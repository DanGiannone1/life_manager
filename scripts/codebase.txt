Here is my codebase:

<File: backend/app.py>
from flask import Flask, request, jsonify, make_response
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address
from flask_cors import CORS
from datetime import datetime, timezone
from typing import Dict, Any, List, Optional, TypedDict, Union
import os
import uuid
from dotenv import load_dotenv
from cosmos_db import CosmosDBManager
import humps
import traceback

# Load environment variables
load_dotenv()

# Initialize Flask app
app = Flask(__name__)
CORS(app)  # Enable CORS for all routes

# Initialize rate limiter
limiter = Limiter(
    app=app,
    key_func=get_remote_address,
    default_limits=["600 per day", "150 per hour"]
)

# Initialize CosmosDB manager
cosmos_db = CosmosDBManager()

class ApiResponse(TypedDict):
    success: bool
    data: Optional[Dict[str, Any]]
    error: Optional[Dict[str, Any]]
    metadata: Optional[Dict[str, Any]]

def create_api_response(
    success: bool,
    data: Optional[Dict[str, Any]] = None,
    error: Optional[Dict[str, Any]] = None,
    metadata: Optional[Dict[str, Any]] = None
) -> ApiResponse:
    """Create a standardized API response following the design document format."""
    response: ApiResponse = {
        "success": success,
        "data": data,
        "error": error,
        "metadata": {
            "timestamp": datetime.now(timezone.utc).isoformat(),
            "requestId": request.headers.get("X-Request-ID", ""),
            **(metadata or {})
        }
    }
    return response

def add_rate_limit_headers(response):
    """Add rate limit headers to the response."""
    if hasattr(request, "view_rate_limit"):
        window_stats = getattr(request, "view_rate_limit")
        response.headers.add(
            "X-RateLimit-Limit",
            str(window_stats.limit)
        )
        response.headers.add(
            "X-RateLimit-Remaining",
            str(window_stats.remaining)
        )
        response.headers.add(
            "X-RateLimit-Reset",
            str(window_stats.reset)
        )
    return response

# Fields that need case conversion for their values
CASE_CONVERTIBLE_FIELDS = ["status"]  # Add more fields here as needed

def convert_case(value: str, to_camel: bool) -> str:
    """Convert a string between snake_case and camelCase."""
    if to_camel:
        return humps.camelize(value)
    return humps.decamelize(value)

def convert_enum_values(data: Union[Dict, List], is_snake_to_camel: bool) -> Union[Dict, List]:
    """Convert enumerated values between snake_case and camelCase."""
    if isinstance(data, list):
        return [convert_enum_values(item, is_snake_to_camel) for item in data]
    
    if not isinstance(data, dict):
        return data
    
    result = {}
    for key, value in data.items():
        if isinstance(value, (dict, list)):
            value = convert_enum_values(value, is_snake_to_camel)
        elif isinstance(value, str) and key in CASE_CONVERTIBLE_FIELDS:
            value = convert_case(value, is_snake_to_camel)
        result[key] = value
    return result

def snake_to_camel(data: Union[Dict, List]) -> Union[Dict, List]:
    """Convert snake_case keys to camelCase and convert enumerated values."""
    # First convert the enum values
    data = convert_enum_values(data, is_snake_to_camel=True)
    # Then convert the keys
    return humps.camelize(data)

def camel_to_snake(data: Union[Dict, List]) -> Union[Dict, List]:
    """Convert camelCase keys to snake_case and convert enumerated values."""
    # First convert the keys
    data = humps.decamelize(data)
    # Then convert the enum values
    return convert_enum_values(data, is_snake_to_camel=False)

@app.errorhandler(Exception)
def handle_error(error: Exception) -> tuple[Dict[str, Any], int]:
    """Global error handler to ensure consistent error responses."""
    if hasattr(error, "code") and hasattr(error, "description"):
        # Handle Flask/HTTP errors
        status_code = error.code
        error_message = error.description
    else:
        # Handle other exceptions
        status_code = 500
        error_message = str(error)

    app.logger.error(f"Error: {error}")
    app.logger.error(traceback.format_exc())

    response = create_api_response(
        success=False,
        error={
            "code": status_code,
            "message": error_message
        }
    )
    return jsonify(response), status_code

@app.route("/api/v1/user-data", methods=["GET"])
@limiter.limit("180 per hour")
def get_user_data():
    """
    Get all data for a user (tasks, goals, categories, dashboard).
    Rate limit: 180 requests per hour
    """
    try:
        # Get user_id from auth token (placeholder - implement actual auth)
        user_id = request.headers.get("X-User-ID")
        user_id = "test-user"
        print("Fetching user data for user_id:", user_id)
        if not user_id:
            raise ValueError("User ID is required")

        # Get all user data using the new get_user_data method
        user_data = cosmos_db.get_user_data(user_id)

        # Convert to camelCase for frontend
        response_data = {
            "tasks": snake_to_camel(user_data["tasks"]),
            "goals": snake_to_camel(user_data["goals"]),
            "categories": snake_to_camel(user_data["categories"]),
            "dashboard": snake_to_camel(user_data["dashboard"]) if user_data["dashboard"] else None,
            "lastSyncedAt": datetime.now(timezone.utc).isoformat()
        }

        response = make_response(jsonify(create_api_response(success=True, data=response_data)))
        return add_rate_limit_headers(response)

    except Exception as e:
        raise

@app.route("/api/v1/sync", methods=["POST"])
@limiter.limit("360 per minute")
def sync_changes():
    """
    Sync changes between frontend and backend.
    Rate limit: 360 requests per minute
    """
    try:
        # Get user_id from auth token (placeholder - implement actual auth)
        user_id = request.headers.get("X-User-ID")
        user_id = "test-user"
        if not user_id:
            raise ValueError("User ID is required")

        # Get request data
        data = request.get_json()
        if not data:
            raise ValueError("Request body is required")

        changes = data.get("changes", [])
        client_last_sync = data.get("clientLastSync")

        if not client_last_sync:
            raise ValueError("clientLastSync is required")

        # Process each change
        server_changes = []
        has_errors = False

        for change in changes:
            change_type = change.get("type")
            operation = change.get("operation")
            item_id = change.get("id")
            item_data = camel_to_snake(change.get("data", {}))

            if item_data:
                item_data["user_id"] = user_id
                item_data["type"] = change_type
                item_data["updated_at"] = datetime.now(timezone.utc).isoformat()

            try:
                if operation == "create":
                    if not item_data:
                        raise ValueError("Data is required for create operation")
                    item_data["id"] = item_id or str(uuid.uuid4())
                    result = cosmos_db.create_item(item_data)
                    if result:
                        server_changes.append({
                            "type": change_type,
                            "operation": "create",
                            "id": result["id"],
                            "data": snake_to_camel(result),
                            "timestamp": result["updated_at"]
                        })

                elif operation == "update":
                    if not item_id:
                        raise ValueError("Item ID is required for update operation")
                    result = cosmos_db.update_item(item_id, item_data)
                    if result:
                        server_changes.append({
                            "type": change_type,
                            "operation": "update",
                            "id": result["id"],
                            "data": snake_to_camel(result),
                            "timestamp": result["updated_at"]
                        })

                elif operation == "delete":
                    if not item_id:
                        raise ValueError("Item ID is required for delete operation")
                    if cosmos_db.delete_item(item_id, user_id):
                        server_changes.append({
                            "type": change_type,
                            "operation": "delete",
                            "id": item_id,
                            "timestamp": datetime.now(timezone.utc).isoformat()
                        })

            except Exception as operation_error:
                app.logger.error(f"Error processing change: {operation_error}")
                app.logger.error(traceback.format_exc())
                has_errors = True
                error_response = create_api_response(
                    success=False,
                    error=str(operation_error),
                    data={"serverChanges": server_changes}
                )
                response = make_response(jsonify(error_response), 500)
                return add_rate_limit_headers(response)

        # Only proceed with server changes if no errors occurred
        if not has_errors:
            # Get any server-side changes newer than client_last_sync
            server_items = cosmos_db.get_changes_since(user_id, client_last_sync)

            # Add server items to server_changes if they're not already included
            processed_ids = {change["id"] for change in server_changes}
            for item in server_items:
                if item["id"] not in processed_ids:
                    server_changes.append({
                        "type": item["type"],
                        "operation": "update",
                        "id": item["id"],
                        "data": snake_to_camel(item),
                        "timestamp": item["updated_at"]
                    })

            response_data = {
                "serverChanges": server_changes,
                "syncedAt": datetime.now(timezone.utc).isoformat()
            }

            response = make_response(jsonify(create_api_response(success=True, data=response_data)))
            return add_rate_limit_headers(response)

    except Exception as e:
        app.logger.error(f"Unexpected error in sync: {e}")
        app.logger.error(traceback.format_exc())
        error_response = create_api_response(success=False, error=str(e))
        response = make_response(jsonify(error_response), 500)
        return add_rate_limit_headers(response)

if __name__ == "__main__":
    app.run(debug=True)

--------------------------------------------------------------------------------
<File: backend/cosmos_db.py>
# File: backend/cosmos_db.py

import os
from typing import List, Dict, Any, Optional
from dotenv import load_dotenv
from azure.cosmos import CosmosClient, exceptions, PartitionKey
from azure.cosmos.container import ContainerProxy
from azure.cosmos.database import DatabaseProxy
from azure.identity import DefaultAzureCredential
from datetime import datetime, timezone, timedelta
import traceback

class CosmosDBManager:
    def __init__(self, cosmos_host=None, cosmos_database_id=None, cosmos_container_id=None):
        self._load_env_variables(cosmos_host, cosmos_database_id, cosmos_container_id)
        self.client = self._get_cosmos_client()
        self.database: Optional[DatabaseProxy] = None
        self.container: Optional[ContainerProxy] = None
        self._initialize_database_and_container()

    def _load_env_variables(self, cosmos_host=None, cosmos_database_id=None, cosmos_container_id=None):
        load_dotenv()
        self.cosmos_host = cosmos_host or os.environ.get("COSMOS_HOST")
        self.cosmos_database_id = cosmos_database_id or os.environ.get("COSMOS_DATABASE_ID")
        self.cosmos_container_id = cosmos_container_id or os.environ.get("COSMOS_CONTAINER_ID")
        self.tenant_id = os.environ.get("TENANT_ID", '16b3c013-d300-468d-ac64-7eda0820b6d3')

        if not all([self.cosmos_host, self.cosmos_database_id, self.cosmos_container_id]):
            raise ValueError("Cosmos DB configuration is incomplete")

    def _get_cosmos_client(self) -> CosmosClient:
        print("Initializing Cosmos DB client")
        print("Using DefaultAzureCredential for Cosmos DB authentication")
        credential = DefaultAzureCredential(
            interactive_browser_tenant_id=self.tenant_id,
            visual_studio_code_tenant_id=self.tenant_id,
            workload_identity_tenant_id=self.tenant_id,
            shared_cache_tenant_id=self.tenant_id
        )
        return CosmosClient(self.cosmos_host, credential=credential)

    def _initialize_database_and_container(self) -> None:
        try:
            self.database = self._create_or_get_database()
            self.container = self._create_or_get_container()
        except exceptions.CosmosHttpResponseError as e:
            print(f'An error occurred: {e.message}')
            raise

    def _create_or_get_database(self) -> DatabaseProxy:
        try:
            database = self.client.create_database(id=self.cosmos_database_id)
            print(f'Database with id \'{self.cosmos_database_id}\' created')
        except exceptions.CosmosResourceExistsError:
            database = self.client.get_database_client(self.cosmos_database_id)
            print(f'Database with id \'{self.cosmos_database_id}\' was found')
        return database

    def _create_or_get_container(self) -> ContainerProxy:
        try:
            container = self.database.create_container(
                id=self.cosmos_container_id, 
                partition_key=PartitionKey(path='/user_id')
            )
            print(f'Container with id \'{self.cosmos_container_id}\' created')
        except exceptions.CosmosResourceExistsError:
            container = self.database.get_container_client(self.cosmos_container_id)
            print(f'Container with id \'{self.cosmos_container_id}\' was found')
        return container

    # Core CRUD Operations
    def get_item_by_id(self, item_id: str, user_id: str) -> Optional[Dict[str, Any]]:
        """Get a single item by its ID and user_id (partition key)."""
        try:
            item = self.container.read_item(item=item_id, partition_key=user_id)
            return item
        except exceptions.CosmosResourceNotFoundError:
            return None
        except Exception as e:
            print(f"Error retrieving item {item_id}: {str(e)}")
            raise

    def create_item(self, item: Dict[str, Any]) -> Dict[str, Any]:
        """Create a new item in the container."""
        try:
            if 'user_id' not in item:
                raise ValueError("user_id (partition key) is required for create operation")
            
            # Ensure timestamps are set
            current_time = datetime.now(timezone.utc).isoformat()
            item['created_at'] = current_time
            item['updated_at'] = current_time
            
            created_item = self.container.create_item(body=item)
            print(f"Item created with id: {created_item['id']}")
            return created_item
        except exceptions.CosmosResourceExistsError:
            print(f"Item with id {item.get('id')} already exists")
            raise
        except Exception as e:
            print(f"Error creating item: {str(e)}")
            raise

    def update_item(self, item_id: str, updates: Dict[str, Any]) -> Dict[str, Any]:
        """Update an existing item with new values."""
        try:
            # Get the existing item
            existing_item = self.get_item_by_id(item_id, updates['user_id'])
            if not existing_item:
                raise ValueError(f"Item with id {item_id} not found")

            # Update the item with new values
            existing_item.update(updates)
            existing_item['updated_at'] = datetime.now(timezone.utc).isoformat()

            # Replace the item in the container
            updated_item = self.container.replace_item(
                item=item_id,
                body=existing_item
            )
            return updated_item
        except Exception as e:
            print(f"Error updating item {item_id}: {str(e)}")
            raise

    def delete_item(self, item_id: str, user_id: str) -> bool:
        """Delete an item by its ID."""
        try:
            self.container.delete_item(item=item_id, partition_key=user_id)
            return True
        except exceptions.CosmosResourceNotFoundError:
            return False
        except Exception as e:
            print(f"Error deleting item {item_id}: {str(e)}")
            raise

    def get_user_data(self, user_id: str) -> Dict[str, List[Dict[str, Any]]]:
        """Get all data for a user (tasks, goals, categories, dashboard)."""
        try:
            query = """
            SELECT * FROM c 
            WHERE c.user_id = @user_id
            """
            items = list(self.container.query_items(
                query=query,
                parameters=[{"name": "@user_id", "value": user_id}],
                enable_cross_partition_query=False
            ))

            # Organize items by type
            result = {
                "tasks": [],
                "goals": [],
                "categories": [],
                "dashboard": None
            }

            for item in items:
                item_type = item.get("type")
                if item_type == "task":
                    result["tasks"].append(item)
                elif item_type == "goal":
                    result["goals"].append(item)
                elif item_type == "category":
                    result["categories"].append(item)
                elif item_type == "dashboard":
                    result["dashboard"] = item

            return result
        except Exception as e:
            print(f"Error getting user data: {str(e)}")
            raise

    def get_changes_since(self, user_id: str, since_timestamp: str) -> List[Dict[str, Any]]:
        """Get all items that have been updated since a given timestamp."""
        try:
            query = """
            SELECT * FROM c 
            WHERE c.user_id = @user_id 
            AND c.updated_at > @since_timestamp
            """
            items = list(self.container.query_items(
                query=query,
                parameters=[
                    {"name": "@user_id", "value": user_id},
                    {"name": "@since_timestamp", "value": since_timestamp}
                ],
                enable_cross_partition_query=False
            ))
            return items
        except Exception as e:
            print(f"Error getting changes since timestamp: {str(e)}")
            raise



--------------------------------------------------------------------------------
<File: backend/testing.py>

from cosmos_db import CosmosDBManager
from datetime import datetime, timedelta, timezone
import uuid

def cleanup_test_data(cosmos_manager: CosmosDBManager, user_id: str):
    """Delete all existing documents for the test user"""
    try:
        # Query for all items belonging to this user
        query = "SELECT * FROM c WHERE c.user_id = @user_id"
        items = list(cosmos_manager.container.query_items(
            query=query,
            parameters=[{"name": "@user_id", "value": user_id}],
            enable_cross_partition_query=False
        ))
        
        # Delete each item
        for item in items:
            cosmos_manager.delete_item(item['id'], user_id)
            print(f"Deleted existing item: {item['id']}")
        
        print(f"Cleaned up {len(items)} existing items for user {user_id}")
    except Exception as e:
        print(f"Error during cleanup: {str(e)}")
        raise

def create_iso_date(days_from_now=0):
    """Create ISO formatted date string for a date N days from now"""
    date = datetime.now(timezone.utc) + timedelta(days=days_from_now)
    return date.isoformat()

def generate_sample_tasks():
    """Generate 5 sample tasks with different characteristics"""
    test_user_id = "test-user"
    
    tasks = [
        {
            "id": str(uuid.uuid4()),
            "user_id": test_user_id,
            "type": "task",
            
            "title": "Daily Exercise Routine",
            "status": "not_started",
            "priority": 80,
            "dynamic_priority": 85,
            "effort": 3,
            "notes": "30 minutes of cardio followed by strength training",
            "due_date": create_iso_date(1),
            "scheduled_date": create_iso_date(1),
            "completion_history": [],
            "recurrence": {
                "is_recurring": True,
                "rule": {
                    "frequency": "daily",
                    "interval": 1,
                    "days_of_week": [0, 1, 2, 3, 4]  # Weekdays only
                }
            }
        },
        {
            "id": str(uuid.uuid4()),
            "user_id": test_user_id,
            "type": "task",
            
            "title": "Quarterly Financial Review",
            "status": "working_on_it",
            "priority": 90,
            "dynamic_priority": 95,
            "effort": 5,
            "notes": "Review Q1 financial statements and prepare report",
            "due_date": create_iso_date(14),
            "scheduled_date": None,
            "completion_history": [],
            "recurrence": {
                "is_recurring": False,
                "rule": None
            }
        },
        {
            "id": str(uuid.uuid4()),
            "user_id": test_user_id,
            "type": "task",
            
            "title": "Weekly Team Meeting",
            "status": "not_started",
            "priority": 70,
            "dynamic_priority": 70,
            "effort": 2,
            "notes": None,
            "due_date": None,
            "scheduled_date": create_iso_date(7),
            "completion_history": [],
            "recurrence": {
                "is_recurring": True,
                "rule": {
                    "frequency": "weekly",
                    "interval": 1,
                    "days_of_week": [1],  # Monday
                    "day_of_month": None,
                    "months": None,
                    "week_of_month": None
                }
            }
        },
        {
            "id": str(uuid.uuid4()),
            "user_id": test_user_id,
            "type": "task",
            
            "title": "Read 'Deep Work' Book",
            "status": "working_on_it",
            "priority": 40,
            "dynamic_priority": 45,
            "effort": 3,
            "notes": "Complete chapters 4-6",
            "due_date": create_iso_date(30),
            "scheduled_date": None,
            "completion_history": [],
            "recurrence": {
                "is_recurring": False,
                "rule": None
            }
        },
        {
            "id": str(uuid.uuid4()),
            "user_id": test_user_id,
            "type": "task",
            
            "title": "Update Personal Website",
            "status": "complete",
            "priority": 60,
            "dynamic_priority": 0,  # Completed tasks have 0 dynamic priority
            "effort": 4,
            "notes": "Refresh portfolio and add recent projects",
            "due_date": create_iso_date(-2),
            "scheduled_date": None,
            "completion_history": [{
                "completed_at": create_iso_date(-1),
                "next_due_date": None,
                "completion_notes": "Added three new projects and updated bio"
            }],
            "recurrence": {
                "is_recurring": False,
                "rule": None
            }
        }
    ]
    
    return tasks

def main():
    try:
        # Initialize the CosmosDB manager
        cosmos_manager = CosmosDBManager()
        
        # Clean up any existing test data
        print("\nCleaning up existing test data...")
        cleanup_test_data(cosmos_manager, "test-user")
        
        print("\nGenerating and loading new test data...")
        # Generate sample tasks
        tasks = generate_sample_tasks()
        
        # Create each task in Cosmos DB
        created_tasks = []
        for task in tasks:
            try:
                # Note: create_item will automatically add created_at and updated_at
                created_task = cosmos_manager.create_item(task)
                created_tasks.append(created_task)
                print(f"Created task: {created_task['title']}")
            except Exception as e:
                print(f"Error creating task '{task['title']}': {str(e)}")
        
        # Verify the data was loaded
        user_data = cosmos_manager.get_user_data("test-user")
        print(f"\nSuccessfully loaded {len(user_data['tasks'])} tasks for test-user")
        
        # Print sample verification data
        if created_tasks:
            sample_task = created_tasks[0]
            print("\nSample task verification:")
            print(f"ID: {sample_task['id']}")
            print(f"Created At: {sample_task['created_at']}")
            print(f"Updated At: {sample_task['updated_at']}")
            print(f"Title: {sample_task['title']}")
            print(f"Status: {sample_task['status']}")
        
    except Exception as e:
        print(f"Error in main: {str(e)}")

if __name__ == "__main__":
    main()
--------------------------------------------------------------------------------
<File: docs/design_document.md>
# Life Manager Design Document

## Table of Contents

1. [Core Architecture](#core-architecture)
   - [Technology Stack](#technology-stack)
   - [State Management](#state-management)
   - [Data Flow & Sync Strategy](#data-flow--sync-strategy)

2. [Data Models](#data-models)
   - [Frontend Data Models (TypeScript)](#frontend-data-models-typescript)
     - [Interface Usage Guidelines](#interface-usage-guidelines)
     - [Common Types](#common-types)
     - [Task Interface](#task-interface)
   - [Backend Data Models (CosmosDB)](#backend-data-models-cosmosdb)
     - [Container Strategy & Querying](#container-strategy--querying)
     - [Indexing Strategy](#indexing-strategy)
     - [Document Models](#document-models)

3. [APIs](#apis)
   - [Base URL](#base-url)
   - [Common Response Format](#common-response-format)
   - [Error Codes](#error-codes)
   - [Core Endpoints](#core-endpoints)

4. [Logging](#logging)
   - [Initial Load](#initial-load)
   - [State Changes](#state-changes)
   - [Backend Sync Operations](#backend-sync-operations)

5. [Features & Implementation](#features--implementation)
   - [Sidebar & Top Panel](#sidebar--top-panel)
   - [Home Page](#home-page)
   - [Weekly Plan Page](#weekly-plan-page)
   - [Master List Page](#master-list-page)
   
6. [Styling & UI](#styling--ui)
    - [High-Level Strategy](#high-level-strategy)
    - [Layout Architecture](#layout-architecture)
    - [Design Tokens](#design-tokens)
    - [Interactive Elements](#interactive-elements)
    - [Component Architecture](#component-architecture)





## Core Architecture

### Technology Stack
- Frontend: React/Vite, TailwindCSS, Shadcn Components, Redux Toolkit
- Backend: Python, Flask
- Database: CosmosDB

### State Management

#### Global State (Redux)
All persistent data lives in Redux, serving as the single source of truth for the application. This includes:

1. **User Data**
   - Tasks

2. **Application State**
   - Sync status (success, error)
   - Last sync timestamp

3. **Store Structure**
```typescript
interface RootState {
    tasks: {
        items: Record<UUID, Task>;
        loading: boolean;
        error: string | null;
    };
    sync: {
        status: 'idle' | 'syncing' | 'error';
        lastSynced: string | null;
        pendingChanges: number;
    };
}
```

#### Local State
Used only for temporary UI states within components:
- Form input values before submission
- Modal/dropdown open/closed states
- Component-specific loading states
- Any temporary data that doesn't need to persist

### Data Flow & Sync Strategy

#### User Login / Initial Load
```mermaid
flowchart LR
    DB[(CosmosDB)] --> 
    API[(/api/v1/user-data)] --> 
    Store[(Redux Store)] --> 
    UI[Application UI]

    classDef storeNode fill:#FF8C00,stroke:#333,stroke-width:2px,color:white
    classDef apiNode fill:#50C878,stroke:#333,stroke-width:2px,color:white
    classDef dbNode fill:#FF69B4,stroke:#333,stroke-width:2px,color:white
    classDef uiNode fill:#9370DB,stroke:#333,stroke-width:2px,color:white

    class Store storeNode
    class API apiNode
    class DB dbNode
    class UI uiNode
```



#### User Interactions
```mermaid
flowchart LR
    Actions[User Actions] -->
    Store[(Redux Store)] -->
    UI[Application UI]
    Store -.->|Debounced Sync| API[(/api/v1/user-data)] -->
    DB[(CosmosDB)]

    classDef storeNode fill:#FF8C00,stroke:#333,stroke-width:2px,color:white
    classDef apiNode fill:#50C878,stroke:#333,stroke-width:2px,color:white
    classDef actionNode fill:#4169E1,stroke:#333,stroke-width:1px,color:white
    classDef dbNode fill:#FF69B4,stroke:#333,stroke-width:2px,color:white
    classDef uiNode fill:#9370DB,stroke:#333,stroke-width:2px,color:white

    class Store storeNode
    class API apiNode
    class Actions actionNode
    class DB dbNode
    class UI uiNode
```


#### 1. Initial Load
```
// In the application's root component (e.g., _app.tsx)
// On initial load:
// 1. Dispatch a loading action to set the application state to loading.
// 2. Call the API to fetch initial user data.
// 3. On successful data fetch:
//    - Dispatch an action to initialize the Redux store with the fetched data.
// 4. On error:
//    - Dispatch an action to set the error state with the error message.
// 5. Finally:
//    - Dispatch a loading action to set the application state to not loading.
```

#### 2. State Updates
```
// The useStateSync hook provides a consistent way to handle state updates.
// It takes a change type (e.g., 'text', 'status', 'priority', 'drag') and an item with changes.
// 1. On change:
//    - Dispatch a Redux action to immediately update the store with the changes.
//      This dispatch triggers a Redux reducer that updates the state.
//    - Trigger a debounced backend sync operation based on the change type.
// The hook returns a handleChange function that components can use to update state.
// The SYNC_CONFIG object defines the debounce time for each change type.
```

#### 3. Component Integration
```
// All components use the same state management pattern to handle data modifications.
// For example, a TaskCard component:
// 1. Uses the handleChange function from useStateSync.
// 2. When the task title input changes:
//    - Calls handleChange with the 'text' change type, the task object, and the new title.
// 3. When the task status changes:
//    - Calls handleChange with the 'status' change type, the task object, and the new status and updated status history.
```

#### 4. Sync Status Management
```
// The SyncIndicator component provides visual feedback on the sync status.
// 1. It uses a Redux selector to get the current sync state.
// 2. If the sync status is 'syncing', it displays a spinner.
// 3. If the sync status is 'error', it displays an error icon.
//    The error icon will be displayed during retry attempts and after all retries have failed.
// 4. If the sync status is 'idle' and there is a last synced timestamp, it displays the last saved time.
```

#### 5. Error Handling
```
// The handleSyncError function handles failed sync operations.
// 1. It takes an error object and an optional retry attempt counter.
// 2. If the retry attempt is less than the maximum number of retries:
//    - It waits for an exponentially increasing amount of time.
//    - It calls the performSync function to retry the sync operation.
// 3. If the maximum number of retries is reached:
//    - It dispatches an action to set the sync error state with the error message.
```


This architecture provides:
- Single source of truth in Redux
- Consistent state update pattern
- Optimistic updates with backend sync
- Clear sync status feedback
- Automatic error handling and retries
- Simple component integration

## Data Models

### Frontend Data Models (TypeScript)

#### Interface Usage Guidelines

1. **Strict Type Adherence**
   - All frontend components must strictly implement these interfaces
   - No extending interfaces without documentation and team review
   - No bypassing optional fields with type assertions (`!` or `as`)
   - All interface extensions must be backwards compatible

2. **State Management**
   - Redux store must maintain normalized data matching these interfaces
   - All API responses must be validated against these interfaces
   - No storing derived data that can be computed from interface fields
   - Use selectors for computing derived data

3. **Component Props**
   - Components should accept the smallest necessary subset of interfaces
   - Use TypeScript utility types to create precise prop interfaces:
     ```typescript
     // Good
     interface TaskTitleProps {
         task: Pick<Task, 'id' | 'title'>;
     }

     // Avoid
     interface TaskTitleProps {
         task: Task;  // Exposes unnecessary fields
     }
     ```
   - Document required vs optional props

4. **Modification Rules**
   - Interface changes require documentation update
   - Breaking changes must be versioned
   - Additions to interfaces must be optional fields
   - Update all relevant type definitions when modifying interfaces

#### Common Types
```typescript
type UUID = string;
type ISODateString = string;

type Status = 'notStarted' | 'workingOnIt' | 'complete';
type RecurrenceFrequency = 'daily' | 'weekly' | 'monthly' | 'yearly';
type TimeRange = 'day' | 'week' | 'month';

interface CompletionEntry {
    completedAt: ISODateString;
    nextDueDate?: ISODateString;
    completionNotes?: string;
}

interface RecurrenceRule {
    frequency: RecurrenceFrequency;
    interval: number;
    endDate?: ISODateString;
    maxOccurrences?: number;
    daysOfWeek?: number[];  // 0-6 for weekly
    dayOfMonth?: number;    // 1-31 for monthly
    months?: number[];      // 1-12 for yearly
    weekOfMonth?: number;   // -1 to 5 (-1 for last)
}
```

#### Task Interface
```typescript
interface Task {
    id: UUID;
    userId: UUID;
    type: 'task';
    title: string;
    status: Status;
    priority: number;
    dynamicPriority: number;
    effort?: number;
    notes?: string;
    dueDate?: ISODateString;
    scheduledDate?: ISODateString;
    createdAt: ISODateString;
    updatedAt: ISODateString;
    
    completionHistory: CompletionEntry[];
    
    recurrence?: {
        isRecurring: boolean;
        rule?: RecurrenceRule;
    };
    
    tags?: string[];
}
```

### Display Mappings

#### Status Display Mapping
```typescript
const STATUS_DISPLAY = {
    notStarted: 'Not Started',
    workingOnIt: 'Working on It',
    complete: 'Complete'
};

const STATUS_COLORS = {
    notStarted: 'gray.500',
    workingOnIt: 'yellow.500',
    complete: 'green.500'
};
```

#### Priority Display Mapping
```typescript
const PRIORITY_DISPLAY = {
    ranges: [
        { min: 80, label: 'Very High', color: 'red.500' },
        { min: 60, label: 'High', color: 'orange.500' },
        { min: 40, label: 'Medium', color: 'yellow.500' },
        { min: 20, label: 'Low', color: 'green.500' },
        { min: 0, label: 'Very Low', color: 'green.250' }
    ]
};
```

#### Effort Display Mapping
```typescript
const EFFORT_DISPLAY = {
    1: {
        label: 'Very Low',
        color: 'green.300'  // Light green for minimal effort
    },
    2: {
        label: 'Low',
        color: 'green.500'  // Medium green for low effort
    },
    3: {
        label: 'Medium',
        color: 'yellow.500'  // Yellow for moderate effort
    },
    4: {
        label: 'High',
        color: 'orange.500'  // Orange for high effort
    },
    5: {
        label: 'Very High',
        color: 'red.500'  // Red for maximum effort
    }
};
```

#### Time Range Display Mapping
```typescript
const TIME_RANGE_DISPLAY = {
    day: 'Daily',
    week: 'Weekly',
    month: 'Monthly'
};
```

### Backend Data Models (CosmosDB)

All variable names are in snake_case. All documents are stored in a single container to enable efficient querying of a user's complete data set.
The frontend uses camelCase for its data models. A manual conversion process is used to handle the differences in naming conventions during API requests and responses.

#### Case Conversion Functions

All data transformations between the backend's `snake_case` data models and the frontend's `camelCase` data models are handled on the backend. This ensures that the frontend receives data in the expected format without needing to perform any conversion logic.

The backend uses two types of case conversion:

1. **Key Case Conversion**: All object keys are converted between snake_case and camelCase.
   ```python
   # Example key conversion:
   "user_id" <-> "userId"
   "created_at" <-> "createdAt"
   "due_date" <-> "dueDate"
   ```

2. **Value Case Conversion**: Certain enumerated string values are also converted between cases.
   ```python
   # Fields that need value case conversion:
   CASE_CONVERTIBLE_FIELDS = ["status"]  # Add more fields as needed

   # Example value conversion for status:
   "not_started" <-> "notStarted"
   "working_on_it" <-> "workingOnIt"
   ```

The conversion process:
1. For frontend responses (snake_to_camel):
   - First converts enumerated values to camelCase
   - Then converts all keys to camelCase

2. For backend storage (camel_to_snake):
   - First converts all keys to snake_case
   - Then converts enumerated values to snake_case

This approach:
- Centralizes the transformation logic
- Makes it easy to add new fields that need value conversion
- Ensures consistency across all API responses
- Simplifies frontend code by removing the need for any data conversion logic
- Makes debugging easier with explicit string manipulation

#### Container Strategy & Querying
The application uses a single container strategy where:
- All task documents live in one container
- Documents are partitioned by `user_id`
- The `type` field enables filtering within a user's partition
- Single query can efficiently retrieve all data for a user

Example query to get all user data:
```sql
SELECT * FROM c
WHERE c.user_id = @userId
```

#### Indexing Strategy
The container uses these indexes to optimize common query patterns:
```json
{
    "indexingPolicy": {
        "includedPaths": [
            {
                "path": "/user_id/?",
                "indexes": [
                    {
                        "kind": "Range",
                        "dataType": "String"
                    }
                ]
            },
            {
                "path": "/type/?",
                "indexes": [
                    {
                        "kind": "Range",
                        "dataType": "String"
                    }
                ]
            },
            {
                "path": "/updated_at/?",
                "indexes": [
                    {
                        "kind": "Range",
                        "dataType": "String"
                    }
                ]
            }
        ]
    }
}
```

#### Document Models

##### Task Document
```json
{
    // Metadata
    "id": "string (UUID)",
    "user_id": "string (UUID)",
    "type": "task",
    "partition_key": "string (user_id)",
    
    // Core Fields
    "title": "string",
    "status": "string (enum: not_started, working_on_it, complete)",
    "priority": "number (0-100)",
    "dynamic_priority": "number (0-100)",
    "effort": "number (1-5, optional)",
    "notes": "string (optional)",
    
    // Dates
    "due_date": "string (ISO date, optional)",
    "scheduled_date": "string (ISO date, optional)",
    "created_at": "string (ISO date)",
    "updated_at": "string (ISO date)",
    
    "completion_history": [
        {
            "completed_at": "string (ISO date)",
            "next_due_date": "string (ISO date, optional)",
            "completion_notes": "string (optional)"
        }
    ],
    

    // Recurrence
    "recurrence": {
        "is_recurring": "boolean",
        "rule": {
            "frequency": "string (enum: daily, weekly, monthly, yearly)",
            "interval": "number",
            "days_of_week": "number[] (0-6, optional)",
            "day_of_month": "number (1-31, optional)",
            "months": "number[] (1-12, optional)",
            "week_of_month": "number (-1 to 5, optional)"
        }
    }

}
```

## APIs

### Base URL
```
https://api.lifemanager.app/v1
```

### Common Response Format
All API responses follow a consistent format:

```typescript
interface ApiResponse<T> {
    success: boolean;
    data?: T;
    error?: {
        code: string;
        message: string;
        details?: any;
    };
    metadata?: {
        timestamp: string;
        requestId: string;
        pagination?: {
            total: number;
            page: number;
            pageSize: number;
            hasMore: boolean;
        };
    };
}
```

### Error Codes
Standard HTTP status codes are used along with custom error codes.
The API response will include the HTTP status code and the custom error code in the error object.

| HTTP Status | Error Code | Description |
|------------|------------|-------------|
| 400 | INVALID_REQUEST | Malformed request or invalid parameters |
| 404 | NOT_FOUND | Resource not found |
| 409 | CONFLICT | Resource conflict (e.g., duplicate) |
| 422 | VALIDATION_ERROR | Request validation failed |
| 500 | INTERNAL_ERROR | Server error |
| 503 | SERVICE_UNAVAILABLE | Service temporarily unavailable |

### Core Endpoints

#### Initial Data Load
```http
GET /api/v1/user-data
Description: Loads all user data at application startup. This is the only bulk data fetch operation.

Response: {
    success: true,
    data: {
        tasks: Record<UUID, Task>;
        lastSyncedAt: string; // ISO date
    }
}
```

#### Sync Changes
```http
POST /api/v1/sync
Description: Debounced endpoint that receives changes from the frontend. Called automatically after user actions with configured debounce times per change type.

Request Body: {
    changes: Array<{
        type: 'task';
        operation: 'create' | 'update' | 'delete';
        id?: UUID;  // Required for update/delete
        data?: Partial<Task>;  // Required for create/update
        timestamp: string;  // ISO date of when change occurred
        changeType?: 'text' | 'status' | 'priority' | 'drag';  // For debounce configuration
    }>;
    clientLastSync: string;  // ISO date of last successful sync
}

Response: {
    success: true,
    data: {
        // Only sent if server has newer changes
        serverChanges?: Array<{
            type: 'task';
            operation: 'create' | 'update' | 'delete';
            id: UUID;
            data?: any;
            timestamp: string;
        }>;
        syncedAt: string;  // ISO date of this sync
    }
}
```

###  Logging

#### Initial Load
On application load, the entire Redux state is logged to the console:
```typescript
// In store configuration
const store = configureStore({
  reducer: rootReducer,
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware().concat(logger),
});

// Custom logger middleware
const logger = store => next => action => {
  if (action.type === '@@INIT') {
    console.log('Initial Redux State:', store.getState());
  }
  return next(action);
};
```

#### State Changes
Every Redux state change is logged to the console with:
- The action type
- The specific state changes (diff)
- Timestamp of the change

```typescript
// Example console output for a task update
{
  type: 'tasks/updateTask',
  payload: {
    id: '123',
    changes: {
      title: 'Updated Task Title',
      status: 'workingOnIt'
    }
  },
  timestamp: '2024-01-20T12:34:56.789Z'
}
```

#### Backend Sync Operations
Each sync operation is logged with:
- The changes being synced
- The sync result (success/failure)
- Any error messages if applicable

```typescript
// Example console output for sync operation
{
  type: 'sync/started',
  changes: [
    {
      type: 'task',
      operation: 'update',
      id: '123',
      data: { title: 'Updated Task Title' }
    }
  ],
  timestamp: '2024-01-20T12:34:57.789Z'
}

// Success case
{
  type: 'sync/completed',
  result: 'success',
  syncedAt: '2024-01-20T12:34:58.789Z'
}

// Failure case
{
  type: 'sync/failed',
  error: {
    code: 'NETWORK_ERROR',
    message: 'Failed to connect to server'
  },
  timestamp: '2024-01-20T12:34:58.789Z'
}
```






## Features & Implementation

### Sidebar & Top Panel

#### Overview
The application includes a persistent global sidebar (on the left) and a top panel (header bar) that remain visible across all pages. These two navigation and control areas ensure quick access to core features and important indicators (sync status, settings, login/logout, etc.).

#### Goals & Requirements

##### Centralized Navigation
- Provide quick links to core pages (Home, Weekly Plan, Master List, etc.)
- Allow easy navigation without refreshing or reloading the application

##### Persistent Visibility
- Remain visible/accessible at all times, regardless of the active page
- Collapse or expand the sidebar in response to user preference or screen size

##### Key Controls in Top Panel
- Settings button for user preferences, theme toggles, or account info
- Sync/Save Indicator to reflect the real-time sync status from the Redux store
- Login/Logout button/indicator to manage authentication state

##### Responsive & Accessible
- Adapt layout for mobile, tablet, and desktop screen sizes
- Provide clear focus states, ARIA labels, and keyboard navigation

#### Layout & Components
```
+------------------------------------------------------------------------+
| [App Logo / Title]            [Sync Indicator]  [Settings]  [Logout]   |
+------------------+-----------------------------------------------------+
|   Sidebar        |  Main Content Area                       |
|   [Nav Links]    |  (Home / Weekly Plan / Master List etc.) |
|   [User Info]    |                                          |
|   [Collapse Btn] |                                          |
+------------------+-----------------------------------------------------+
```

#### Sidebar

##### Navigation Links
- Home
- Weekly Plan
- Master List


##### User Info / Profile Section 
- Empty for now

##### Collapse/Expand Control
- A button (e.g., a hamburger icon or double-chevron) that toggles the sidebar's width
- Uses local React state since it only affects the layout

##### Responsive Behavior
- Mobile: The sidebar may slide in/out over the content
- Desktop: The sidebar remains docked on the left

##### Implementation Details
- Housed in a `<Sidebar>` component, rendered at the same level as the main content
- All navigation items are stored in an array or config object (e.g., `NAV_LINKS = [{ path: '/home', label: 'Home', icon: ... }, ...]`), then mapped to `<NavLink>` items
- Uses local React state for collapse state since it only affects the layout


#### Top Panel

##### Position & Layout
- Stays at the top of the viewport, spanning the full width

##### Content Components
- App Logo or Title: Left-aligned; navigates back to Home or a landing page
- Sync/Save Indicator:
  - Reflects the Redux sync state (idle, syncing, error)
  - Could be a small icon + text (e.g., "All changes saved" or a spinner if syncing)
  - Ties into the same sync slice that other pages use (see Core Architecture > State Management)
  - Top right corner
- Settings Button:
  - Opens a modal or dedicated page with user-configurable settings (theme, notifications, account details, etc.)
  - Could be an icon button that triggers `<SettingsModal>`
  - Inactive for now
  - Top right corner
- Login/Logout Button:
  - Shows "Login" if user is not authenticated, "Logout" if user is authenticated
  - On click, dispatches an auth action or navigates to a login page
  - Top right corner
  - Inactive for now






## Styling & UI

### Core Principles
- Use Tailwind CSS as the primary styling solution
- Configure core design tokens (colors, typography, spacing) in `tailwind.config.js`
- Leverage shadcn/ui components for common UI elements
- Minimize component-specific styling
- Maintain consistent responsive behavior across all pages
- lucide icons

### Global Configuration

#### Tailwind Setup
```javascript
// tailwind.config.js
module.exports = {
  theme: {
    extend: {
      colors: {
        // Core brand colors
        primary: '#1D4ED8',
        secondary: '#9333EA',
        accent: '#F59E0B'
      },
      fontFamily: {
        sans: ['Inter', 'sans-serif']
      }
    }
  }
}
```

#### Component Library
- Use shadcn/ui components for standard UI elements (buttons, inputs, modals)
- Maintain default shadcn styling unless specific requirements dictate otherwise
- Configure component themes through shadcn's built-in theming system

### Layout Structure
- Global layout wrapper handles standard page structure
- Responsive design uses Tailwind's breakpoint system
- Consistent spacing and container widths across pages

### Styling Guidelines
1. Use Tailwind utility classes for layout and basic styling
2. Apply component-specific styles only when required by design specs
3. Keep custom CSS minimal and well-documented
4. Maintain consistent spacing, typography, and color usage across components

### Visual Feedback
- Status indicators follow predefined color schemes
- Loading states use consistent animations
- Error states maintain uniform styling
- Toast notifications follow a standard design pattern
--------------------------------------------------------------------------------
<File: docs/project_structure.md>
life-manager/
├── docs/
│   ├── design_doc.md         # Complete system design document
│   ├── project_structure.md  # This file - explains the project organization
│   └── task_plan.md         # Development tasks and timeline
│
├── backend/
│   ├── app.py               # Routes and business logic
│   ├── cosmos_db.py         # Database operations
│   ├── requirements.txt
│   └── .env
│
├── frontend/
│   ├── index.html
│   ├── package.json
│   ├── vite.config.ts
│   ├── tsconfig.json
│   ├── tailwind.config.js
│   ├── postcss.config.js
│   │
│   ├── src/
│   │   ├── main.tsx         # Application entry point
│   │   ├── App.tsx         # Root component and routing
│   │   │
│   │   ├── components/
│   │   │   ├── ui/         # Add shadcn components as needed
│   │   │   │
│   │   │   └── task/       # Task-specific components
│   │   │       ├── TaskTable.tsx      # Table container & sorting
│   │   │       ├── TaskTableRow.tsx   # Full task info in tabular format
│   │   │       ├── TaskCard.tsx       # Compact, draggable version
│   │   │       └── TaskDetails.tsx    # Shared task display logic
│   │   │
│   │   ├── pages/
│   │   │   ├── HomePage.tsx
│   │   │   ├── WeeklyPlanPage.tsx    # Uses TaskCard for calendar
│   │   │   └── MasterListPage.tsx    # Uses TaskTable + TaskTableRow
│   │   │
│   │   ├── state/
│   │   │   ├── slices/
│   │   │   │   ├── taskSlice.ts      # Task state and reducers
│   │   │   │   └── syncSlice.ts      # Sync state and reducers
│   │   │   ├── logger.ts             # Logging middleware and utilities
│   │   │   └── syncEngine.ts         # Store setup + sync orchestration
│   │   │
│   │   ├── utils/
│   │   │   ├── types.ts     # Interfaces from design doc
│   │   │   └── api.ts       # API client
│   │   │
│   │   └── styles/
│   │       └── globals.css
│   │
│   └── public/
│       └── assets/
│
├── README.md
└── .gitignore


# Frontend Hierarchy

## Root Components

### `App.tsx`
- Root component that provides core setup:
  - Redux Provider configuration
  - Router implementation
  - Implements AppLayout for main structure

### `AppLayout.tsx`
- Main layout wrapper component:
  - Accepts `containerWidth` prop for content control
  - Wraps content in base Layout component
  - Manages container max-width constraints

### `Layout.tsx`
- Base layout component responsible for:
  - Managing sidebar state
  - Implementing core structure:
    - TopPanel
    - Sidebar
    - Main content area
  - Handling responsive behaviors

## Layout Components

### `TopPanel.tsx`
- Header component that displays:
  - Sync status
  - Settings
  - Other top-level controls

### `Sidebar.tsx`
- Navigation sidebar component:
  - Contains main navigation menu
  - Handles collapsible state
--------------------------------------------------------------------------------
<File: docs/task_plan.md>
1. Backend 

[x] - Validate that app.py adheres to the design document and everything is implemented correctly 

2. Frontend

[x] - Create a react vite app with typescript named 'frontend'. Install packages necessary to adhere to design doc. 
[x] - Set up initial configuration (TypeScript, Tailwind, shadcn/ui)
[x] - Create scaffolding for the frontend:
    [x] - Set up Redux store structure (tasks and sync slices)
    [x] - Set up API client and sync engine
    [x] - Create base layout components:
        [x] - Sidebar component with navigation
        [x] - Top panel with sync status
    [ ] - Create core pages:
        [x] - HomePage.tsx
        [x] - WeeklyPlanPage.tsx
        [x] - MasterListPage.tsx
    [ ] - Implement shared task components:
        [ ] - TaskTable.tsx
        [ ] - TaskTableRow.tsx
        [ ] - TaskCard.tsx
        [ ] - TaskDetails.tsx


3. Logging

[x] - Create a logging system that logs to the console and to a file. 


--------------------------------------------------------------------------------
<File: frontend/components.json>
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": false,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.js",
    "css": "src/index.css",
    "baseColor": "gray",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}
--------------------------------------------------------------------------------
<File: frontend/eslint.config.js>
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'

export default tseslint.config(
  { ignores: ['dist'] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ['**/*.{ts,tsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
)

--------------------------------------------------------------------------------
<File: frontend/index.html>
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React + TS</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

--------------------------------------------------------------------------------
<File: frontend/package.json>
{
  "name": "frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@radix-ui/react-checkbox": "^1.1.3",
    "@radix-ui/react-dialog": "^1.1.4",
    "@radix-ui/react-select": "^2.1.4",
    "@radix-ui/react-separator": "^1.1.1",
    "@radix-ui/react-slot": "^1.1.1",
    "@reduxjs/toolkit": "^2.5.0",
    "@types/lodash": "^4.17.14",
    "@types/react-router-dom": "^5.3.3",
    "autoprefixer": "^10.4.20",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "deep-object-diff": "^1.1.9",
    "lodash": "^4.17.21",
    "lucide-react": "^0.471.0",
    "postcss": "^8.4.49",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-redux": "^9.2.0",
    "react-router-dom": "^7.1.1",
    "tailwind-merge": "^2.6.0",
    "tailwindcss": "^3.4.17"
  },
  "devDependencies": {
    "@eslint/js": "^9.17.0",
    "@types/node": "^22.10.5",
    "@types/react": "^18.3.18",
    "@types/react-dom": "^18.3.5",
    "@vitejs/plugin-react": "^4.3.4",
    "eslint": "^9.17.0",
    "eslint-plugin-react-hooks": "^5.0.0",
    "eslint-plugin-react-refresh": "^0.4.16",
    "globals": "^15.14.0",
    "tailwindcss-animate": "^1.0.7",
    "typescript": "~5.6.2",
    "typescript-eslint": "^8.18.2",
    "vite": "^6.0.5"
  }
}

--------------------------------------------------------------------------------
<File: frontend/postcss.config.js>
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

--------------------------------------------------------------------------------
<File: frontend/README.md>
# React + TypeScript + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react/README.md) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## Expanding the ESLint configuration

If you are developing a production application, we recommend updating the configuration to enable type aware lint rules:

- Configure the top-level `parserOptions` property like this:

```js
export default tseslint.config({
  languageOptions: {
    // other options...
    parserOptions: {
      project: ['./tsconfig.node.json', './tsconfig.app.json'],
      tsconfigRootDir: import.meta.dirname,
    },
  },
})
```

- Replace `tseslint.configs.recommended` to `tseslint.configs.recommendedTypeChecked` or `tseslint.configs.strictTypeChecked`
- Optionally add `...tseslint.configs.stylisticTypeChecked`
- Install [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) and update the config:

```js
// eslint.config.js
import react from 'eslint-plugin-react'

export default tseslint.config({
  // Set the react version
  settings: { react: { version: '18.3' } },
  plugins: {
    // Add the react plugin
    react,
  },
  rules: {
    // other rules...
    // Enable its recommended rules
    ...react.configs.recommended.rules,
    ...react.configs['jsx-runtime'].rules,
  },
})
```

--------------------------------------------------------------------------------
<File: frontend/src/App.css>
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}

--------------------------------------------------------------------------------
<File: frontend/src/App.tsx>
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import { Provider } from 'react-redux';
import { store } from './state/syncEngine';

// Pages
import HomePage from './pages/HomePage';
import WeeklyPlanPage from './pages/WeeklyPlanPage';
import MasterListPage from './pages/MasterListPage';

// Layout components
import { AppLayout } from './components/layouts/AppLayout';

function App() {
  return (
    <Provider store={store}>
      <Router>
        <Routes>
          <Route element={<AppLayout />}>
            <Route path="/" element={<HomePage />} />
            <Route path="/weekly-plan" element={<WeeklyPlanPage />} />
            <Route path="/master-list" element={<MasterListPage />} />
          </Route>
        </Routes>
      </Router>
    </Provider>
  );
}

export default App;

--------------------------------------------------------------------------------
<File: frontend/src/components/animations/StatusCheckAnimation.css>
/* src/components/animations/StatusCheckAnimation.css */

/* Attach this class to the overall bubble so we can position the check icon within it */
.status-bubble {
    position: relative; /* so the .status-check-icon can be absolutely placed */
    /* Force a consistent bubble size */
    width: 7rem;       /* pick a width wide enough to show "Working on It" */
    height: 2rem;      /* a consistent height for the bubble */
    /* Because we're forcing a width/height, center text with flex or text-align. 
       (We also do some of that in TaskTableRow, but up to you.)
    */
  }
  
  /* The check icon itself (initially hidden & scaled down) */
  .status-check-icon {
    position: absolute;
    right: 0.4rem;                /* tweak to your liking */
    top: 50%;
    transform: translateY(-50%) scale(0);
    opacity: 0;
    transition: transform 0.3s ease, opacity 0.3s ease;
    color: white; /* or black, depending on your bubble color */
  }
  
  /* When .animate-check is active, “pop” the check in */
  .animate-check .status-check-icon {
    transform: translateY(-50%) scale(1);
    opacity: 1;
  }
  
--------------------------------------------------------------------------------
<File: frontend/src/components/layouts/AppLayout.tsx>
import { useEffect, useState } from 'react';
import { Outlet } from 'react-router-dom';
import { initializeData } from '../../state/syncEngine';
import { Sidebar } from './Sidebar';
import { TopPanel } from './TopPanel';

export function AppLayout() {
  const [isCollapsed, setIsCollapsed] = useState(false);

  useEffect(() => {
    // Initialize data when the app loads
    initializeData();
  }, []);

  return (
    <div className="flex flex-col min-h-screen"> 
      {/* Top Panel at the top */}
      <TopPanel />

      {/* Main area is a flex container: Sidebar + Main Content */}
      <div className="flex flex-1">
        <Sidebar 
          isCollapsed={isCollapsed} 
          onCollapsedChange={setIsCollapsed} 
        />

        {/* Main content area */}
        <main className="flex-1 p-4 md:p-8 overflow-y-auto">
          <Outlet />
        </main>
      </div>
    </div>
  );
}

--------------------------------------------------------------------------------
<File: frontend/src/components/layouts/Sidebar.tsx>
import { NavLink } from 'react-router-dom';
import { Home, Calendar, List, ChevronLeft, ChevronRight } from 'lucide-react';
import { cn } from '../../utils/utils';
import { Button } from '../ui/button';

interface SidebarProps {
  isCollapsed: boolean;
  onCollapsedChange: (collapsed: boolean) => void;
}

export const Sidebar = ({ isCollapsed, onCollapsedChange }: SidebarProps) => {
  const navItems = [
    { path: '/', label: 'Home', icon: Home },
    { path: '/weekly-plan', label: 'Weekly Plan', icon: Calendar },
    { path: '/master-list', label: 'Master List', icon: List },
  ];

  return (
    <div
      className={cn(
        'h-screen bg-card border-r transition-all duration-300',
        isCollapsed ? 'w-16' : 'w-64'
      )}
    >
      <div className="flex flex-col h-full">
        <div className="p-4 flex justify-end">
          <Button
            variant="default"
            size="icon"
            onClick={() => onCollapsedChange(!isCollapsed)}
          >
            {isCollapsed ? <ChevronRight size={16} /> : <ChevronLeft size={16} />}
          </Button>
        </div>

        <nav className="flex-1 px-2 py-4">
          {navItems.map(({ path, label, icon: Icon }) => (
            <NavLink
              key={path}
              to={path}
              className={({ isActive }) =>
                cn(
                  'flex items-center px-4 py-2 my-1 rounded-md transition-colors',
                  'hover:bg-accent hover:text-accent-foreground',
                  isActive ? 'bg-accent text-accent-foreground' : 'text-muted-foreground',
                  isCollapsed && 'justify-center'
                )
              }
            >
              <Icon size={20} />
              {!isCollapsed && <span className="ml-3">{label}</span>}
            </NavLink>
          ))}
        </nav>
      </div>
    </div>
  );
}; 
--------------------------------------------------------------------------------
<File: frontend/src/components/layouts/TopPanel.tsx>
import { useSelector } from 'react-redux';
import { Link } from 'react-router-dom';
import { Check, Loader2, AlertCircle } from 'lucide-react';
import { RootState } from '../../state/syncEngine';
import { Button } from '../ui/button';

export function TopPanel() {
    const syncStatus = useSelector((state: RootState) => state.sync.status);
    const lastSynced = useSelector((state: RootState) => state.sync.lastSynced);

    const renderSyncStatus = () => {
        switch (syncStatus) {
            case 'syncing':
                return (
                    <div className="flex items-center">
                        <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                        <span>Syncing...</span>
                    </div>
                );
            case 'error':
                return (
                    <div className="flex items-center text-destructive">
                        <AlertCircle className="mr-2 h-4 w-4" />
                        <span>Sync error</span>
                    </div>
                );
            case 'idle':
                return (
                    <div className="flex items-center">
                        <Check className="mr-2 h-4 w-4 text-emerald-500" />
                        <span className="text-foreground whitespace-nowrap">
                            {lastSynced
                                ? `Last saved at ${new Date(lastSynced).toLocaleTimeString()}`
                                : 'All changes saved'}
                        </span>
                    </div>
                );
        }
    };

    return (
        <header className="sticky top-0 z-50 w-full border-b bg-background/95 backdrop-blur">
            <div className="mx-8">
                <div className="flex h-14 items-center justify-between">
                    {/* App Logo/Title */}
                    <Link to="/" className="flex items-center">
                        <span className="text-xl font-bold">Life Manager</span>
                    </Link>

                    {/* Right Side Controls */}
                    <div className="flex items-center gap-6">
                        {/* Sync Status */}
                        <div className="flex-shrink-0">
                            {renderSyncStatus()}
                        </div>

                        {/* Settings Button - Inactive for now */}
                        <Button
                            variant="default"
                            size="sm"
                            
                            aria-label="Settings (coming soon)"
                        >
                            Settings
                        </Button>

                        {/* Login/Logout Button - Inactive for now */}
                        <Button
                            variant="default"
                            size="sm"
                            
                            aria-label="Login (coming soon)"
                        >
                            Login
                        </Button>
                    </div>
                </div>
            </div>
        </header>
    );
} 
--------------------------------------------------------------------------------
<File: frontend/src/components/task/TaskCard.tsx>
import React from 'react';
import { Task } from '../../utils/types';

interface TaskCardProps {
  task: Task;
}

const TaskCard = ({ task }: TaskCardProps) => {
  return (
    <div className="p-4 border rounded-lg shadow-sm">
      {/* Card content will be added later */}
    </div>
  );
};

export default TaskCard; 
--------------------------------------------------------------------------------
<File: frontend/src/components/task/TaskDetails.tsx>
import React from 'react';
import { Task } from '../../utils/types';
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "../ui/dialog";

interface TaskDetailsProps {
  task: Task;
  open: boolean;
  onOpenChange: (open: boolean) => void;
}

const TaskDetails = ({ task, open, onOpenChange }: TaskDetailsProps) => {
  const formatDate = (date: string | undefined) => {
    if (!date) return '-';
    return new Date(date).toLocaleDateString();
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-2xl">
        <DialogHeader>
          <DialogTitle>{task.title}</DialogTitle>
        </DialogHeader>
        
        <div className="grid gap-4 py-4">
          <div className="grid grid-cols-4 items-center gap-4">
            <div className="font-medium">Status</div>
            <div className="col-span-3 flex items-center gap-2">
              <div className={`w-2 h-2 rounded-full ${
                task.status === 'complete' ? 'bg-green-500' :
                task.status === 'workingOnIt' ? 'bg-yellow-500' :
                'bg-gray-500'
              }`} />
              {task.status === 'notStarted' ? 'Not Started' :
               task.status === 'workingOnIt' ? 'Working on It' :
               'Complete'}
            </div>
          </div>

          <div className="grid grid-cols-4 items-center gap-4">
            <div className="font-medium">Priority</div>
            <div className="col-span-3">
              <div className={`inline-flex px-2 py-1 rounded-full text-xs ${
                task.priority >= 80 ? 'bg-red-100 text-red-800' :
                task.priority >= 60 ? 'bg-orange-100 text-orange-800' :
                task.priority >= 40 ? 'bg-yellow-100 text-yellow-800' :
                task.priority >= 20 ? 'bg-green-100 text-green-800' :
                'bg-gray-100 text-gray-800'
              }`}>
                {task.priority}
              </div>
            </div>
          </div>

          <div className="grid grid-cols-4 items-center gap-4">
            <div className="font-medium">Due Date</div>
            <div className="col-span-3">{formatDate(task.dueDate)}</div>
          </div>

          <div className="grid grid-cols-4 items-center gap-4">
            <div className="font-medium">Scheduled</div>
            <div className="col-span-3">{formatDate(task.scheduledDate)}</div>
          </div>

          {task.notes && (
            <div className="grid grid-cols-4 items-start gap-4">
              <div className="font-medium">Notes</div>
              <div className="col-span-3 whitespace-pre-wrap">{task.notes}</div>
            </div>
          )}

          {task.recurrence?.isRecurring && task.recurrence.rule && (
            <div className="grid grid-cols-4 items-start gap-4">
              <div className="font-medium">Recurrence</div>
              <div className="col-span-3">
                Every {task.recurrence.rule.interval} {task.recurrence.rule.frequency}
                {task.recurrence.rule.endDate && ` until ${formatDate(task.recurrence.rule.endDate)}`}
              </div>
            </div>
          )}

          {task.completionHistory.length > 0 && (
            <div className="grid grid-cols-4 items-start gap-4">
              <div className="font-medium">History</div>
              <div className="col-span-3">
                <div className="space-y-2">
                  {task.completionHistory.map((entry, index) => (
                    <div key={index} className="text-sm">
                      Completed on {formatDate(entry.completedAt)}
                      {entry.completionNotes && (
                        <div className="text-gray-600 ml-4">{entry.completionNotes}</div>
                      )}
                    </div>
                  ))}
                </div>
              </div>
            </div>
          )}
        </div>
      </DialogContent>
    </Dialog>
  );
};

export default TaskDetails; 
--------------------------------------------------------------------------------
<File: frontend/src/components/task/TaskTable.tsx>
// src/components/task/TaskTable.tsx
import React from 'react';
import { Task } from '../../utils/types';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from '../ui/table';
import TaskTableRow from './TaskTableRow';

interface TaskTableProps {
  tasks: Task[];
}

const TaskTable = ({ tasks }: TaskTableProps) => {
  return (
    <div className="w-full">
      <Table>
        <TableHeader>
          <TableRow>
            <TableHead>Title</TableHead>
            <TableHead>Status</TableHead>
            <TableHead>Priority</TableHead>
            <TableHead>Effort</TableHead>
            <TableHead>Due Date</TableHead>
            <TableHead>Recurrence</TableHead>
            {/* Removed Created/Updated. We'll show Notes here */}
            <TableHead>Notes</TableHead>
            <TableHead>Actions</TableHead>
          </TableRow>
        </TableHeader>
        <TableBody>
          {tasks.map((task) => (
            <TaskTableRow key={task.id} task={task} />
          ))}
        </TableBody>
      </Table>
    </div>
  );
};

export default TaskTable;

--------------------------------------------------------------------------------
<File: frontend/src/components/task/TaskTableRow.tsx>
import { useState } from 'react';
import { TableCell, TableRow } from '../ui/table';
import { Button } from '../ui/button';
import { Eye, Trash2, Check } from 'lucide-react';
import TaskDetails from './TaskDetails';
import { Task } from '../../utils/types';
import {
  STATUS_DISPLAY,
  STATUS_COLORS,
  getPriorityDisplay,
  EFFORT_DISPLAY,
  getRecurrenceDisplay,
} from '../../utils/displayMappings';
import { syncChanges, store } from '../../state/syncEngine';
import { updateTask, deleteTask } from '../../state/slices/taskSlice';

// Import the CSS that controls our checkmark animation
import '../animations/StatusCheckAnimation.css';

interface TaskTableRowProps {
  task: Task;
}

const STATUS_SEQUENCE = ['notStarted', 'workingOnIt', 'complete'] as const;
const PRIORITY_SEQUENCE = [0, 20, 40, 60, 80];
const EFFORT_SEQUENCE = [1, 2, 3, 4, 5];

const TaskTableRow = ({ task }: TaskTableRowProps) => {
  const [showDetails, setShowDetails] = useState(false);
  const [animateCheck, setAnimateCheck] = useState(false);

  // Format date safely
  const formatDate = (date: string | undefined) => {
    if (!date) return '-';
    return new Date(date).toLocaleDateString();
  };

  const priorityInfo = getPriorityDisplay(task.priority);
  const effortInfo = task.effort ? EFFORT_DISPLAY[task.effort] : null;
  const recurrenceLabel = getRecurrenceDisplay(
    task.recurrence?.isRecurring || false,
    task.recurrence?.rule?.frequency,
    task.recurrence?.rule?.interval
  );

  // Cycle status on click
  const handleStatusClick = () => {
    const currentIndex = STATUS_SEQUENCE.indexOf(task.status);
    const nextIndex = (currentIndex + 1) % STATUS_SEQUENCE.length;
    const nextStatus = STATUS_SEQUENCE[nextIndex];

    // Update in Redux (optimistic UI)
    store.dispatch(
      updateTask({
        id: task.id,
        changes: { status: nextStatus },
      })
    );

    // Debounced sync to server
    syncChanges('status', [
      {
        type: 'task',
        operation: 'update',
        id: task.id,
        data: { status: nextStatus },
      },
    ]);

    // Trigger the check “pop” if newly “complete”
    if (nextStatus === 'complete') {
      setAnimateCheck(true);
      setTimeout(() => setAnimateCheck(false), 1000);
    } else {
      setAnimateCheck(false);
    }
  };

  // Cycle priority on click
  const handlePriorityClick = () => {
    const currentIndex = PRIORITY_SEQUENCE.indexOf(task.priority);
    const safeIndex = currentIndex >= 0 ? currentIndex : 0;
    const nextIndex = (safeIndex + 1) % PRIORITY_SEQUENCE.length;
    const nextPriority = PRIORITY_SEQUENCE[nextIndex];

    store.dispatch(
      updateTask({
        id: task.id,
        changes: { priority: nextPriority },
      })
    );

    syncChanges('priority', [
      {
        type: 'task',
        operation: 'update',
        id: task.id,
        data: { priority: nextPriority },
      },
    ]);
  };

  // Cycle effort on click
  const handleEffortClick = () => {
    const currentEffort = task.effort || 1;
    const currentIndex = EFFORT_SEQUENCE.indexOf(currentEffort);
    const safeIndex = currentIndex >= 0 ? currentIndex : 0;
    const nextIndex = (safeIndex + 1) % EFFORT_SEQUENCE.length;
    const nextEffort = EFFORT_SEQUENCE[nextIndex];

    store.dispatch(
      updateTask({
        id: task.id,
        changes: { effort: nextEffort },
      })
    );

    // re-using 'priority' as the "changeType" here, or define a new one if you prefer
    syncChanges('priority', [
      {
        type: 'task',
        operation: 'update',
        id: task.id,
        data: { effort: nextEffort },
      },
    ]);
  };

  // Delete this task
  const handleDeleteTask = (id: string) => {
    store.dispatch(deleteTask(id));
    syncChanges('status', [
      {
        type: 'task',
        operation: 'delete',
        id,
      },
    ]);
  };

  return (
    <>
      <TableRow>
        {/* TITLE */}
        <TableCell>{task.title}</TableCell>

        {/* STATUS BUBBLE */}
        <TableCell>
          <button
            onClick={handleStatusClick}
            className={[
              // Force a consistent bubble size: w-28/h-8 plus our custom class for the animation
              'inline-flex items-center justify-center w-28 h-8 px-2 py-1 rounded-full text-xs relative',
              'status-bubble', // from StatusCheckAnimation.css
              STATUS_COLORS[task.status] || 'bg-gray-100 text-gray-800',
              animateCheck ? 'animate-check' : '',
            ].join(' ')}
          >
            {STATUS_DISPLAY[task.status] || task.status}
            <Check className="status-check-icon h-4 w-4" />
          </button>
        </TableCell>

        {/* PRIORITY BUBBLE */}
        <TableCell>
          <button
            onClick={handlePriorityClick}
            className={[
              'inline-flex items-center justify-center w-28 h-8 px-2 py-1 rounded-full text-xs',
              priorityInfo.colorClass,
              'cursor-pointer',
            ].join(' ')}
          >
            {priorityInfo.label}
          </button>
        </TableCell>

        {/* EFFORT BUBBLE */}
        <TableCell>
          <button
            onClick={handleEffortClick}
            className={[
              'inline-flex items-center justify-center w-28 h-8 px-2 py-1 rounded-full text-xs',
              effortInfo ? effortInfo.colorClass : 'bg-gray-100 text-gray-800',
              'cursor-pointer',
            ].join(' ')}
          >
            {effortInfo ? effortInfo.label : 'N/A'}
          </button>
        </TableCell>

        {/* DUE DATE */}
        <TableCell>{formatDate(task.dueDate)}</TableCell>

        {/* RECURRENCE */}
        <TableCell>{recurrenceLabel}</TableCell>

        {/* NOTES */}
        <TableCell>{task.notes?.trim() || '-'}</TableCell>

        {/* ACTIONS */}
        <TableCell className="flex gap-2">
          <Button variant="default" size="sm" onClick={() => setShowDetails(true)}>
            <Eye className="h-4 w-4" />
          </Button>
          <Button variant="default" size="sm" onClick={() => handleDeleteTask(task.id)}>
            <Trash2 className="h-4 w-4" />
          </Button>
        </TableCell>
      </TableRow>

      {/* DETAILS DIALOG */}
      {showDetails && (
        <TaskDetails
          task={task}
          open={showDetails}
          onOpenChange={setShowDetails}
        />
      )}
    </>
  );
};

export default TaskTableRow;

--------------------------------------------------------------------------------
<File: frontend/src/components/ui/button.tsx>
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "../../utils/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "bg-transparent text-muted-foreground hover:text-foreground border border-input transition-colors",
        destructive:
          "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
        outline:
          "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
        gray:
          "bg-grayButton text-grayButton-foreground hover:bg-grayButton-hover shadow-sm",
        transparent:
          "bg-transparent text-muted-foreground hover:text-foreground transition-colors",
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

export const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

--------------------------------------------------------------------------------
<File: frontend/src/components/ui/card.tsx>
import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-xl border bg-card text-card-foreground shadow",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("font-semibold leading-none tracking-tight", className)}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }

--------------------------------------------------------------------------------
<File: frontend/src/components/ui/checkbox.tsx>
import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { Check } from "lucide-react"

import { cn } from "@/lib/utils"

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary shadow focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn("flex items-center justify-center text-current")}
    >
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
))
Checkbox.displayName = CheckboxPrimitive.Root.displayName

export { Checkbox }

--------------------------------------------------------------------------------
<File: frontend/src/components/ui/dialog.tsx>
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"

import { cn } from "../../utils/utils"


const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogTrigger,
  DialogClose,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}

--------------------------------------------------------------------------------
<File: frontend/src/components/ui/input.tsx>
import * as React from "react"

import { cn } from "@/lib/utils"

const Input = React.forwardRef<HTMLInputElement, React.ComponentProps<"input">>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-base shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }

--------------------------------------------------------------------------------
<File: frontend/src/components/ui/select.tsx>
import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"

import { cn } from "@/lib/utils"

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-9 w-full items-center justify-between whitespace-nowrap rounded-md border border-input bg-transparent px-3 py-2 text-sm shadow-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-1 focus:ring-ring disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("px-2 py-1.5 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-2 pr-8 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute right-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>
    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}

--------------------------------------------------------------------------------
<File: frontend/src/components/ui/separator.tsx>
"use client"

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
  (
    { className, orientation = "horizontal", decorative = true, ...props },
    ref
  ) => (
    <SeparatorPrimitive.Root
      ref={ref}
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "shrink-0 bg-border",
        orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
        className
      )}
      {...props}
    />
  )
)
Separator.displayName = SeparatorPrimitive.Root.displayName

export { Separator }

--------------------------------------------------------------------------------
<File: frontend/src/components/ui/skeleton.tsx>
import { cn } from "@/lib/utils"

function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-primary/10", className)}
      {...props}
    />
  )
}

export { Skeleton }

--------------------------------------------------------------------------------
<File: frontend/src/components/ui/table.tsx>
import * as React from "react"

import { cn } from "../../utils/utils"

const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="relative w-full overflow-auto">
    <table
      ref={ref}
      className={cn("w-full caption-bottom text-sm", className)}
      {...props}
    />
  </div>
))
Table.displayName = "Table"

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />
))
TableHeader.displayName = "TableHeader"

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn("[&_tr:last-child]:border-0", className)}
    {...props}
  />
))
TableBody.displayName = "TableBody"

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn(
      "border-t bg-muted/50 font-medium [&>tr]:last:border-b-0",
      className
    )}
    {...props}
  />
))
TableFooter.displayName = "TableFooter"

const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
      className
    )}
    {...props}
  />
))
TableRow.displayName = "TableRow"

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      "h-10 px-2 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
      className
    )}
    {...props}
  />
))
TableHead.displayName = "TableHead"

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn(
      "p-2 align-middle [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
      className
    )}
    {...props}
  />
))
TableCell.displayName = "TableCell"

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn("mt-4 text-sm text-muted-foreground", className)}
    {...props}
  />
))
TableCaption.displayName = "TableCaption"

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}

--------------------------------------------------------------------------------
<File: frontend/src/main.tsx>
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './styles/globals.css'
import App from './App.tsx'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
)

--------------------------------------------------------------------------------
<File: frontend/src/pages/HomePage.tsx>
import React from 'react';

const HomePage = () => {
  return (
    <div className="p-6">
      <h1 className="text-2xl font-bold mb-4">Home</h1>
      {/* Content will be added later */}
    </div>
  );
};

export default HomePage; 
--------------------------------------------------------------------------------
<File: frontend/src/pages/MasterListPage.tsx>
import React from 'react';
import { useSelector } from 'react-redux';
import { RootState } from '../state/syncEngine';
import TaskTable from '../components/task/TaskTable';
import { Task } from '../utils/types';

const MasterListPage = () => {
  const tasksObj = useSelector((state: RootState) => state.tasks.items);
  const tasksArray: Task[] = Object.values(tasksObj);

  return (
    <div className="w-full">
      <h1 className="text-2xl font-bold mb-4">Master List</h1>
      <div className="rounded-md border w-full">
        <TaskTable tasks={tasksArray} />
      </div>
    </div>
  );
};

export default MasterListPage; 
--------------------------------------------------------------------------------
<File: frontend/src/pages/WeeklyPlanPage.tsx>
import React from 'react';

const WeeklyPlanPage = () => {
  return (
    <div className="p-6">
      <h1 className="text-2xl font-bold mb-4">Weekly Plan</h1>
      {/* Content will be added later */}
    </div>
  );
};

export default WeeklyPlanPage; 
--------------------------------------------------------------------------------
<File: frontend/src/state/logger.ts>
// src/state/logger.ts

import { Middleware, Action } from '@reduxjs/toolkit';
import { diff } from 'deep-object-diff';

// Helper to get a clean state diff
const getStateDiff = (prevState: any, nextState: any) => {
    const stateDiff = diff(prevState, nextState);
    return Object.keys(stateDiff).length ? stateDiff : null;
};

// Helper to format timestamps consistently
const getTimestamp = () => new Date().toISOString();

// Grouped console styling
const groupStyles = {
    init: 'color: #3f51b5; font-weight: bold;',     // Indigo for initialization
    action: 'color: #4CAF50; font-weight: bold;',    // Green for data changes
    sync: 'color: #9c27b0; font-weight: bold;',      // Purple for sync operations
    error: 'color: #f44336; font-weight: bold;'      // Red for errors
};

// Custom logger middleware for state changes
export const stateLogger: Middleware = (store) => (next) => (action: unknown) => {
    // Skip logging for sync status changes
    if ((action as Action).type === 'sync/setSyncStatus') {
        return next(action);
    }

    const timestamp = getTimestamp();
    const prevState = store.getState();
    const result = next(action);
    const nextState = store.getState();
    
    // Calculate meaningful state changes
    const stateDiff = getStateDiff(prevState, nextState);
    
    if (stateDiff) {
        const actionType = (action as Action).type;
        const style = actionType.startsWith('sync/') ? groupStyles.sync : groupStyles.action;
        
        console.groupCollapsed(`%c${actionType}`, style);
        console.log({
            type: actionType,
            payload: (action as any).payload,
            timestamp,
            changes: stateDiff
        });
        console.groupEnd();
    }
    
    return result;
};

// Sync operation logging functions
export const logSyncStarted = (changes: any[], changeType: string) => {
    console.groupCollapsed('%cSync Started', groupStyles.sync);
    console.log({
        type: 'sync/started',
        changeType,
        numChanges: changes.length,
        changes,
        timestamp: getTimestamp()
    });
    console.groupEnd();
};

export const logSyncCompleted = (syncedAt: string) => {
    console.groupCollapsed('%cSync Completed', groupStyles.sync);
    console.log({
        type: 'sync/completed',
        result: 'success',
        syncedAt,
        timestamp: getTimestamp()
    });
    console.groupEnd();
};

export const logSyncFailed = (error: unknown) => {
    console.group('%cSync Failed', groupStyles.error);
    console.log({
        type: 'sync/failed',
        error: {
            code: error instanceof Error ? error.name : 'UNKNOWN_ERROR',
            message: error instanceof Error ? error.message : 'An unknown error occurred'
        },
        timestamp: getTimestamp()
    });
    console.groupEnd();
};

// Initial load logging
export const logInitialState = (state: any) => {
    console.group('%cInitial Redux State', groupStyles.init);
    console.log('State:', state);
    console.log('Tasks:', Object.keys(state.tasks.items).length);
    console.log('Sync Status:', state.sync.status);
    console.log('Last Synced:', state.sync.lastSynced);
    console.groupEnd();
};
--------------------------------------------------------------------------------
<File: frontend/src/state/slices/syncSlice.ts>
import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import { SyncState } from '../../utils/types';

const initialState: SyncState = {
    status: 'idle',
    lastSynced: null,
    pendingChanges: 0
};

export const syncSlice = createSlice({
    name: 'sync',
    initialState,
    reducers: {
        setSyncStatus: (state, action: PayloadAction<'idle' | 'syncing' | 'error'>) => {
            state.status = action.payload;
        },
        setLastSynced: (state, action: PayloadAction<string | null>) => {
            state.lastSynced = action.payload;
        },
        incrementPendingChanges: (state) => {
            state.pendingChanges += 1;
        },
        decrementPendingChanges: (state) => {
            if (state.pendingChanges > 0) {
                state.pendingChanges -= 1;
            }
        },
        resetPendingChanges: (state) => {
            state.pendingChanges = 0;
        }
    }
});

export const {
    setSyncStatus,
    setLastSynced,
    incrementPendingChanges,
    decrementPendingChanges,
    resetPendingChanges
} = syncSlice.actions;

export default syncSlice.reducer; 
--------------------------------------------------------------------------------
<File: frontend/src/state/slices/taskSlice.ts>
// File: frontend/src/state/slices/taskSlice.ts

import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import { Task, TasksState, UUID } from '../../utils/types';

const initialState: TasksState = {
  items: {},
  loading: false,
  error: null
};

export const taskSlice = createSlice({
  name: 'tasks',
  initialState,
  reducers: {
    setLoading: (state, action: PayloadAction<boolean>) => {
      state.loading = action.payload;
    },
    setError: (state, action: PayloadAction<string | null>) => {
      state.error = action.payload;
    },

    /**
     * Add a single task to the dictionary.
     */
    addTask: (state, action: PayloadAction<Task>) => {
      state.items[action.payload.id] = action.payload;
    },

    /**
     * Update an existing task by its id.
     */
    updateTask: (state, action: PayloadAction<{ id: UUID; changes: Partial<Task> }>) => {
      const { id, changes } = action.payload;
      if (state.items[id]) {
        state.items[id] = { ...state.items[id], ...changes };
      } else {
        console.log('[updateTask] Task not found in store:', id);
      }
    },

    /**
     * Delete a task from the dictionary by its id.
     */
    deleteTask: (state, action: PayloadAction<UUID>) => {
      delete state.items[action.payload];
    },

    /**
     * Set an entire collection of tasks in the store. 
     * Accepts EITHER:
     *   1) A dictionary of tasks keyed by ID, OR
     *   2) An array of tasks
     * We convert arrays to a dictionary automatically.
     */
    setTasks: (
      state,
      action: PayloadAction<Record<UUID, Task> | Task[]>
    ) => {
      const payload = action.payload;

      if (Array.isArray(payload)) {
        // If payload is an array, convert it to a dictionary
        const record: Record<string, Task> = {};
        payload.forEach((task) => {
          record[task.id] = task;
        });
        state.items = record;
      } else {
        // If it's already a dictionary, just store it
        state.items = payload;
      }
    }
  }
});

// Export all of the action creators
export const {
  setLoading,
  setError,
  addTask,
  updateTask,
  deleteTask,
  setTasks
} = taskSlice.actions;

// Export the reducer to be included in your store
export default taskSlice.reducer;

--------------------------------------------------------------------------------
<File: frontend/src/state/syncEngine.ts>
// src/state/syncEngine.ts

import { configureStore } from '@reduxjs/toolkit';
import { debounce } from 'lodash';
import taskReducer, {
  setTasks,
  addTask,
  updateTask,
  deleteTask
} from './slices/taskSlice';
import syncReducer, {
  setSyncStatus,
  setLastSynced,
  resetPendingChanges
} from './slices/syncSlice';
import { api } from '../utils/api';
import { Task, UUID, ChangeType } from '../utils/types';
import {
  stateLogger,
  logSyncStarted,
  logSyncCompleted,
  logSyncFailed,
  logInitialState
} from './logger';

/**
 * Configure the Redux store
 */
export const store = configureStore({
  reducer: {
    tasks: taskReducer,
    sync: syncReducer
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      serializableCheck: {
        // Ignore these action types in serializability checks
        ignoredActions: ['sync/setLastSynced']
      }
    }).concat(stateLogger)
});

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;

/**
 * Sync configuration for each type of UI change
 */
const SYNC_CONFIG: Record<ChangeType, number> = {
  text: 2000,      // 2 seconds for text changes
  status: 500,     // 500ms for status changes
  priority: 1000,  // 1 second for priority changes
  drag: 500        // 500ms for drag operations
};

/**
 * Initialize data on app start
 */
export const initializeData = async () => {
  try {
    store.dispatch(setSyncStatus('syncing'));

    const userData = await api.getUserData();
    store.dispatch(setTasks(userData.tasks));
    store.dispatch(setLastSynced(userData.lastSyncedAt));

    store.dispatch(setSyncStatus('idle'));
    logInitialState(store.getState());
  } catch (error) {
    console.error('Failed to initialize data:', error);
    store.dispatch(setSyncStatus('error'));
  }
};

/**
 * Debounced sync functions (FIRE AND FORGET!)
 *
 * Each function logs the start, sets the store to 'syncing',
 * but does NOT await the result. We handle success/failure in then/catch.
 */
const debouncedSyncs = Object.entries(SYNC_CONFIG).reduce(
  (acc, [changeType, delay]) => {
    acc[changeType as ChangeType] = debounce((changes: Array<{
      type: 'task';
      operation: 'create' | 'update' | 'delete';
      id?: UUID;
      data?: Partial<Task>;
    }>) => {
      // 1) Log sync start in console
      logSyncStarted(changes, changeType);
      // 2) Set store to 'syncing' so top panel can show spinner
      store.dispatch(setSyncStatus('syncing'));

      const syncRequest = {
        changes: changes.map((change) => ({
          ...change,
          timestamp: new Date().toISOString(),
          changeType: changeType as ChangeType
        })),
        // fallback to "now" if we don't have lastSynced
        clientLastSync: store.getState().sync.lastSynced || new Date().toISOString()
      };

      // ===== Fire-and-forget: NO `await` here =====
      api.sync(syncRequest)
        .then((response) => {
          // If the server has new changes, apply them
          if (response.serverChanges?.length) {
            response.serverChanges.forEach((change) => {
              switch (change.operation) {
                case 'create':
                  if (change.data) {
                    store.dispatch(addTask(change.data));
                  }
                  break;
                case 'update':
                  if (change.data) {
                    store.dispatch(
                      updateTask({
                        id: change.id,
                        changes: change.data
                      })
                    );
                  }
                  break;
                case 'delete':
                  store.dispatch(deleteTask(change.id));
                  break;
              }
            });
          }

          // Sync is done
          store.dispatch(setLastSynced(response.syncedAt));
          store.dispatch(setSyncStatus('idle'));
          store.dispatch(resetPendingChanges());

          logSyncCompleted(response.syncedAt);
        })
        .catch((error) => {
          logSyncFailed(error);
          // Mark the store as 'error', so top panel can show “sync error”
          store.dispatch(setSyncStatus('error'));
        });
    }, delay);

    return acc;
  },
  {} as Record<ChangeType, Function>
);

/**
 * Export a helper so components can queue changes
 */
export const syncChanges = (
  changeType: ChangeType,
  changes: Array<{
    type: 'task';
    operation: 'create' | 'update' | 'delete';
    id?: UUID;
    data?: Partial<Task>;
  }>
) => {
  debouncedSyncs[changeType](changes);
};

--------------------------------------------------------------------------------
<File: frontend/src/styles/globals.css>
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  font-family: Inter, system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

a {
  font-weight: 500;
  color: #646cff;
  text-decoration: inherit;
}
a:hover {
  color: #535bf2;
}

body {
  margin: 0;
  min-width: 320px;
  min-height: 100vh;
}

h1 {
  font-size: 3.2em;
  line-height: 1.1;
}

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #1a1a1a;
  cursor: pointer;
  transition: border-color 0.25s;
}
button:hover {
  border-color: #646cff;
}
button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
}

@media (prefers-color-scheme: light) {
  :root {
    color: #213547;
    background-color: #ffffff;
  }
  a:hover {
    color: #747bff;
  }
  button {
    background-color: #f9f9f9;
  }
}

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 224 71.4% 4.1%;
    --card: 0 0% 100%;
    --card-foreground: 224 71.4% 4.1%;
    --popover: 0 0% 100%;
    --popover-foreground: 224 71.4% 4.1%;
    --primary: 220.9 39.3% 11%;
    --primary-foreground: 210 20% 98%;
    --secondary: 220 14.3% 95.9%;
    --secondary-foreground: 220.9 39.3% 11%;
    --muted: 220 14.3% 95.9%;
    --muted-foreground: 220 8.9% 46.1%;
    --accent: 220 14.3% 95.9%;
    --accent-foreground: 220.9 39.3% 11%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 20% 98%;
    --border: 220 13% 91%;
    --input: 220 13% 91%;
    --ring: 224 71.4% 4.1%;
    --chart-1: 12 76% 61%;
    --chart-2: 173 58% 39%;
    --chart-3: 197 37% 24%;
    --chart-4: 43 74% 66%;
    --chart-5: 27 87% 67%;
    --radius: 0.5rem;
  }
  .dark {
    --background: 224 71.4% 4.1%;
    --foreground: 210 20% 98%;
    --card: 224 71.4% 4.1%;
    --card-foreground: 210 20% 98%;
    --popover: 224 71.4% 4.1%;
    --popover-foreground: 210 20% 98%;
    --primary: 210 20% 98%;
    --primary-foreground: 220.9 39.3% 11%;
    --secondary: 215 27.9% 16.9%;
    --secondary-foreground: 210 20% 98%;
    --muted: 215 27.9% 16.9%;
    --muted-foreground: 217.9 10.6% 64.9%;
    --accent: 215 27.9% 16.9%;
    --accent-foreground: 210 20% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 210 20% 98%;
    --border: 215 27.9% 16.9%;
    --input: 215 27.9% 16.9%;
    --ring: 216 12.2% 83.9%;
    --chart-1: 220 70% 50%;
    --chart-2: 160 60% 45%;
    --chart-3: 30 80% 55%;
    --chart-4: 280 65% 60%;
    --chart-5: 340 75% 55%;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}

--------------------------------------------------------------------------------
<File: frontend/src/utils/api.ts>
import { Task, UUID } from './types';

const API_BASE_URL = 'http://localhost:5000/api/v1';

interface ApiResponse<T> {
    success: boolean;
    data?: T;
    error?: {
        code: string;
        message: string;
        details?: any;
    };
    metadata?: {
        timestamp: string;
        requestId: string;
        pagination?: {
            total: number;
            page: number;
            pageSize: number;
            hasMore: boolean;
        };
    };
}

interface UserData {
    tasks: Record<UUID, Task>;
    lastSyncedAt: string;
}

interface SyncRequest {
    changes: Array<{
        type: 'task';
        operation: 'create' | 'update' | 'delete';
        id?: UUID;
        data?: Partial<Task>;
        timestamp: string;
        changeType?: 'text' | 'status' | 'priority' | 'drag';
    }>;
    clientLastSync: string;
}

interface SyncResponse {
    serverChanges?: Array<{
        type: 'task';
        operation: 'create' | 'update' | 'delete';
        id: UUID;
        data?: any;
        timestamp: string;
    }>;
    syncedAt: string;
}

class ApiClient {
    private userId: string = 'temp-user-id'; // TODO: Replace with actual auth

    private async request<T>(
        endpoint: string,
        options: RequestInit = {}
    ): Promise<ApiResponse<T>> {
        const url = `${API_BASE_URL}${endpoint}`;
        const headers = {
            'Content-Type': 'application/json',
            'X-User-ID': this.userId,
            'X-Request-ID': crypto.randomUUID(),
            ...options.headers,
        };

        try {
            const response = await fetch(url, { ...options, headers });
            const data: ApiResponse<T> = await response.json();

            if (!response.ok) {
                throw new Error(data.error?.message || 'An error occurred');
            }

            return data;
        } catch (error) {
            console.error('API request failed:', error);
            throw error;
        }
    }

    async getUserData(): Promise<UserData> {
        const response = await this.request<UserData>('/user-data');
        return response.data!;
    }

    async sync(changes: SyncRequest): Promise<SyncResponse> {
        const response = await this.request<SyncResponse>('/sync', {
            method: 'POST',
            body: JSON.stringify(changes),
        });
        return response.data!;
    }
}

export const api = new ApiClient(); 
--------------------------------------------------------------------------------
<File: frontend/src/utils/displayMappings.ts>
// src/utils/displayMappings.ts

/**
 * Status
 */
export const STATUS_DISPLAY: Record<string, string> = {
    notStarted: 'Not Started',
    workingOnIt: 'Working on It',
    complete: 'Complete',
  };
  
  /**
   * Status color classes
   * Gray => notStarted
   * Yellow => workingOnIt
   * Green => complete
   */
  export const STATUS_COLORS: Record<string, string> = {
    notStarted: 'bg-gray-300 text-gray-800',   // a subdued gray
    workingOnIt: 'bg-yellow-400 text-gray-800', // a medium yellow
    complete: 'bg-green-500 text-white',        // a strong green
  };
  
  /**
   * Priority Ranges
   * (Unchanged, unless you want to tweak them)
   */
  export const priorityRanges = [
    { min: 80, label: 'Very High', colorClass: 'bg-red-100 text-red-800' },
    { min: 60, label: 'High',     colorClass: 'bg-orange-100 text-orange-800' },
    { min: 40, label: 'Medium',   colorClass: 'bg-yellow-100 text-yellow-800' },
    { min: 20, label: 'Low',      colorClass: 'bg-green-100 text-green-800' },
    { min: 0,  label: 'Very Low', colorClass: 'bg-green-50 text-green-800' },
  ];
  
  export function getPriorityDisplay(priority: number): {
    label: string;
    colorClass: string;
  } {
    const found = priorityRanges.find((r) => priority >= r.min);
    return found
      ? { label: found.label, colorClass: found.colorClass }
      : { label: 'Unknown', colorClass: 'bg-gray-100 text-gray-800' };
  }
  
  /**
   * Effort
   * (Keeping as-is, unless you want to also change these)
   */
  export const EFFORT_DISPLAY: Record<number, { label: string; colorClass: string }> = {
    1: { label: 'Very Low',  colorClass: 'bg-gray-100 text-gray-800' },
    2: { label: 'Low',       colorClass: 'bg-gray-200 text-gray-800' },
    3: { label: 'Medium',    colorClass: 'bg-gray-300 text-gray-800' },
    4: { label: 'High',      colorClass: 'bg-gray-400 text-gray-800' },
    5: { label: 'Very High', colorClass: 'bg-gray-500 text-white' },
  };
  
  /**
   * Recurrence display
   */
  export function getRecurrenceDisplay(
    isRecurring: boolean,
    frequency?: string,
    interval?: number
  ): string {
    if (!isRecurring) return 'None';
    if (!frequency) return 'Recurring (?)';
  
    const freqLabel = frequency[0].toUpperCase() + frequency.slice(1);
    if (interval && interval > 1) {
      return `Every ${interval} ${freqLabel}s`;
    }
    return freqLabel;
  }
  
--------------------------------------------------------------------------------
<File: frontend/src/utils/types.ts>
// Common Types
export type UUID = string;
export type ISODateString = string;

export type Status = 'notStarted' | 'workingOnIt' | 'complete';
export type RecurrenceFrequency = 'daily' | 'weekly' | 'monthly' | 'yearly';
export type TimeRange = 'day' | 'week' | 'month';
export type ChangeType = 'text' | 'status' | 'priority' | 'drag';

export interface CompletionEntry {
    completedAt: ISODateString;
    nextDueDate?: ISODateString;
    completionNotes?: string;
}

export interface RecurrenceRule {
    frequency: RecurrenceFrequency;
    interval: number;
    endDate?: ISODateString;
    maxOccurrences?: number;
    daysOfWeek?: number[];  // 0-6 for weekly
    dayOfMonth?: number;    // 1-31 for monthly
    months?: number[];      // 1-12 for yearly
    weekOfMonth?: number;   // -1 to 5 (-1 for last)
}

// Task Interface
export interface Task {
    id: UUID;
    userId: UUID;
    type: 'task';
    title: string;
    status: Status;
    priority: number;
    dynamicPriority: number;
    effort?: number;
    notes?: string;
    dueDate?: ISODateString;
    scheduledDate?: ISODateString;
    createdAt: ISODateString;
    updatedAt: ISODateString;
    
    completionHistory: CompletionEntry[];
    
    recurrence?: {
        isRecurring: boolean;
        rule?: RecurrenceRule;
    };
    
    tags?: string[];
}

// Redux State Types
export interface TasksState {
    items: Record<UUID, Task>;
    loading: boolean;
    error: string | null;
}

export interface SyncState {
    status: 'idle' | 'syncing' | 'error';
    lastSynced: string | null;
    pendingChanges: number;
}

export interface LayoutState {
    sidebarCollapsed: boolean;
}

export interface RootState {
    tasks: TasksState;
    sync: SyncState;
    layout: LayoutState;
} 
--------------------------------------------------------------------------------
<File: frontend/src/utils/utils.ts>
import { type ClassValue, clsx } from 'clsx';
import { twMerge } from 'tailwind-merge';

export function cn(...inputs: ClassValue[]) {
    return twMerge(clsx(inputs));
}

--------------------------------------------------------------------------------
<File: frontend/src/vite-env.d.ts>
/// <reference types="vite/client" />

--------------------------------------------------------------------------------
<File: frontend/tailwind.config.js>
/** @type {import('tailwindcss').Config} */
export default {
  darkMode: ["class"],
  content: [
    './index.html',
    './src/**/*.{js,ts,jsx,tsx}',
  ],
  theme: {
  	extend: {
  		colors: {
  			primary: {
  				DEFAULT: 'hsl(var(--primary))',
  				foreground: 'hsl(var(--primary-foreground))'
  			},
  			secondary: {
  				DEFAULT: 'hsl(var(--secondary))',
  				foreground: 'hsl(var(--secondary-foreground))'
  			},
  			accent: {
  				DEFAULT: 'hsl(var(--accent))',
  				foreground: 'hsl(var(--accent-foreground))'
  			},
  			background: 'hsl(var(--background))',
  			foreground: 'hsl(var(--foreground))',
  			card: {
  				DEFAULT: 'hsl(var(--card))',
  				foreground: 'hsl(var(--card-foreground))'
  			},
  			popover: {
  				DEFAULT: 'hsl(var(--popover))',
  				foreground: 'hsl(var(--popover-foreground))'
  			},
  			muted: {
  				DEFAULT: 'hsl(var(--muted))',
  				foreground: 'hsl(var(--muted-foreground))'
  			},
  			destructive: {
  				DEFAULT: 'hsl(var(--destructive))',
  				foreground: 'hsl(var(--destructive-foreground))'
  			},
  			border: 'hsl(var(--border))',
  			input: 'hsl(var(--input))',
  			ring: 'hsl(var(--ring))',
  			chart: {
  				'1': 'hsl(var(--chart-1))',
  				'2': 'hsl(var(--chart-2))',
  				'3': 'hsl(var(--chart-3))',
  				'4': 'hsl(var(--chart-4))',
  				'5': 'hsl(var(--chart-5))'
  			},
  			grayButton: {
  				DEFAULT: '#9CA3AF',
  				hover: '#6B7280',
  				foreground: '#ffffff'
  			}
  		},
  		fontFamily: {
  			sans: [
  				'Inter',
  				'sans-serif'
  			]
  		},
  		borderRadius: {
  			lg: 'var(--radius)',
  			md: 'calc(var(--radius) - 2px)',
  			sm: 'calc(var(--radius) - 4px)'
  		}
  	}
  },
  plugins: [require("tailwindcss-animate")],
}


--------------------------------------------------------------------------------
<File: frontend/tsconfig.app.json>
{
  "compilerOptions": {
    "incremental": true,
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["src"]
}

--------------------------------------------------------------------------------
<File: frontend/tsconfig.json>
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,

    /* Path Aliases */
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}

--------------------------------------------------------------------------------
<File: frontend/tsconfig.node.json>
{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true
  },
  "include": ["vite.config.ts"]
}

--------------------------------------------------------------------------------
<File: frontend/vite.config.ts>
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import { fileURLToPath } from 'url'
import { dirname, resolve } from 'path'

const __filename = fileURLToPath(import.meta.url)
const __dirname = dirname(__filename)

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      "@": resolve(__dirname, "./src"),
    },
  },
})

--------------------------------------------------------------------------------
<File: README.md>
# tbd

--------------------------------------------------------------------------------

<end codebase> 

