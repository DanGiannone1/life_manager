Here is my codebase:

<File: backend/app.py>
from flask import Flask, request, jsonify, make_response
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address
from flask_cors import CORS
from datetime import datetime, timezone
from typing import Dict, Any, List, Optional, TypedDict, Union
import os
import uuid
from dotenv import load_dotenv
from cosmos_db import CosmosDBManager
import humps
import traceback

# Load environment variables
load_dotenv()

# Initialize Flask app
app = Flask(__name__)
CORS(app)  # Enable CORS for all routes

# Initialize rate limiter
limiter = Limiter(
    app=app,
    key_func=get_remote_address,
    default_limits=["600 per day", "150 per hour"]
)

# Initialize CosmosDB manager
cosmos_db = CosmosDBManager()

class ApiResponse(TypedDict):
    success: bool
    data: Optional[Dict[str, Any]]
    error: Optional[Dict[str, Any]]
    metadata: Optional[Dict[str, Any]]

def create_api_response(
    success: bool,
    data: Optional[Dict[str, Any]] = None,
    error: Optional[Dict[str, Any]] = None,
    metadata: Optional[Dict[str, Any]] = None
) -> ApiResponse:
    """Create a standardized API response following the design document format."""
    response: ApiResponse = {
        "success": success,
        "data": data,
        "error": error,
        "metadata": {
            "timestamp": datetime.now(timezone.utc).isoformat(),
            "requestId": request.headers.get("X-Request-ID", ""),
            **(metadata or {})
        }
    }
    return response

def add_rate_limit_headers(response):
    """Add rate limit headers to the response."""
    if hasattr(request, "view_rate_limit"):
        window_stats = getattr(request, "view_rate_limit")
        response.headers.add(
            "X-RateLimit-Limit",
            str(window_stats.limit)
        )
        response.headers.add(
            "X-RateLimit-Remaining",
            str(window_stats.remaining)
        )
        response.headers.add(
            "X-RateLimit-Reset",
            str(window_stats.reset)
        )
    return response

# Fields that need case conversion for their values
CASE_CONVERTIBLE_FIELDS = ["status"]  # Add more fields here as needed

def convert_case(value: str, to_camel: bool) -> str:
    """Convert a string between snake_case and camelCase."""
    if to_camel:
        return humps.camelize(value)
    return humps.decamelize(value)

def convert_enum_values(data: Union[Dict, List], is_snake_to_camel: bool) -> Union[Dict, List]:
    """Convert enumerated values between snake_case and camelCase."""
    if isinstance(data, list):
        return [convert_enum_values(item, is_snake_to_camel) for item in data]
    
    if not isinstance(data, dict):
        return data
    
    result = {}
    for key, value in data.items():
        if isinstance(value, (dict, list)):
            value = convert_enum_values(value, is_snake_to_camel)
        elif isinstance(value, str) and key in CASE_CONVERTIBLE_FIELDS:
            value = convert_case(value, is_snake_to_camel)
        result[key] = value
    return result

def snake_to_camel(data: Union[Dict, List]) -> Union[Dict, List]:
    """Convert snake_case keys to camelCase and convert enumerated values."""
    # First convert the enum values
    data = convert_enum_values(data, is_snake_to_camel=True)
    # Then convert the keys
    return humps.camelize(data)

def camel_to_snake(data: Union[Dict, List]) -> Union[Dict, List]:
    """Convert camelCase keys to snake_case and convert enumerated values."""
    # First convert the keys
    data = humps.decamelize(data)
    # Then convert the enum values
    return convert_enum_values(data, is_snake_to_camel=False)

@app.errorhandler(Exception)
def handle_error(error: Exception) -> tuple[Dict[str, Any], int]:
    """Global error handler to ensure consistent error responses."""
    if hasattr(error, "code") and hasattr(error, "description"):
        # Handle Flask/HTTP errors
        status_code = error.code
        error_message = error.description
    else:
        # Handle other exceptions
        status_code = 500
        error_message = str(error)

    app.logger.error(f"Error: {error}")
    app.logger.error(traceback.format_exc())

    response = create_api_response(
        success=False,
        error={
            "code": status_code,
            "message": error_message
        }
    )
    return jsonify(response), status_code

@app.route("/api/v1/user-data", methods=["GET"])
@limiter.limit("180 per hour")
def get_user_data():
    """
    Get all data for a user (tasks, goals, categories, dashboard).
    Rate limit: 180 requests per hour
    """
    try:
        # Get user_id from auth token (placeholder - implement actual auth)
        user_id = request.headers.get("X-User-ID")
        user_id = "test-user"
        print("Fetching user data for user_id:", user_id)
        if not user_id:
            raise ValueError("User ID is required")

        # Get all user data using the new get_user_data method
        user_data = cosmos_db.get_user_data(user_id)

        # Convert to camelCase for frontend
        response_data = {
            "tasks": snake_to_camel(user_data["tasks"]),
            "goals": snake_to_camel(user_data["goals"]),
            "categories": snake_to_camel(user_data["categories"]),
            "dashboard": snake_to_camel(user_data["dashboard"]) if user_data["dashboard"] else None,
            "lastSyncedAt": datetime.now(timezone.utc).isoformat()
        }

        response = make_response(jsonify(create_api_response(success=True, data=response_data)))
        return add_rate_limit_headers(response)

    except Exception as e:
        raise

@app.route("/api/v1/sync", methods=["POST"])
@limiter.limit("360 per minute")
def sync_changes():
    """
    Sync changes between frontend and backend.
    Rate limit: 360 requests per minute
    """
    try:
        # Get user_id from auth token (placeholder - implement actual auth)
        user_id = request.headers.get("X-User-ID")
        user_id = "test-user"
        if not user_id:
            raise ValueError("User ID is required")

        # Get request data
        data = request.get_json()
        if not data:
            raise ValueError("Request body is required")

        changes = data.get("changes", [])
        client_last_sync = data.get("clientLastSync")

        if not client_last_sync:
            raise ValueError("clientLastSync is required")

        # Process each change
        server_changes = []
        has_errors = False

        for change in changes:
            change_type = change.get("type")
            operation = change.get("operation")
            item_id = change.get("id")
            # Convert the data while preserving all fields, including None values
            item_data = camel_to_snake(change.get("data")) if change.get("data") is not None else {}

            if item_data is not None:
                item_data["user_id"] = user_id
                item_data["type"] = change_type
                item_data["updated_at"] = datetime.now(timezone.utc).isoformat()

            try:
                if operation == "create":
                    if not item_data:
                        raise ValueError("Data is required for create operation")
                    item_data["id"] = item_id or str(uuid.uuid4())
                    result = cosmos_db.create_item(item_data)
                    if result:
                        server_changes.append({
                            "type": change_type,
                            "operation": "create",
                            "id": result["id"],
                            "data": snake_to_camel(result),
                            "timestamp": result["updated_at"]
                        })

                elif operation == "update":
                    if not item_id:
                        raise ValueError("Item ID is required for update operation")
                    result = cosmos_db.update_item(item_id, item_data)
                    if result:
                        server_changes.append({
                            "type": change_type,
                            "operation": "update",
                            "id": result["id"],
                            "data": snake_to_camel(result),
                            "timestamp": result["updated_at"]
                        })

                elif operation == "delete":
                    if not item_id:
                        raise ValueError("Item ID is required for delete operation")
                    if cosmos_db.delete_item(item_id, user_id):
                        server_changes.append({
                            "type": change_type,
                            "operation": "delete",
                            "id": item_id,
                            "timestamp": datetime.now(timezone.utc).isoformat()
                        })

            except Exception as operation_error:
                app.logger.error(f"Error processing change: {operation_error}")
                app.logger.error(traceback.format_exc())
                has_errors = True
                error_response = create_api_response(
                    success=False,
                    error=str(operation_error),
                    data={"serverChanges": server_changes}
                )
                response = make_response(jsonify(error_response), 500)
                return add_rate_limit_headers(response)

        # Only proceed with server changes if no errors occurred
        if not has_errors:
            # Get any server-side changes newer than client_last_sync
            server_items = cosmos_db.get_changes_since(user_id, client_last_sync)

            # Add server items to server_changes if they're not already included
            processed_ids = {change["id"] for change in server_changes}
            for item in server_items:
                if item["id"] not in processed_ids:
                    server_changes.append({
                        "type": item["type"],
                        "operation": "update",
                        "id": item["id"],
                        "data": snake_to_camel(item),
                        "timestamp": item["updated_at"]
                    })

            response_data = {
                "serverChanges": server_changes,
                "syncedAt": datetime.now(timezone.utc).isoformat()
            }

            response = make_response(jsonify(create_api_response(success=True, data=response_data)))
            return add_rate_limit_headers(response)

    except Exception as e:
        app.logger.error(f"Unexpected error in sync: {e}")
        app.logger.error(traceback.format_exc())
        error_response = create_api_response(success=False, error=str(e))
        response = make_response(jsonify(error_response), 500)
        return add_rate_limit_headers(response)

if __name__ == "__main__":
    app.run(debug=True)

--------------------------------------------------------------------------------
<File: backend/cosmos_db.py>
# File: backend/cosmos_db.py

import os
from typing import List, Dict, Any, Optional
from dotenv import load_dotenv
from azure.cosmos import CosmosClient, exceptions, PartitionKey
from azure.cosmos.container import ContainerProxy
from azure.cosmos.database import DatabaseProxy
from azure.identity import DefaultAzureCredential
from datetime import datetime, timezone, timedelta
import traceback

class CosmosDBManager:
    def __init__(self, cosmos_host=None, cosmos_database_id=None, cosmos_container_id=None):
        self._load_env_variables(cosmos_host, cosmos_database_id, cosmos_container_id)
        self.client = self._get_cosmos_client()
        self.database: Optional[DatabaseProxy] = None
        self.container: Optional[ContainerProxy] = None
        self._initialize_database_and_container()

    def _load_env_variables(self, cosmos_host=None, cosmos_database_id=None, cosmos_container_id=None):
        load_dotenv()
        self.cosmos_host = cosmos_host or os.environ.get("COSMOS_HOST")
        self.cosmos_database_id = cosmos_database_id or os.environ.get("COSMOS_DATABASE_ID")
        self.cosmos_container_id = cosmos_container_id or os.environ.get("COSMOS_CONTAINER_ID")
        self.tenant_id = os.environ.get("TENANT_ID", '16b3c013-d300-468d-ac64-7eda0820b6d3')

        if not all([self.cosmos_host, self.cosmos_database_id, self.cosmos_container_id]):
            raise ValueError("Cosmos DB configuration is incomplete")

    def _get_cosmos_client(self) -> CosmosClient:
        print("Initializing Cosmos DB client")
        print("Using DefaultAzureCredential for Cosmos DB authentication")
        credential = DefaultAzureCredential(
            interactive_browser_tenant_id=self.tenant_id,
            visual_studio_code_tenant_id=self.tenant_id,
            workload_identity_tenant_id=self.tenant_id,
            shared_cache_tenant_id=self.tenant_id
        )
        return CosmosClient(self.cosmos_host, credential=credential)

    def _initialize_database_and_container(self) -> None:
        try:
            self.database = self._create_or_get_database()
            self.container = self._create_or_get_container()
        except exceptions.CosmosHttpResponseError as e:
            print(f'An error occurred: {e.message}')
            raise

    def _create_or_get_database(self) -> DatabaseProxy:
        try:
            database = self.client.create_database(id=self.cosmos_database_id)
            print(f'Database with id \'{self.cosmos_database_id}\' created')
        except exceptions.CosmosResourceExistsError:
            database = self.client.get_database_client(self.cosmos_database_id)
            print(f'Database with id \'{self.cosmos_database_id}\' was found')
        return database

    def _create_or_get_container(self) -> ContainerProxy:
        try:
            container = self.database.create_container(
                id=self.cosmos_container_id, 
                partition_key=PartitionKey(path='/user_id')
            )
            print(f'Container with id \'{self.cosmos_container_id}\' created')
        except exceptions.CosmosResourceExistsError:
            container = self.database.get_container_client(self.cosmos_container_id)
            print(f'Container with id \'{self.cosmos_container_id}\' was found')
        return container

    # Core CRUD Operations
    def get_item_by_id(self, item_id: str, user_id: str) -> Optional[Dict[str, Any]]:
        """Get a single item by its ID and user_id (partition key)."""
        try:
            item = self.container.read_item(item=item_id, partition_key=user_id)
            return item
        except exceptions.CosmosResourceNotFoundError:
            return None
        except Exception as e:
            print(f"Error retrieving item {item_id}: {str(e)}")
            raise

    def create_item(self, item: Dict[str, Any]) -> Dict[str, Any]:
        """Create a new item in the container."""
        try:
            if 'user_id' not in item:
                raise ValueError("user_id (partition key) is required for create operation")
            
            # Ensure timestamps are set
            current_time = datetime.now(timezone.utc).isoformat()
            item['created_at'] = current_time
            item['updated_at'] = current_time
            
            created_item = self.container.create_item(body=item)
            print(f"Item created with id: {created_item['id']}")
            return created_item
        except exceptions.CosmosResourceExistsError:
            print(f"Item with id {item.get('id')} already exists")
            raise
        except Exception as e:
            print(f"Error creating item: {str(e)}")
            raise

    def update_item(self, item_id: str, updates: Dict[str, Any]) -> Dict[str, Any]:
        """Update an existing item with new values."""
        try:
            # Get the existing item
            existing_item = self.get_item_by_id(item_id, updates['user_id'])
            if not existing_item:
                raise ValueError(f"Item with id {item_id} not found")

            # Update the item with new values
            existing_item.update(updates)
            existing_item['updated_at'] = datetime.now(timezone.utc).isoformat()

            # Replace the item in the container
            updated_item = self.container.replace_item(
                item=item_id,
                body=existing_item
            )
            return updated_item
        except Exception as e:
            print(f"Error updating item {item_id}: {str(e)}")
            raise

    def delete_item(self, item_id: str, user_id: str) -> bool:
        """Delete an item by its ID."""
        try:
            self.container.delete_item(item=item_id, partition_key=user_id)
            return True
        except exceptions.CosmosResourceNotFoundError:
            return False
        except Exception as e:
            print(f"Error deleting item {item_id}: {str(e)}")
            raise

    def get_user_data(self, user_id: str) -> Dict[str, List[Dict[str, Any]]]:
        """Get all data for a user (tasks, goals, categories, dashboard)."""
        try:
            query = """
            SELECT * FROM c 
            WHERE c.user_id = @user_id
            """
            items = list(self.container.query_items(
                query=query,
                parameters=[{"name": "@user_id", "value": user_id}],
                enable_cross_partition_query=False
            ))

            # Organize items by type
            result = {
                "tasks": [],
                "goals": [],
                "categories": [],
                "dashboard": None
            }

            for item in items:
                item_type = item.get("type")
                if item_type == "task":
                    result["tasks"].append(item)
                elif item_type == "goal":
                    result["goals"].append(item)
                elif item_type == "category":
                    result["categories"].append(item)
                elif item_type == "dashboard":
                    result["dashboard"] = item

            return result
        except Exception as e:
            print(f"Error getting user data: {str(e)}")
            raise

    def get_changes_since(self, user_id: str, since_timestamp: str) -> List[Dict[str, Any]]:
        """Get all items that have been updated since a given timestamp."""
        try:
            query = """
            SELECT * FROM c 
            WHERE c.user_id = @user_id 
            AND c.updated_at > @since_timestamp
            """
            items = list(self.container.query_items(
                query=query,
                parameters=[
                    {"name": "@user_id", "value": user_id},
                    {"name": "@since_timestamp", "value": since_timestamp}
                ],
                enable_cross_partition_query=False
            ))
            return items
        except Exception as e:
            print(f"Error getting changes since timestamp: {str(e)}")
            raise



--------------------------------------------------------------------------------
<File: docs/design_document.md>
# Life Manager Design Document

## Table of Contents

1. [Core Architecture](#core-architecture)
   - [Technology Stack](#technology-stack)
   - [State Management](#state-management)
   - [Data Flow & Sync Strategy](#data-flow--sync-strategy)

2. [Data Models](#data-models)
   - [Frontend Data Models (TypeScript)](#frontend-data-models-typescript)
     - [Interface Usage Guidelines](#interface-usage-guidelines)
     - [Common Types](#common-types)
     - [Task Interface](#task-interface)
   - [Backend Data Models (CosmosDB)](#backend-data-models-cosmosdb)
     - [Container Strategy & Querying](#container-strategy--querying)
     - [Indexing Strategy](#indexing-strategy)
     - [Document Models](#document-models)

3. [APIs](#apis)
   - [Base URL](#base-url)
   - [Common Response Format](#common-response-format)
   - [Error Codes](#error-codes)
   - [Core Endpoints](#core-endpoints)

4. [Logging](#logging)
   - [Initial Load](#initial-load)
   - [State Changes](#state-changes)
   - [Backend Sync Operations](#backend-sync-operations)

5. [Implementation Details](#implementation-details)
   - [Project Structure](#project-structure)
   - [Page Implementations](#page-implementations)
     - [Master List Page](#master-list-page)
     - [Weekly Plan Page](#weekly-plan-page)
     - [Home Page](#home-page)
   - [Core Components](#core-components)
     - [Sidebar & Top Panel](#sidebar--top-panel)
   
6. [Styling & UI](#styling--ui)
    - [High-Level Strategy](#high-level-strategy)
    - [Layout Architecture](#layout-architecture)
    - [Design Tokens](#design-tokens)
    - [Interactive Elements](#interactive-elements)
    - [Component Architecture](#component-architecture)





## Core Architecture

### Technology Stack
- Frontend: React/Vite, TailwindCSS, Shadcn Components, Redux Toolkit
- Backend: Python, Flask
- Database: CosmosDB

### State Management

#### Global State (Redux)
All persistent data lives in Redux, serving as the single source of truth for the application. This includes:

1. **User Data**
   - Tasks

2. **Application State**
   - Sync status (success, error)
   - Last sync timestamp

3. **Store Structure**
```typescript
interface RootState {
    tasks: {
        items: Record<UUID, Task>;
        loading: boolean;
        error: string | null;
    };
    sync: {
        status: 'idle' | 'syncing' | 'error';
        lastSynced: string | null;
        pendingChanges: number;
    };
}
```

#### Local State
Used only for temporary UI states within components:
- Form input values before submission
- Modal/dropdown open/closed states
- Component-specific loading states
- Any temporary data that doesn't need to persist

### Data Flow & Sync Strategy

#### User Login / Initial Load
```mermaid
flowchart LR
    DB[(CosmosDB)] --> 
    API[(/api/v1/user-data)] --> 
    Store[(Redux Store)] --> 
    UI[Application UI]

    classDef storeNode fill:#FF8C00,stroke:#333,stroke-width:2px,color:white
    classDef apiNode fill:#50C878,stroke:#333,stroke-width:2px,color:white
    classDef dbNode fill:#FF69B4,stroke:#333,stroke-width:2px,color:white
    classDef uiNode fill:#9370DB,stroke:#333,stroke-width:2px,color:white

    class Store storeNode
    class API apiNode
    class DB dbNode
    class UI uiNode
```



#### User Interactions
```mermaid
flowchart LR
    Actions[User Actions] -->
    Store[(Redux Store)] -->
    UI[Application UI]
    Store -.->|Debounced Sync| API[(/api/v1/user-data)] -->
    DB[(CosmosDB)]

    classDef storeNode fill:#FF8C00,stroke:#333,stroke-width:2px,color:white
    classDef apiNode fill:#50C878,stroke:#333,stroke-width:2px,color:white
    classDef actionNode fill:#4169E1,stroke:#333,stroke-width:1px,color:white
    classDef dbNode fill:#FF69B4,stroke:#333,stroke-width:2px,color:white
    classDef uiNode fill:#9370DB,stroke:#333,stroke-width:2px,color:white

    class Store storeNode
    class API apiNode
    class Actions actionNode
    class DB dbNode
    class UI uiNode
```


#### 1. Initial Load
```
// In the application's root component (e.g., _app.tsx)
// On initial load:
// 1. Dispatch a loading action to set the application state to loading.
// 2. Call the API to fetch initial user data.
// 3. On successful data fetch:
//    - Dispatch an action to initialize the Redux store with the fetched data.
// 4. On error:
//    - Dispatch an action to set the error state with the error message.
// 5. Finally:
//    - Dispatch a loading action to set the application state to not loading.
```

#### 2. State Updates
```
// The useStateSync hook provides a consistent way to handle state updates.
// It takes a change type (e.g., 'text', 'status', 'priority', 'drag') and an item with changes.
// 1. On change:
//    - Dispatch a Redux action to immediately update the store with the changes.
//      This dispatch triggers a Redux reducer that updates the state.
//    - Trigger a debounced backend sync operation based on the change type.
// The hook returns a handleChange function that components can use to update state.
// The SYNC_CONFIG object defines the debounce time for each change type.
```

#### 3. Component Integration
```
// All components use the same state management pattern to handle data modifications.
// For example, a TaskCard component:
// 1. Uses the handleChange function from useStateSync.
// 2. When the task title input changes:
//    - Calls handleChange with the 'text' change type, the task object, and the new title.
// 3. When the task status changes:
//    - Calls handleChange with the 'status' change type, the task object, and the new status and updated status history.
```

#### 4. Sync Status Management
```
// The SyncIndicator component provides visual feedback on the sync status.
// 1. It uses a Redux selector to get the current sync state.
// 2. If the sync status is 'syncing', it displays a spinner.
// 3. If the sync status is 'error', it displays an error icon.
//    The error icon will be displayed during retry attempts and after all retries have failed.
// 4. If the sync status is 'idle' and there is a last synced timestamp, it displays the last saved time.
```

#### 5. Error Handling
```
// The handleSyncError function handles failed sync operations.
// 1. It takes an error object and an optional retry attempt counter.
// 2. If the retry attempt is less than the maximum number of retries:
//    - It waits for an exponentially increasing amount of time.
//    - It calls the performSync function to retry the sync operation.
// 3. If the maximum number of retries is reached:
//    - It dispatches an action to set the sync error state with the error message.
```


This architecture provides:
- Single source of truth in Redux
- Consistent state update pattern
- Optimistic updates with backend sync
- Clear sync status feedback
- Automatic error handling and retries
- Simple component integration

## Data Models

### Frontend Data Models (TypeScript)

#### Interface Usage Guidelines

1. **Strict Type Adherence**
   - All frontend components must strictly implement these interfaces
   - No extending interfaces without documentation and team review
   - No bypassing optional fields with type assertions (`!` or `as`)
   - All interface extensions must be backwards compatible

2. **State Management**
   - Redux store must maintain normalized data matching these interfaces
   - All API responses must be validated against these interfaces
   - No storing derived data that can be computed from interface fields
   - Use selectors for computing derived data

3. **Component Props**
   - Components should accept the smallest necessary subset of interfaces
   - Use TypeScript utility types to create precise prop interfaces:
     ```typescript
     // Good
     interface TaskTitleProps {
         task: Pick<Task, 'id' | 'title'>;
     }

     // Avoid
     interface TaskTitleProps {
         task: Task;  // Exposes unnecessary fields
     }
     ```
   - Document required vs optional props

4. **Modification Rules**
   - Interface changes require documentation update
   - Breaking changes must be versioned
   - Additions to interfaces must be optional fields
   - Update all relevant type definitions when modifying interfaces

#### Common Types
```typescript
type UUID = string;
type ISODateString = string;

type Status = 'notStarted' | 'workingOnIt' | 'complete';
type RecurrenceFrequency = 'daily' | 'weekly' | 'monthly' | 'yearly';
type TimeRange = 'day' | 'week' | 'month';

interface CompletionEntry {
    completedAt: ISODateString;
    nextDueDate?: ISODateString;
    completionNotes?: string;
}

interface RecurrenceRule {
    frequency: RecurrenceFrequency;
    interval: number;
    endDate?: ISODateString;
    maxOccurrences?: number;
    daysOfWeek?: number[];  // 0-6 for weekly
    dayOfMonth?: number;    // 1-31 for monthly
    months?: number[];      // 1-12 for yearly
    weekOfMonth?: number;   // -1 to 5 (-1 for last)
}
```

#### Task Interface
```typescript
interface Task {
    id: UUID;
    userId: UUID;
    type: 'task';
    title: string;
    status: Status;
    priority: number;
    dynamicPriority: number;
    effort?: number;
    notes?: string;
    dueDate?: ISODateString;
    scheduledDate?: ISODateString;
    createdAt: ISODateString;
    updatedAt: ISODateString;
    
    completionHistory: CompletionEntry[];
    
    recurrence?: {
        isRecurring: boolean;
        rule?: RecurrenceRule;
    };
    
    tags?: string[];
}
```

### Display Mappings

#### Status Display Mapping
```typescript
const STATUS_DISPLAY = {
    notStarted: 'Not Started',
    workingOnIt: 'Working on It',
    complete: 'Complete'
};

const STATUS_COLORS = {
    notStarted: 'gray.500',
    workingOnIt: 'yellow.500',
    complete: 'green.500'
};
```

#### Priority Display Mapping
```typescript
const PRIORITY_DISPLAY = {
    ranges: [
        { min: 80, label: 'Very High', color: 'red.500' },
        { min: 60, label: 'High', color: 'orange.500' },
        { min: 40, label: 'Medium', color: 'yellow.500' },
        { min: 20, label: 'Low', color: 'green.500' },
        { min: 0, label: 'Very Low', color: 'green.250' }
    ]
};
```

#### Effort Display Mapping
```typescript
const EFFORT_DISPLAY = {
    1: {
        label: 'Very Low',
        color: 'green.300'  // Light green for minimal effort
    },
    2: {
        label: 'Low',
        color: 'green.500'  // Medium green for low effort
    },
    3: {
        label: 'Medium',
        color: 'yellow.500'  // Yellow for moderate effort
    },
    4: {
        label: 'High',
        color: 'orange.500'  // Orange for high effort
    },
    5: {
        label: 'Very High',
        color: 'red.500'  // Red for maximum effort
    }
};
```

#### Time Range Display Mapping
```typescript
const TIME_RANGE_DISPLAY = {
    day: 'Daily',
    week: 'Weekly',
    month: 'Monthly'
};
```

### Backend Data Models (CosmosDB)

All variable names are in snake_case. All documents are stored in a single container to enable efficient querying of a user's complete data set.
The frontend uses camelCase for its data models. A manual conversion process is used to handle the differences in naming conventions during API requests and responses.

#### Case Conversion Functions

All data transformations between the backend's `snake_case` data models and the frontend's `camelCase` data models are handled on the backend. This ensures that the frontend receives data in the expected format without needing to perform any conversion logic.

The backend uses two types of case conversion:

1. **Key Case Conversion**: All object keys are converted between snake_case and camelCase.
   ```python
   # Example key conversion:
   "user_id" <-> "userId"
   "created_at" <-> "createdAt"
   "due_date" <-> "dueDate"
   ```

2. **Value Case Conversion**: Certain enumerated string values are also converted between cases.
   ```python
   # Fields that need value case conversion:
   CASE_CONVERTIBLE_FIELDS = ["status"]  # Add more fields as needed

   # Example value conversion for status:
   "not_started" <-> "notStarted"
   "working_on_it" <-> "workingOnIt"
   ```

The conversion process:
1. For frontend responses (snake_to_camel):
   - First converts enumerated values to camelCase
   - Then converts all keys to camelCase

2. For backend storage (camel_to_snake):
   - First converts all keys to snake_case
   - Then converts enumerated values to snake_case

This approach:
- Centralizes the transformation logic
- Makes it easy to add new fields that need value conversion
- Ensures consistency across all API responses
- Simplifies frontend code by removing the need for any data conversion logic
- Makes debugging easier with explicit string manipulation

#### Container Strategy & Querying
The application uses a single container strategy where:
- All task documents live in one container
- Documents are partitioned by `user_id`
- The `type` field enables filtering within a user's partition
- Single query can efficiently retrieve all data for a user

Example query to get all user data:
```sql
SELECT * FROM c
WHERE c.user_id = @userId
```

#### Indexing Strategy
The container uses these indexes to optimize common query patterns:
```json
{
    "indexingPolicy": {
        "includedPaths": [
            {
                "path": "/user_id/?",
                "indexes": [
                    {
                        "kind": "Range",
                        "dataType": "String"
                    }
                ]
            },
            {
                "path": "/type/?",
                "indexes": [
                    {
                        "kind": "Range",
                        "dataType": "String"
                    }
                ]
            },
            {
                "path": "/updated_at/?",
                "indexes": [
                    {
                        "kind": "Range",
                        "dataType": "String"
                    }
                ]
            }
        ]
    }
}
```

#### Document Models

##### Task Document
```json
{
    // Metadata
    "id": "string (UUID)",
    "user_id": "string (UUID)",
    "type": "task",
    "partition_key": "string (user_id)",
    
    // Core Fields
    "title": "string",
    "status": "string (enum: not_started, working_on_it, complete)",
    "priority": "number (0-100)",
    "dynamic_priority": "number (0-100)",
    "effort": "number (1-5, optional)",
    "notes": "string (optional)",
    
    // Dates
    "due_date": "string (ISO date, optional)",
    "scheduled_date": "string (ISO date, optional)",
    "created_at": "string (ISO date)",
    "updated_at": "string (ISO date)",
    
    "completion_history": [
        {
            "completed_at": "string (ISO date)",
            "next_due_date": "string (ISO date, optional)",
            "completion_notes": "string (optional)"
        }
    ],
    

    // Recurrence
    "recurrence": {
        "is_recurring": "boolean",
        "rule": {
            "frequency": "string (enum: daily, weekly, monthly, yearly)",
            "interval": "number",
            "days_of_week": "number[] (0-6, optional)",
            "day_of_month": "number (1-31, optional)",
            "months": "number[] (1-12, optional)",
            "week_of_month": "number (-1 to 5, optional)"
        }
    }

}
```

## APIs

### Base URL
```
https://api.lifemanager.app/v1
```

### Common Response Format
All API responses follow a consistent format:

```typescript
interface ApiResponse<T> {
    success: boolean;
    data?: T;
    error?: {
        code: string;
        message: string;
        details?: any;
    };
    metadata?: {
        timestamp: string;
        requestId: string;
        pagination?: {
            total: number;
            page: number;
            pageSize: number;
            hasMore: boolean;
        };
    };
}
```

### Error Codes
Standard HTTP status codes are used along with custom error codes.
The API response will include the HTTP status code and the custom error code in the error object.

| HTTP Status | Error Code | Description |
|------------|------------|-------------|
| 400 | INVALID_REQUEST | Malformed request or invalid parameters |
| 404 | NOT_FOUND | Resource not found |
| 409 | CONFLICT | Resource conflict (e.g., duplicate) |
| 422 | VALIDATION_ERROR | Request validation failed |
| 500 | INTERNAL_ERROR | Server error |
| 503 | SERVICE_UNAVAILABLE | Service temporarily unavailable |

### Core Endpoints

#### Initial Data Load
```http
GET /api/v1/user-data
Description: Loads all user data at application startup. This is the only bulk data fetch operation.

Response: {
    success: true,
    data: {
        tasks: Record<UUID, Task>;
        lastSyncedAt: string; // ISO date
    }
}
```

#### Sync Changes
```http
POST /api/v1/sync
Description: Debounced endpoint that receives changes from the frontend. Called automatically after user actions with configured debounce times per change type.

Request Body: {
    changes: Array<{
        type: 'task';
        operation: 'create' | 'update' | 'delete';
        id?: UUID;  // Required for update/delete
        data?: Partial<Task>;  // Required for create/update
        timestamp: string;  // ISO date of when change occurred
        changeType?: 'text' | 'status' | 'priority' | 'drag';  // For debounce configuration
    }>;
    clientLastSync: string;  // ISO date of last successful sync
}

Response: {
    success: true,
    data: {
        // Only sent if server has newer changes
        serverChanges?: Array<{
            type: 'task';
            operation: 'create' | 'update' | 'delete';
            id: UUID;
            data?: any;
            timestamp: string;
        }>;
        syncedAt: string;  // ISO date of this sync
    }
}
```

###  Logging

#### Initial Load
On application load, the entire Redux state is logged to the console:
```typescript
// In store configuration
const store = configureStore({
  reducer: rootReducer,
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware().concat(logger),
});

// Custom logger middleware
const logger = store => next => action => {
  if (action.type === '@@INIT') {
    console.log('Initial Redux State:', store.getState());
  }
  return next(action);
};
```

#### State Changes
Every Redux state change is logged to the console with:
- The action type
- The specific state changes (diff)
- Timestamp of the change

```typescript
// Example console output for a task update
{
  type: 'tasks/updateTask',
  payload: {
    id: '123',
    changes: {
      title: 'Updated Task Title',
      status: 'workingOnIt'
    }
  },
  timestamp: '2024-01-20T12:34:56.789Z'
}
```

#### Backend Sync Operations
Each sync operation is logged with:
- The changes being synced
- The sync result (success/failure)
- Any error messages if applicable

```typescript
// Example console output for sync operation
{
  type: 'sync/started',
  changes: [
    {
      type: 'task',
      operation: 'update',
      id: '123',
      data: { title: 'Updated Task Title' }
    }
  ],
  timestamp: '2024-01-20T12:34:57.789Z'
}

// Success case
{
  type: 'sync/completed',
  result: 'success',
  syncedAt: '2024-01-20T12:34:58.789Z'
}

// Failure case
{
  type: 'sync/failed',
  error: {
    code: 'NETWORK_ERROR',
    message: 'Failed to connect to server'
  },
  timestamp: '2024-01-20T12:34:58.789Z'
}
```






## Implementation Details

### Project Structure
The project follows a well-organized structure detailed in [project_structure.md](./project_structure.md). Key highlights include:

- Clear separation of frontend and backend code
- Organized component hierarchy
- Consistent file naming and organization
- Centralized configuration files
- Documentation organization

### Page Implementations

#### Master List Page
The Master List page implementation is documented in [master_list.md](./master_list.md). It covers:

- Table-based task display
- Task creation and modification
- Status updates and animations
- Priority and effort management
- Task details dialog
- Sync operations

#### Weekly Plan Page
*Detailed design document pending*

The Weekly Plan page will follow similar documentation patterns as the Master List page, with its own specific requirements and implementation details.

#### Home Page
*Detailed design document pending*

The Home page will follow similar documentation patterns as the Master List page, with its own specific requirements and implementation details.

### Core Components

#### Sidebar & Top Panel

##### Overview
The application includes a persistent global sidebar (on the left) and a top panel (header bar) that remain visible across all pages. These two navigation and control areas ensure quick access to core features and important indicators (sync status, settings, login/logout, etc.).

##### Goals & Requirements

###### Centralized Navigation
- Provide quick links to core pages (Home, Weekly Plan, Master List, etc.)
- Allow easy navigation without refreshing or reloading the application

###### Persistent Visibility
- Remain visible/accessible at all times, regardless of the active page
- Collapse or expand the sidebar in response to user preference or screen size

###### Key Controls in Top Panel
- Settings button for user preferences, theme toggles, or account info
- Sync/Save Indicator to reflect the real-time sync status from the Redux store
- Login/Logout button/indicator to manage authentication state

###### Responsive & Accessible
- Adapt layout for mobile, tablet, and desktop screen sizes
- Provide clear focus states, ARIA labels, and keyboard navigation

##### Layout & Components
```
+------------------------------------------------------------------------+
| [App Logo / Title]            [Sync Indicator]  [Settings]  [Logout]   |
+------------------+-----------------------------------------------------+
|   Sidebar        |  Main Content Area                       |
|   [Nav Links]    |  (Home / Weekly Plan / Master List etc.) |
|   [User Info]    |                                          |
|   [Collapse Btn] |                                          |
+------------------+-----------------------------------------------------+
```

##### Sidebar Implementation

###### Navigation Links
- Home
- Weekly Plan
- Master List

###### User Info / Profile Section 
- Empty for now

###### Collapse/Expand Control
- A button (e.g., a hamburger icon or double-chevron) that toggles the sidebar's width
- Uses local React state since it only affects the layout

###### Responsive Behavior
- Mobile: The sidebar may slide in/out over the content
- Desktop: The sidebar remains docked on the left

###### Implementation Details
- Housed in a `<Sidebar>` component, rendered at the same level as the main content
- All navigation items are stored in an array or config object (e.g., `NAV_LINKS = [{ path: '/home', label: 'Home', icon: ... }, ...]`), then mapped to `<NavLink>` items
- Uses local React state for collapse state since it only affects the layout

##### Top Panel Implementation

###### Position & Layout
- Stays at the top of the viewport, spanning the full width

###### Content Components
- App Logo or Title: Left-aligned; navigates back to Home or a landing page
- Sync/Save Indicator:
  - Reflects the Redux sync state (idle, syncing, error)
  - Could be a small icon + text (e.g., "All changes saved" or a spinner if syncing)
  - Ties into the same sync slice that other pages use (see Core Architecture > State Management)
  - Top right corner
- Settings Button:
  - Opens a modal or dedicated page with user-configurable settings (theme, notifications, account details, etc.)
  - Could be an icon button that triggers `<SettingsModal>`
  - Inactive for now
  - Top right corner
- Login/Logout Button:
  - Shows "Login" if user is not authenticated, "Logout" if user is authenticated
  - On click, dispatches an auth action or navigates to a login page
  - Top right corner
  - Inactive for now






## Styling & UI

### Core Principles
- Use Tailwind CSS as the primary styling solution
- Configure core design tokens (colors, typography, spacing) in `tailwind.config.js`
- Leverage shadcn/ui components for common UI elements
- Minimize component-specific styling
- Maintain consistent responsive behavior across all pages
- lucide icons

### Global Configuration

#### Tailwind Setup
```javascript
// tailwind.config.js
module.exports = {
  theme: {
    extend: {
      colors: {
        // Core brand colors
        primary: '#1D4ED8',
        secondary: '#9333EA',
        accent: '#F59E0B'
      },
      fontFamily: {
        sans: ['Inter', 'sans-serif']
      }
    }
  }
}
```

#### Component Library
- Use shadcn/ui components for standard UI elements (buttons, inputs, modals)
- Maintain default shadcn styling unless specific requirements dictate otherwise
- Configure component themes through shadcn's built-in theming system

### Layout Structure
- Global layout wrapper handles standard page structure
- Responsive design uses Tailwind's breakpoint system
- Consistent spacing and container widths across pages

### Styling Guidelines
1. Use Tailwind utility classes for layout and basic styling
2. Apply component-specific styles only when required by design specs
3. Keep custom CSS minimal and well-documented
4. Maintain consistent spacing, typography, and color usage across components

### Visual Feedback
- Status indicators follow predefined color schemes
- Loading states use consistent animations
- Error states maintain uniform styling
- Toast notifications follow a standard design pattern
--------------------------------------------------------------------------------
<File: docs/master_list.md>
# Master List Page Requirements & Implementation

## Table of Contents
1. [Overview](#overview)
2. [Purpose & Goals](#purpose--goals)
3. [Key Features](#key-features)
    - [Task Table](#task-table)
    - [New Task Creation](#new-task-creation)
    - [Status Updates](#status-updates)
    - [Priority & Effort Updates](#priority--effort-updates)
    - [Task Deletion](#task-deletion)
    - [Task Details Dialog](#task-details-dialog)
4. [Data Flow & Architecture](#data-flow--architecture)
    - [Redux State & Actions](#redux-state--actions)
    - [Sync Operations](#sync-operations)
    - [UI/UX Flow](#uiux-flow)
5. [Relevant Code Files & Interfaces](#relevant-code-files--interfaces)
    - [MasterListPage.tsx](#masterlistpagetsx)
    - [TaskTable.tsx](#tasktabletsx)
    - [TaskTableRow.tsx](#tasktablerowtsx)
    - [AddTaskDialog.tsx](#addtaskdialogtsx)
    - [Task.ts Interface](#taskts-interface)
    - [Sync Engine & Data Models](#sync-engine--data-models)
6. [How It Aligns with the Design Document](#how-it-aligns-with-the-design-document)
7. [Future Enhancements](#future-enhancements)

---

## Overview
The **Master List** page displays all tasks in a tabular, filterable, and sortable layout. It also allows users to create new tasks, update existing tasks (status, priority, effort, etc.), and view additional details in a dialog. This page is intended to be a centralized "all-tasks" view, complementing other domain-specific pages like the Weekly Plan.

In the UI screenshot, each row of the table shows a single task's essential information (title, status, priority, effort, due date, etc.). A user can also create new tasks via the **New Task** button at the top right.

---

## Purpose & Goals
- **Easy Visibility**: Provide a single page for users to see all their tasks in a list/table format.
- **Quick Interaction**: Change statuses, priorities, or effort with minimal clicks.
- **New Task Creation**: Let users add tasks without leaving the page.
- **Detailed Inspection**: Access more info in a pop-up dialog (history, recurrence info, notes).
- **Backend Sync**: Changes appear instantly in the UI (optimistic updates) and automatically sync with the backend via the shared sync engine.

---

## Key Features

### Task Table
- Renders a table of tasks, one per row.
- Each column includes properties like **Title**, **Status**, **Priority**, **Effort**, **Due Date**, **Recurrence**, and **Notes**.
- The final **Actions** column provides buttons to **view** task details or **delete** the task.

### New Task Creation
- A **New Task** button is positioned in the top-right corner of the page.
- Clicking it opens the `AddTaskDialog`, a modal form that collects:
  - **Title** (required)
  - **Priority** (defaults to Medium / 40)
  - **Effort** (defaults to Medium / 3)
  - **Due Date** (optional date selector)
  - **Notes** (optional text)
  - **Recurrence** (optional, with fields for frequency and interval)
- Form validations ensure a title is entered and recurrence intervals make sense.

### Status Updates
- Clicking the **status bubble** in each row cycles the task through `Not Started`, `Working on It`, and `Complete`. 
- If the task is recurring, setting it to `complete` triggers logic to reset it:
  1. Marks it complete momentarily.
  2. Creates a completion record in `completionHistory`.
  3. Immediately resets status to `not_started`, updates `due_date` based on the recurrence rule, and logs a toast notification.
- The user sees an animation while the task transitions.

### Priority & Effort Updates
- **Priority**: Each row includes a priority chip. Clicking it cycles through `Very Low (0)`, `Low (20)`, `Medium (40)`, `High (60)`, `Very High (80)`.
- **Effort**: A similar chip cycles from `Very Low (1)` to `Very High (5)`.

### Task Deletion
- Each row has a trash icon button. Clicking it pops open a small **Popover** to confirm deletion. If confirmed, the task is optimistically removed from Redux and marked for deletion in the backend sync engine.

### Task Details Dialog
- Clicking the eye icon opens the `TaskDetails` dialog, which shows:
  - Status and color-coded bubble
  - Priority (numeric plus color-coded chip)
  - Due Date (read-only display)
  - Scheduled Date (read-only display)
  - Recurrence summary (if any)
  - Completion History (timestamps and optional completion notes)
- This dialog is read-only by default but helps the user quickly reference deeper details.

---

## Data Flow & Architecture

### Redux State & Actions
1. **`taskSlice`**  
   - Stores tasks in normalized form (`items: Record<id, Task>`).
   - Includes actions: `addTask`, `updateTask`, `deleteTask`, `setTasks` (bulk set).
   
2. **`syncSlice`**  
   - Stores the global sync state: `status: 'idle' | 'syncing' | 'error'`, plus `lastSynced` timestamp.
   - Actions like `setSyncStatus`, `setLastSynced` keep track of sync progress.

### Sync Operations
- **Optimistic Updates**: Whenever the user changes a task (status, priority, etc.), the UI updates immediately.
- **Debounced Sync**: The system schedules a sync request to the `/api/v1/sync` endpoint after a brief delay. Each type of change (e.g. status vs. text) has a different debounce time.
- The server's response may contain newer changes from other clients or server-side logic, which get merged back into local state.

### UI/UX Flow
1. **Load**: When the user navigates to the Master List page, the tasks are already loaded into Redux from an initial fetch at app startup.
2. **Interaction**: 
   - User sees a table of tasks.  
   - User can click status, priority, or effort chips to cycle through values; a sync operation is scheduled automatically.  
   - Deletion or creation triggers an immediate store update plus a background sync.  
   - If recurring tasks are completed, the system initiates a small animation, updates the store, and triggers a re-sync.

---

## Relevant Code Files & Interfaces

### `MasterListPage.tsx`
- **Location**: `frontend/src/pages/MasterListPage.tsx`
- **Responsibilities**:
  - Fetches tasks from Redux and converts to array (`tasksArray`).
  - Renders the **New Task** button, which opens `AddTaskDialog`.
  - Displays `TaskTable` with all tasks.

### `TaskTable.tsx`
- **Location**: `frontend/src/components/task/TaskTable.tsx`
- **Responsibilities**:
  - Receives an array of tasks.
  - Renders them in a `<table>` structure using shadcn/ui `Table` components.
  - Maps each task to a `TaskTableRow`.

### `TaskTableRow.tsx`
- **Location**: `frontend/src/components/task/TaskTableRow.tsx`
- **Responsibilities**:
  - Renders each task's columns (title, status, priority, etc.).
  - Implements click handlers to cycle statuses, priority, effort.
  - Initiates sync calls via `syncChanges(...)`.
  - Opens the `TaskDetails` dialog or the delete confirmation popover.

### `AddTaskDialog.tsx`
- **Location**: `frontend/src/components/task/AddTaskDialog.tsx`
- **Responsibilities**:
  - Renders a form in a dialog for creating new tasks:
    - Title, Priority, Effort, Due Date, Notes, Recurrence, etc.
  - Validates user input (e.g., Title is required).
  - Dispatches `addTask` to Redux plus a "create" operation to the sync engine.
  - Closes on successful creation.

### `Task.ts` Interface
- **Location**: `frontend/src/utils/types.ts`
- **Interface Definition**:
  ```typescript
  export interface Task {
    id: UUID;
    userId: UUID;
    type: 'task';
    title: string;
    status: 'notStarted' | 'workingOnIt' | 'complete';
    priority: number;
    dynamicPriority: number;
    effort?: number;
    notes?: string;
    dueDate?: string;
    scheduledDate?: string;
    createdAt: string;
    updatedAt: string;
    completionHistory: CompletionEntry[];
    recurrence?: { isRecurring: boolean; rule?: RecurrenceRule };
    tags?: string[];
  }
  ```
- The status field is used heavily on this page (cycling from `notStarted`  `workingOnIt`  `complete`).
- The optional recurrence object leads to automatic re-scheduling logic when a task is completed.

### Sync Engine & Data Models
- `syncEngine.ts` manages debounced sync calls.
- `api.ts` provides methods for fetching user data (`getUserData`) and syncing changes (`sync`).
- Backend: Follows the design document's architecture, using a single container in Cosmos DB with snake_case fields.
- Case conversions happen on the backend so the frontend can remain in camelCase.

---

## How It Aligns with the Design Document
- **Single Source of Truth**: Uses Redux for local state; aligns with "Data Flow & Sync Strategy" from the design doc.
- **Optimistic Updates**: Immediately applies UI changes, then syncs in the background.
- **Enum & Value Mappings**: Follows the design doc's approach for statuses, priority ranges, effort levels, and recurrence data.
- **Case Conversion**: The backend handles snake_case, while the frontend remains in camelCase per the design doc's instructions.
- **Component Architecture**: Splits table, table row, details dialog, add dialog into separate files, aligning with the doc's "Component Architecture" section for maintainability.

---

## Future Enhancements

### Filtering & Sorting
- Add UI controls to filter tasks by status, due date, or search keywords.
- Integrate table-based or server-based sorting (by priority, effort, or date).

### Inline Editing
- Edit titles or notes directly in the row, further reducing the need for a details dialog.

### Pagination
- For users with very large task sets, a paginated or virtualized table might be necessary.
--------------------------------------------------------------------------------
<File: docs/project_structure.md>
# Project Tree

```text
life-manager/
 docs/
    design_document.md         # Complete system design document
    project_structure.md       # This file - explains the project organization
    task_plan.md              # Development tasks and timeline

 backend/
    app.py                    # Routes and business logic
    cosmos_db.py             # Database operations
    testing.py               # Test data generation and cleanup
    requirements.txt
    .env

 frontend/
    index.html
    package.json
    vite.config.ts
    tsconfig.json
    tsconfig.app.json        # App-specific TypeScript config
    tsconfig.node.json       # Node-specific TypeScript config
    tailwind.config.js
    postcss.config.js
    eslint.config.js         # ESLint configuration
    components.json          # shadcn/ui component configuration
   
    src/
       main.tsx            # Application entry point
       App.tsx            # Root component and routing
      
       components/
          animations/    # CSS animations
             StatusCheckAnimation.css
         
          layouts/      # Layout components
             AppLayout.tsx
             Sidebar.tsx
             TopPanel.tsx
         
          ui/           # shadcn/ui components
             button.tsx
             card.tsx
             checkbox.tsx
             dialog.tsx
             input.tsx
             select.tsx
             separator.tsx
             skeleton.tsx
             table.tsx
         
          task/        # Task-specific components
              TaskCard.tsx     # Compact, draggable version
              TaskDetails.tsx  # Detailed task view dialog
              TaskTable.tsx    # Table container & sorting
              TaskTableRow.tsx # Full task info in tabular format
      
       pages/
          HomePage.tsx
          WeeklyPlanPage.tsx    # Uses TaskCard for calendar
          MasterListPage.tsx    # Uses TaskTable + TaskTableRow
      
       state/
          slices/
             taskSlice.ts     # Task state and reducers
             syncSlice.ts     # Sync state and reducers
          logger.ts            # Logging middleware and utilities
          syncEngine.ts        # Store setup + sync orchestration
      
       utils/
          api.ts              # API client
          displayMappings.ts  # UI display configurations
          types.ts            # TypeScript interfaces
          utils.ts            # Utility functions
      
       styles/
           globals.css         # Global styles and Tailwind imports
   
    public/
        assets/

 README.md
 .gitignore
```

# Frontend Hierarchy & Styling Architecture

## Core Style Configuration

### 1. Type Definitions (`src/utils/types.ts`)
- TypeScript interfaces and type definitions for:
  - Task interfaces
  - Status types
  - Recurrence types
  - State interfaces
  - Common type definitions

### 2. Display Mappings (`src/utils/displayMappings.ts`)
- Status colors and display text
- Priority range definitions and colors
- Effort level display configurations
- Recurrence display formatting
- All UI-related constants and helper functions
- Color definitions for statuses, priorities, etc.

### 3. Theme Configuration (`tailwind.config.js`)
- Core design tokens:
  - Base color palette
  - Typography settings
  - Spacing scales
  - Border radius values
  - Dark/light mode variables

### 4. Global Styles (`src/styles/globals.css`)
- Tailwind imports
- CSS variables
- Dark/light mode schemes
- Base element styles

### 5. UI Components (`src/components/ui/`)
- shadcn/ui base components
- Consistent styling patterns
- Theme token usage

## Component Hierarchy

### Root Component (`App.tsx`)
- Redux Provider configuration
- Router implementation
- AppLayout wrapper

### Layout Components

#### `AppLayout.tsx` (`src/components/layouts/`)
- Main layout wrapper
- Core page structure
- Sidebar state management
- Responsive layout handling
- TopPanel and Sidebar integration

#### `TopPanel.tsx` (`src/components/layouts/`)
- Application header
- Sync status display
- Settings controls
- Authentication controls

#### `Sidebar.tsx` (`src/components/layouts/`)
- Navigation menu
- Collapsible functionality
- Route management
- Active state handling

### Content Pages (`src/pages/`)
- HomePage.tsx
- WeeklyPlanPage.tsx
- MasterListPage.tsx

### Task Components (`src/components/task/`)

#### `TaskTable.tsx`
- Task list container
- Table structure
- Column management

#### `TaskTableRow.tsx`
- Individual task display
- Status management
- Priority display
- Action handlers

#### `TaskCard.tsx`
- Compact task display
- Drag-and-drop support
- Status indicators

#### `TaskDetails.tsx`
- Full task information
- Edit capabilities
- Modal dialog

### Animation Components (`src/components/animations/`)
- StatusCheckAnimation.css
- Task status transitions
- UI feedback animations



## Weekly Plan

Current Implementation Structure

Page Level (WeeklyPlanPage.tsx):


Manages selected week dates using useState
Fetches all tasks from Redux
Splits them into unscheduled vs scheduled tasks
Handles week navigation
Renders the main layout with UnscheduledTasksSidebar and WeeklyCalendar


Calendar Level (WeeklyCalendar.tsx):


Takes weekDates and tasks as props
Maps over the 7 days of the week
Uses getTasksForDate to filter tasks for each day
Renders the column headers and DayColumn components


Day Column Level (DayColumn.tsx):


Handles drag and drop functionality
Updates task.scheduledDate when tasks are dropped
Renders TaskCard components for each task assigned to that day

--------------------------------------------------------------------------------
<File: docs/task_plan.md>
# Task Plan

1. Backend 
   - [x] Validate that app.py adheres to the design document and everything is implemented correctly

2. Frontend Setup 
   - [x] Create a React Vite app with TypeScript named 'frontend'
   - [x] Install packages necessary to adhere to design doc
   - [x] Set up initial configuration (TypeScript, Tailwind, shadcn/ui)
   - [x] Create scaffolding for the frontend:
       [x] Set up Redux store structure (tasks and sync slices)
       [x] Set up API client and sync engine
       [x] Create base layout components:
           [x] Sidebar component with navigation
           [x] Top panel with sync status

3. Core Pages 
   - [ ] HomePage.tsx (scaffolded)
   - [ ] WeeklyPlanPage.tsx  (scaffolded)
   - [x] MasterListPage.tsx (implemented with TaskTable)

4. Task Components 
   - [x] TaskTable.tsx (complete with sorting and display)
   - [x] TaskTableRow.tsx (complete with actions and status updates)
   - [x] TaskDetails.tsx (dialog for viewing task details)
   - [x] TaskCard.tsx (basic structure)


5. Add Task Creation Flow
   - [ ] Create AddTaskDialog Component
       - [ ] Create basic dialog structure using shadcn Dialog
       - [ ] Add form fields for required task properties:
           - [ ] Title (required)
           - [ ] Priority (optional)
           - [ ] Effort (optional)
           - [ ] Due Date (optional)
           - [ ] Notes (optional)
       - [ ] Add form fields for recurrence:
           - [ ] Is Recurring checkbox
           - [ ] Frequency select (daily, weekly, monthly, yearly)
           - [ ] Interval input
           - [ ] Additional fields based on frequency

   
   - [ ] Implement Task Creation in Redux
       - [ ] Add createTask action to taskSlice
       - [ ] Update syncEngine to handle task creation
       - [ ] Ensure task creation adheres to core design strategy of optimistic updates, immediate feedback, and debouncing syncs to the backend via syncEngine

   - [ ] Add Task Creation Button
       - [ ] Add action button in MasterListPage


6. Task Recurrence Logic
   - [ ] Update Task Completion Flow
       - [ ] Create utility function to calculate next due date based on recurrence rule
       - [ ] Add completion record to history when marking complete
       - [ ] Add logic to reset recurring tasks:
           - [ ] Status back to notStarted
           - [ ] Update due date based on recurrence rule

   
   - [ ] Add Recurrence Preview
       - [ ] Show next occurrence date in TaskDetails
       - [ ] Add visual indicator for recurring tasks in table
       - [ ] Add tooltip showing recurrence pattern


1. Add "Add Task" functionality
    -  Create AddTaskDialog component
    -  Implement task creation flow in Redux
    -  Add create task API integration (/sync)
    -  Validate task creation flow adheres to core design strategy

2. Core Functionality 
    - Add recurrence logic -> when a task with a recurrence is marked complete, reset the status to not started and update the due date based on the recurrence. Add a record of the completion to the completion_history field. 
    - Add the ability to edit task details (Due Date, Notes, Title) 

3. Create collapsable filter and sort scaffolding 
--------------------------------------------------------------------------------
<File: docs/weekly_plan.md>
# Weekly Plan Page Documentation

## Overview
The Weekly Plan Page provides a 7-day calendar-style interface for scheduling and managing tasks. It leverages the same core Task model and optimistic Redux architecture used in the rest of the application. Users can see at a glance which tasks are planned for each day of the week, drag unscheduled tasks onto specific days, and toggle task statuses directly within the weekly view.

## Core Concepts

### Single Source of Truth in Redux
- All tasks are stored in Redux (via the tasks slice)
- The Weekly Plan uses scheduledDate on each Task to determine whether it appears on a certain day (e.g., if scheduledDate === "2025-04-05", it shows up on April 5)

### Optimistic Updates & Debounced Sync
- When a user drags a task to a day, the UI immediately sets scheduledDate in Redux
- A background sync call (syncChanges('drag', ...)) persists the change to the backend
- If the user reloads or navigates away, the updated scheduledDate ensures the task reappears on that date

### Same Status-Toggling Logic as Master List
- Tasks can be marked notStarted  workingOnIt  complete using a simple click cycle
- If a recurring task is marked complete, the same recurrence reset logic triggers. The difference is purely visual: the Weekly Plan fades out the completed task after the "green check" animation (and possibly resets dueDate or scheduledDate if it's recurring)

## Goals & Requirements

### Visual Scheduling
- Display a seven-day grid representing the selected week
- Let users drag tasks from an "Unscheduled" list (or from one day to another) to set or change scheduledDate

### Status Management
- Provide the same toggle logic used in the Master List: a click cycles from notStarted to workingOnIt to complete
- Trigger the same optimistic updates and toast notifications, with an additional fade-out animation on completion

### No Extra API Calls for Navigation
- The Weekly Plan only depends on data already fetched and stored in Redux via /api/v1/user-data
- Navigating to previous or next week adjusts which scheduledDate range is displayed, but no new data fetch is required

### Minimal Error Handling
- If a sync call fails, the top panel's sync indicator shows "sync error," but we do not implement automatic reverts or advanced retry logic

## Page Layout

```
+----------------------------------------------------------------------------------+
|  [Weekly Plan Header]  (e.g. "Mar 31, 2025 - Apr 6, 2025")   [Prev | Next]       |
+-----------------------------+----------------------------------------------------+
| Unscheduled Tasks (sidebar) |   7-Day Grid (Mon | Tue | Wed | Thu | Fri | Sat | Sun)
|  - tasks without            |     Each day: tasks with scheduledDate == that day
|    scheduledDate            |     Drag-and-drop to change day or to/from sidebar
+-----------------------------+----------------------------------------------------+
```

### Unscheduled Tasks
- Tasks with no scheduledDate (null/undefined) appear here
- Support drag from this list onto any day column in the grid
- On drop, Redux updates the task's scheduledDate, followed by an automatic background sync (changeType: 'drag')

### 7-Day Grid
- Each column corresponds to a date within the selected week
- Tasks for that date appear in a vertical list (a "day column")
- Dragging a task from one day to another updates its scheduledDate

### Weekly Plan Header
- Shows the currently selected week range
- "Prev" and "Next" buttons adjust a local or Redux-based selectedWeek state
- Since all tasks live in Redux, changing weeks is just a matter of filtering tasks by date

## Key Interactions

### Scheduling a Task
1. Drag a task from the Unscheduled list onto a day's column
2. The app immediately sets task.scheduledDate = <that day> in Redux
3. syncChanges('drag', ...) is called to push the update to the backend

### Rescheduling Between Days
- Drag a task from one day column to another
- Same Redux update + background sync pattern

### Status Toggle
- Click on the task's status bubble or button to cycle: notStarted  workingOnIt  complete
- If complete, handle the same recurring reset logic as on the Master List (e.g., add an entry to completionHistory, set status back to notStarted, etc.), plus a fade-out animation in the Weekly Plan's UI

### Animations & Toast
- On complete, show a brief checkmark toast (and possibly a separate fade-out if you're removing the task from the day column)
- If recurring, also reset the task's scheduledDate or dueDate in Redux, and dispatch a sync
- If non-recurring, leave the task's scheduledDate but show it as complete

## Implementation Details

### Data Model: Task

```typescript
interface Task {
  id: string;
  userId: string;
  type: 'task';
  title: string;
  status: 'notStarted' | 'workingOnIt' | 'complete';
  priority: number;
  dynamicPriority: number;
  effort?: number;
  notes?: string;
  dueDate?: string;
  scheduledDate?: string; // <-- used extensively on Weekly Plan
  createdAt: string;
  updatedAt: string;
  completionHistory: CompletionEntry[];
  recurrence?: {
    isRecurring: boolean;
    rule?: RecurrenceRule;
  };
  tags?: string[];
}
```

**Key Field**: `scheduledDate` determines whether a task appears in a given day column or in the Unscheduled list (null/undefined means unscheduled).

### Redux Integration

#### Selectors
- `selectUnscheduledTasks`: filters tasks where scheduledDate is null/undefined
- `selectTasksForDate(dateString)`: filters tasks whose scheduledDate matches the day

#### Actions & Slices
- The same taskSlice from the Master List handles creation, updates, and deletions
- Setting scheduledDate is handled by a standard updateTask action:

```typescript
store.dispatch(updateTask({ id: task.id, changes: { scheduledDate: '2025-04-05' } }));
```

The syncEngine.ts handles the debounced calls (syncChanges('drag', ...), syncChanges('status', ...), etc.).

### Components

#### WeeklyPlanPage.tsx
- High-Level Container: Renders a WeeklyPlanHeader, an UnscheduledTasksSidebar, and a WeeklyCalendar
- Maintains or retrieves selectedWeek from Redux or local state

#### WeeklyPlanHeader
- Displays the currently selected week range
- Buttons for "previous"/"next" week adjust selectedWeek
- Possibly highlights the current week or day

#### UnscheduledTasksSidebar
- Lists tasks where scheduledDate is not set
- Each task is shown as a small card or row (similar to the Master List's TaskCard) with drag handles
- Initiates a drag event that references the task's ID, letting you drop it onto a day

#### WeeklyCalendar
- A 7-day row (or column) of DayColumn components (e.g., [Mon, Tue, Wed, Thu, Fri, Sat, Sun])
- Each DayColumn uses selectTasksForDate to render relevant tasks
- Each day's tasks are also draggable. You can drag from one day to another. On drop, scheduledDate changes

#### DayColumn
- Accepts a date prop (e.g., '2025-04-05')
- Renders each Task in a stack or list
- Dropping tasks triggers updateTask({ scheduledDate: date })

#### TaskCard (or "TaskRow")
- Reused or adapted from your Master List
- Has the same status toggle logic
- Possibly has an additional fade-out animation on complete if you want to remove completed tasks from the view

## Example Workflow

### User Drags Unscheduled Task
1. The "Unscheduled" sidebar has a task with scheduledDate = undefined
2. The user drags it onto Wednesday (e.g., "2025-04-02")
3. Redux immediately updates task.scheduledDate = '2025-04-02', UI re-renders to show the task under Wednesday
4. syncChanges('drag', [ { type: 'task', operation: 'update', id: task.id, data: { scheduledDate: '2025-04-02' } } ]) is dispatched

### User Marks Task Complete
1. The user clicks on the task's status bubble
2. It cycles from workingOnIt to complete
3. The system shows a green check toast
4. If the task is recurring, a short delay triggers reset logic (e.g., sets status to notStarted, calculates next dueDate, clears scheduledDate, and logs the completion). The UI animates a fade-out from the calendar
5. Another sync call updates the server with these changes

## Future Enhancements

### Drag Reversion / Retry
- Currently not implemented. If a sync call fails, the user sees an error indicator, but no automatic revert occurs

### Filter or Group by Priority
- The Weekly Plan could optionally show higher-priority tasks in a highlight color or separate group

### Extended Recurrence Logic
- You may choose to auto-set the scheduledDate for upcoming occurrences if a task is recurring. Currently, only the completion logic is handled

### Inline Edits
- Let users rename tasks or change notes directly from the weekly calendar, reusing your existing syncChanges('text', ...) approach

## Summary
- The Weekly Plan Page is a specialized interface built atop the same Task model and Redux slices used by the Master List
- Scheduled tasks appear in date columns; unscheduled tasks appear in a sidebar
- Dragging updates scheduledDate, and status toggling uses the same cycle logic from your Master List, with an added fade-out animation for completed tasks
- All changes are optimistic, with a debounced sync operation to persist data in the backend
- Advanced failure recovery (revert/retry) is intentionally out of scope for now, but the page still conforms to the core design patterns of your app (Redux, single container in CosmosDB, and consistent case conversions on the backend)
--------------------------------------------------------------------------------
<File: frontend/components.json>
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": false,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.js",
    "css": "src/index.css",
    "baseColor": "gray",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}
--------------------------------------------------------------------------------
<File: frontend/eslint.config.js>
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'

export default tseslint.config(
  { ignores: ['dist'] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ['**/*.{ts,tsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
)

--------------------------------------------------------------------------------
<File: frontend/index.html>
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React + TS</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

--------------------------------------------------------------------------------
<File: frontend/package.json>
{
  "name": "frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@radix-ui/react-checkbox": "^1.1.3",
    "@radix-ui/react-dialog": "^1.1.4",
    "@radix-ui/react-label": "^2.1.1",
    "@radix-ui/react-popover": "^1.1.4",
    "@radix-ui/react-select": "^2.1.4",
    "@radix-ui/react-separator": "^1.1.1",
    "@radix-ui/react-slot": "^1.1.1",
    "@radix-ui/react-toast": "^1.2.4",
    "@reduxjs/toolkit": "^2.5.0",
    "@types/lodash": "^4.17.14",
    "@types/react-router-dom": "^5.3.3",
    "@types/uuid": "^10.0.0",
    "autoprefixer": "^10.4.20",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "date-fns": "^4.1.0",
    "deep-object-diff": "^1.1.9",
    "lodash": "^4.17.21",
    "lucide-react": "^0.471.0",
    "postcss": "^8.4.49",
    "react": "^18.3.1",
    "react-beautiful-dnd": "^13.1.1",
    "react-day-picker": "^8.10.1",
    "react-dom": "^18.3.1",
    "react-redux": "^9.2.0",
    "react-router-dom": "^7.1.1",
    "tailwind-merge": "^2.6.0",
    "tailwindcss": "^3.4.17",
    "uuid": "^11.0.5"
  },
  "devDependencies": {
    "@eslint/js": "^9.17.0",
    "@types/node": "^22.10.5",
    "@types/react": "^18.3.18",
    "@types/react-beautiful-dnd": "^13.1.8",
    "@types/react-dom": "^18.3.5",
    "@vitejs/plugin-react": "^4.3.4",
    "eslint": "^9.17.0",
    "eslint-plugin-react-hooks": "^5.0.0",
    "eslint-plugin-react-refresh": "^0.4.16",
    "globals": "^15.14.0",
    "tailwindcss-animate": "^1.0.7",
    "typescript": "~5.6.2",
    "typescript-eslint": "^8.18.2",
    "vite": "^6.0.5"
  }
}

--------------------------------------------------------------------------------
<File: frontend/postcss.config.js>
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

--------------------------------------------------------------------------------
<File: frontend/README.md>
# React + TypeScript + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react/README.md) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## Expanding the ESLint configuration

If you are developing a production application, we recommend updating the configuration to enable type aware lint rules:

- Configure the top-level `parserOptions` property like this:

```js
export default tseslint.config({
  languageOptions: {
    // other options...
    parserOptions: {
      project: ['./tsconfig.node.json', './tsconfig.app.json'],
      tsconfigRootDir: import.meta.dirname,
    },
  },
})
```

- Replace `tseslint.configs.recommended` to `tseslint.configs.recommendedTypeChecked` or `tseslint.configs.strictTypeChecked`
- Optionally add `...tseslint.configs.stylisticTypeChecked`
- Install [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) and update the config:

```js
// eslint.config.js
import react from 'eslint-plugin-react'

export default tseslint.config({
  // Set the react version
  settings: { react: { version: '18.3' } },
  plugins: {
    // Add the react plugin
    react,
  },
  rules: {
    // other rules...
    // Enable its recommended rules
    ...react.configs.recommended.rules,
    ...react.configs['jsx-runtime'].rules,
  },
})
```

--------------------------------------------------------------------------------
<File: frontend/src/App.css>
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}

--------------------------------------------------------------------------------
<File: frontend/src/App.tsx>
// src/App.tsx
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import { Provider } from 'react-redux';
import { store } from './state/syncEngine';
import { Toaster } from "@/components/ui/toaster";
import "@/components/animations/animations.css";

// Pages
import HomePage from './pages/HomePage';
import WeeklyPlanPage from './pages/WeeklyPlanPage';
import MasterListPage from './pages/MasterListPage';

// Layout components
import { AppLayout } from './components/layouts/AppLayout';

function App() {
  return (
    <Provider store={store}>
      <Router>
        <Routes>
          <Route element={<AppLayout />}>
            <Route path="/" element={<HomePage />} />
            <Route path="/weekly-plan" element={<WeeklyPlanPage />} />
            <Route path="/master-list" element={<MasterListPage />} />
          </Route>
        </Routes>
        <Toaster />
      </Router>
    </Provider>
  );
}

export default App;
--------------------------------------------------------------------------------
<File: frontend/src/components/animations/animations.css>
/* src/components/animations/animations.css */

/* Status bubble and checkmark animation */
.status-bubble {
  position: relative;
}

.status-check-icon {
  transform: scale(0);
  opacity: 0;
  transition: transform 500ms ease, opacity 500ms ease;
}

.animate-check .status-check-icon {
  transform: scale(1);
  opacity: 1;
}

/* Completion animation */
@keyframes completionFlash {
  0% {
    background-color: transparent;
  }
  50% {
    background-color: rgba(34, 197, 94, 0.1); /* Light green flash */
  }
  100% {
    background-color: transparent;
  }
}

.animate-completion {
  animation: completionFlash 1s ease-out forwards;
}

/* Task resetting animation */
.task-resetting {
  opacity: 0.5;
  transition: opacity 300ms ease-in-out;
}

/* Fade out animation */
.fade-out {
  opacity: 0;
  transform: scale(0.95);
  transition: opacity 500ms ease-out, transform 500ms ease-out;
}
--------------------------------------------------------------------------------
<File: frontend/src/components/layouts/AppLayout.tsx>
import { useEffect, useState } from 'react';
import { Outlet } from 'react-router-dom';
import { initializeData } from '../../state/syncEngine';
import { Sidebar } from './Sidebar';
import { TopPanel } from './TopPanel';

export function AppLayout() {
  const [isCollapsed, setIsCollapsed] = useState(false);

  useEffect(() => {
    // Initialize data when the app loads
    initializeData();
  }, []);

  return (
    <div className="flex min-h-screen">
      {/* Sidebar */}
      <Sidebar 
        isCollapsed={isCollapsed} 
        onCollapsedChange={setIsCollapsed} 
      />

      {/* Main content area with TopPanel */}
      <div className="flex flex-col flex-1">
        <TopPanel />
        <main className="flex-1 p-4 md:p-8 overflow-y-auto">
          <Outlet />
        </main>
      </div>
    </div>
  );
}

--------------------------------------------------------------------------------
<File: frontend/src/components/layouts/Sidebar.tsx>
import { NavLink } from 'react-router-dom';
import { Home, Calendar, List, ChevronLeft, ChevronRight } from 'lucide-react';
import { cn } from '../../utils/utils';
import { Button } from '../ui/button';

interface SidebarProps {
  isCollapsed: boolean;
  onCollapsedChange: (collapsed: boolean) => void;
}

export const Sidebar = ({ isCollapsed, onCollapsedChange }: SidebarProps) => {
  const navItems = [
    { path: '/', label: 'Home', icon: Home },
    { path: '/weekly-plan', label: 'Weekly Plan', icon: Calendar },
    { path: '/master-list', label: 'Master List', icon: List },
  ];

  return (
    <div
      className={cn(
        'bg-card border-r transition-all duration-300',
        isCollapsed ? 'w-16' : 'w-64'
      )}
    >
      <div className="flex flex-col h-full">
        <div className="p-4 flex items-center justify-between">
          {!isCollapsed && (
            <span className="text-xl font-bold">Life Manager</span>
          )}
          <Button
            variant="default"
            size="icon"
            onClick={() => onCollapsedChange(!isCollapsed)}
          >
            {isCollapsed ? <ChevronRight size={16} /> : <ChevronLeft size={16} />}
          </Button>
        </div>

        <nav className="flex-1 px-2 py-4">
          {navItems.map(({ path, label, icon: Icon }) => (
            <NavLink
              key={path}
              to={path}
              className={({ isActive }) =>
                cn(
                  'flex items-center px-4 py-2 my-1 rounded-md transition-colors',
                  'hover:bg-accent hover:text-accent-foreground',
                  isActive ? 'bg-accent text-accent-foreground' : 'text-muted-foreground',
                  isCollapsed && 'justify-center'
                )
              }
            >
              <Icon size={20} />
              {!isCollapsed && <span className="ml-3">{label}</span>}
            </NavLink>
          ))}
        </nav>
      </div>
    </div>
  );
}; 
--------------------------------------------------------------------------------
<File: frontend/src/components/layouts/TopPanel.tsx>
import { useSelector } from 'react-redux';
import { Check, Loader2, AlertCircle, Settings, LogIn } from 'lucide-react';
import { RootState } from '../../state/syncEngine';
import { Button } from '../ui/button';

export function TopPanel() {
    const syncStatus = useSelector((state: RootState) => state.sync.status);
    const lastSynced = useSelector((state: RootState) => state.sync.lastSynced);

    const renderSyncStatus = () => {
        switch (syncStatus) {
            case 'syncing':
                return (
                    <div className="flex items-center">
                        <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                        <span>Syncing...</span>
                    </div>
                );
            case 'error':
                return (
                    <div className="flex items-center text-destructive">
                        <AlertCircle className="mr-2 h-4 w-4" />
                        <span>Sync error</span>
                    </div>
                );
            case 'idle':
                return (
                    <div className="flex items-center">
                        <Check className="mr-2 h-4 w-4 text-emerald-500" />
                        <span className="text-foreground whitespace-nowrap">
                            {lastSynced
                                ? `Last saved at ${new Date(lastSynced).toLocaleTimeString()}`
                                : 'All changes saved'}
                        </span>
                    </div>
                );
        }
    };

    return (
        <header className="sticky top-0 z-50 w-full border-b bg-background/95 backdrop-blur">
            <div className="mx-8">
                <div className="flex h-14 items-center justify-end">
                    {/* Right Side Controls */}
                    <div className="flex items-center gap-6">
                        {/* Sync Status */}
                        <div className="flex-shrink-0">
                            {renderSyncStatus()}
                        </div>

                        {/* Settings Button - Inactive for now */}
                        <Button
                            variant="default"
                            size="sm"
                            aria-label="Settings (coming soon)"
                            title="Settings"
                        >
                            <Settings className="h-4 w-4" />
                        </Button>

                        {/* Login/Logout Button - Inactive for now */}
                        <Button
                            variant="default"
                            size="sm"
                            aria-label="Login (coming soon)"
                            title="Logout"
                        >
                            <LogIn className="h-4 w-4" />
                        </Button>
                    </div>
                </div>
            </div>
        </header>
    );
} 
--------------------------------------------------------------------------------
<File: frontend/src/components/task/AddTaskDialog.tsx>
import React, { useState } from 'react';
import { useDispatch } from 'react-redux';
import { v4 as uuidv4 } from 'uuid';
import { format } from "date-fns";
import { Calendar as CalendarIcon } from "lucide-react";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import { Calendar } from "@/components/ui/calendar";
import { Checkbox } from '@/components/ui/checkbox';
import { Task, RecurrenceFrequency } from '@/utils/types';
import { addTask } from '@/state/slices/taskSlice';
import { syncChanges } from '@/state/syncEngine';
import { EFFORT_DISPLAY } from '@/utils/displayMappings';
import { cn } from '@/utils/utils';

interface AddTaskDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
}

export function AddTaskDialog({ open, onOpenChange }: AddTaskDialogProps) {
  const dispatch = useDispatch();
  
  // Form state
  const [title, setTitle] = useState('');
  const [priority, setPriority] = useState<number>(40); // Default to Medium
  const [effort, setEffort] = useState<number>(3); // Default to Medium
  const [dueDate, setDueDate] = useState<Date>();
  const [notes, setNotes] = useState('');
  const [isRecurring, setIsRecurring] = useState(false);
  const [recurrenceFrequency, setRecurrenceFrequency] = useState<RecurrenceFrequency>('daily');
  const [recurrenceInterval, setRecurrenceInterval] = useState(1);

  // Form validation state
  const [errors, setErrors] = useState<Record<string, string>>({});

  const validateForm = (): boolean => {
    const newErrors: Record<string, string> = {};

    if (!title.trim()) {
      newErrors.title = 'Title is required';
    }

    if (isRecurring && recurrenceInterval < 1) {
      newErrors.recurrenceInterval = 'Interval must be at least 1';
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();

    if (!validateForm()) {
      return;
    }

    const now = new Date().toISOString();
    const newTask: Task = {
      id: uuidv4(),
      userId: 'test-user', // TODO: Get from auth context
      type: 'task',
      title: title.trim(),
      status: 'notStarted',
      priority: priority,
      dynamicPriority: priority, // Initially same as priority
      effort: effort,
      notes: notes.trim() || undefined,
      dueDate: dueDate?.toISOString(),
      scheduledDate: undefined,
      createdAt: now,
      updatedAt: now,
      completionHistory: [],
      recurrence: isRecurring
        ? {
            isRecurring: true,
            rule: {
              frequency: recurrenceFrequency,
              interval: recurrenceInterval,
            },
          }
        : undefined,
    };

    // Dispatch to Redux (optimistic update)
    dispatch(addTask(newTask));

    // Sync to backend
    syncChanges('text', [
      {
        type: 'task',
        operation: 'create',
        id: newTask.id,
        data: newTask,
      },
    ]);

    // Reset form and close dialog
    resetForm();
    onOpenChange(false);
  };

  const resetForm = () => {
    setTitle('');
    setPriority(40);
    setEffort(3);
    setDueDate(undefined);
    setNotes('');
    setIsRecurring(false);
    setRecurrenceFrequency('daily');
    setRecurrenceInterval(1);
    setErrors({});
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-[425px]">
        <DialogHeader>
          <DialogTitle>Add New Task</DialogTitle>
          <DialogDescription>
            Create a new task. Add title and any additional details needed.
          </DialogDescription>
        </DialogHeader>

        <form onSubmit={handleSubmit} className="space-y-6">
          {/* Title Input */}
          <div className="space-y-2">
            <Label htmlFor="title">
              Title <span className="text-destructive">*</span>
            </Label>
            <Input
              id="title"
              value={title}
              onChange={(e) => setTitle(e.target.value)}
              className={errors.title ? 'border-destructive' : ''}
            />
            {errors.title && (
              <p className="text-sm text-destructive">{errors.title}</p>
            )}
          </div>

          {/* Priority Select */}
          <div className="space-y-2">
            <Label htmlFor="priority">Priority</Label>
            <Select
              value={priority.toString()}
              onValueChange={(value) => setPriority(parseInt(value))}
            >
              <SelectTrigger id="priority">
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                <SelectGroup>
                  <SelectLabel>Priority Level</SelectLabel>
                  <SelectItem value="80">Very High</SelectItem>
                  <SelectItem value="60">High</SelectItem>
                  <SelectItem value="40">Medium</SelectItem>
                  <SelectItem value="20">Low</SelectItem>
                  <SelectItem value="0">Very Low</SelectItem>
                </SelectGroup>
              </SelectContent>
            </Select>
          </div>

          {/* Effort Select */}
          <div className="space-y-2">
            <Label htmlFor="effort">Effort</Label>
            <Select
              value={effort.toString()}
              onValueChange={(value) => setEffort(parseInt(value))}
            >
              <SelectTrigger id="effort">
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                <SelectGroup>
                  <SelectLabel>Effort Level</SelectLabel>
                  {Object.entries(EFFORT_DISPLAY).map(([value, { label }]) => (
                    <SelectItem key={value} value={value}>
                      {label}
                    </SelectItem>
                  ))}
                </SelectGroup>
              </SelectContent>
            </Select>
          </div>

          {/* Due Date Input */}
          <div className="space-y-2">
            <Label htmlFor="dueDate">Due Date</Label>
            <Popover>
              <PopoverTrigger asChild>
                <Button
                  variant={"outline"}
                  className={cn(
                    "w-full justify-start text-left font-normal",
                    !dueDate && "text-muted-foreground"
                  )}
                >
                  <CalendarIcon className="mr-2 h-4 w-4" />
                  {dueDate ? format(dueDate, "PPP") : "Pick a date"}
                </Button>
              </PopoverTrigger>
              <PopoverContent className="w-auto p-0" align="start">
                <Calendar
                  mode="single"
                  selected={dueDate}
                  onSelect={setDueDate}
                  initialFocus
                />
              </PopoverContent>
            </Popover>
          </div>

          {/* Notes Input */}
          <div className="space-y-2">
            <Label htmlFor="notes">Notes</Label>
            <Input
              id="notes"
              value={notes}
              onChange={(e) => setNotes(e.target.value)}
            />
          </div>

          {/* Recurrence Section */}
          <div className="space-y-4">
            <div className="flex items-center space-x-2">
              <Checkbox
                id="isRecurring"
                checked={isRecurring}
                onCheckedChange={(checked) => setIsRecurring(!!checked)}
              />
              <Label htmlFor="isRecurring">Recurring Task</Label>
            </div>

            {isRecurring && (
              <div className="space-y-4 pl-6">
                <div className="space-y-2">
                  <Label htmlFor="recurrenceFrequency">Frequency</Label>
                  <Select
                    value={recurrenceFrequency}
                    onValueChange={(value) => 
                      setRecurrenceFrequency(value as RecurrenceFrequency)
                    }
                  >
                    <SelectTrigger id="recurrenceFrequency">
                      <SelectValue />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectGroup>
                        <SelectItem value="daily">Daily</SelectItem>
                        <SelectItem value="weekly">Weekly</SelectItem>
                        <SelectItem value="monthly">Monthly</SelectItem>
                        <SelectItem value="yearly">Yearly</SelectItem>
                      </SelectGroup>
                    </SelectContent>
                  </Select>
                </div>

                <div className="space-y-2">
                  <Label htmlFor="recurrenceInterval">
                    Repeat Every
                  </Label>
                  <Input
                    id="recurrenceInterval"
                    type="number"
                    min="1"
                    value={recurrenceInterval}
                    onChange={(e) => 
                      setRecurrenceInterval(parseInt(e.target.value) || 1)
                    }
                    className={errors.recurrenceInterval ? 'border-destructive' : ''}
                  />
                  {errors.recurrenceInterval && (
                    <p className="text-sm text-destructive">
                      {errors.recurrenceInterval}
                    </p>
                  )}
                </div>
              </div>
            )}
          </div>

          {/* Submit Button */}
          <div className="flex justify-end">
            <Button type="submit" variant="default">
              Create Task
            </Button>
          </div>
        </form>
      </DialogContent>
    </Dialog>
  );
}
--------------------------------------------------------------------------------
<File: frontend/src/components/task/Recurrence.tsx>
// src/components/task/Recurrence.ts

import { addDays, addWeeks, addMonths, addYears, isBefore } from 'date-fns';
import { RecurrenceRule, CompletionEntry } from '@/utils/types';

/**
 * Calculate the next due date based on a recurrence rule
 * Now using the current date as the base for calculations
 */
export function calculateNextDueDate(
  rule: RecurrenceRule
): string {
  // Always use current date as the base for next occurrence
  const now = new Date();
  const baseDate = new Date(now);
  
  // Calculate next date based on frequency and interval
  let nextDate: Date;
  switch (rule.frequency) {
    case 'daily':
      nextDate = addDays(baseDate, rule.interval);
      break;
      
    case 'weekly':
      // First, add the weeks
      nextDate = addWeeks(baseDate, rule.interval);
      
      // If specific days of week are specified
      if (rule.daysOfWeek?.length) {
        // Find the next allowed day of week after our calculated date
        const currentDay = nextDate.getDay();
        let daysUntilNext = 7; // Maximum days we might need to add
        
        for (const allowedDay of rule.daysOfWeek) {
          const diff = allowedDay - currentDay;
          const adjustedDiff = diff <= 0 ? diff + 7 : diff;
          if (adjustedDiff < daysUntilNext) {
            daysUntilNext = adjustedDiff;
          }
        }
        
        nextDate = addDays(nextDate, daysUntilNext);
      }
      break;
      
    case 'monthly':
      nextDate = addMonths(baseDate, rule.interval);
      
      // If a specific day of month is specified
      if (rule.dayOfMonth) {
        // Get the last day of the target month
        const lastDay = new Date(
          nextDate.getFullYear(),
          nextDate.getMonth() + 1,
          0
        ).getDate();
        
        // Use the specified day, but don't exceed the last day of the month
        const targetDay = Math.min(rule.dayOfMonth, lastDay);
        nextDate.setDate(targetDay);
        
        // If the calculated date is before current date, move to next month
        if (isBefore(nextDate, now)) {
          nextDate = addMonths(nextDate, 1);
        }
      }
      break;
      
    case 'yearly':
      nextDate = addYears(baseDate, rule.interval);
      break;
      
    default:
      throw new Error(`Unknown frequency: ${rule.frequency}`);
  }
  
  // Ensure we never return a date in the past
  if (isBefore(nextDate, now)) {
    switch (rule.frequency) {
      case 'daily':
        nextDate = addDays(now, rule.interval);
        break;
      case 'weekly':
        nextDate = addWeeks(now, rule.interval);
        break;
      case 'monthly':
        nextDate = addMonths(now, rule.interval);
        break;
      case 'yearly':
        nextDate = addYears(now, rule.interval);
        break;
    }
  }
  
  return nextDate.toISOString();
}

/**
 * Create a completion record for a task
 */
export function createCompletionRecord(
  nextDueDate?: string,
  notes?: string
): CompletionEntry {
  return {
    completedAt: new Date().toISOString(),
    nextDueDate,
    completionNotes: notes
  };
}

/**
 * Format a date for display
 */
export function formatDate(date: string | Date): string {
  if (!date) return '';
  const d = new Date(date);
  return d.toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'short',
    day: 'numeric'
  });
}

/**
 * Check if a task should be reset based on its recurrence rule
 */
export function shouldResetTask(
  task: { recurrence?: { isRecurring: boolean; rule?: RecurrenceRule } }
): boolean {
  return Boolean(
    task.recurrence?.isRecurring && 
    task.recurrence.rule &&
    task.recurrence.rule.frequency
  );
}
--------------------------------------------------------------------------------
<File: frontend/src/components/task/TaskCard.tsx>
// src/components/weekly-plan/TaskCard.tsx
import { useState } from 'react';
import { useDispatch } from 'react-redux';
import { Task } from '@/utils/types';
import { Card } from '@/components/ui/card';
import { Check, GripVertical } from 'lucide-react';
import { STATUS_DISPLAY, STATUS_COLORS } from '@/utils/displayMappings';
import { updateTask } from '@/state/slices/taskSlice';
import { syncChanges } from '@/state/syncEngine';
import { 
  calculateNextDueDate,
  createCompletionRecord,
  shouldResetTask,
} from '@/components/task/Recurrence';
import '@/components/animations/animations.css';

interface TaskCardProps {
  task: Task;
  isDraggable?: boolean;
}

const STATUS_SEQUENCE = ['notStarted', 'workingOnIt', 'complete'] as const;

const TaskCard = ({ task, isDraggable }: TaskCardProps) => {
  const dispatch = useDispatch();
  const [isDragging, setIsDragging] = useState(false);
  const [animateCheck, setAnimateCheck] = useState(false);
  const [isFadingOut, setIsFadingOut] = useState(false);

  // Handle marking a recurring task as complete
  const handleRecurringComplete = () => {
    if (!task.recurrence?.rule) return;

    // Calculate next due date and create completion record
    const nextDueDate = calculateNextDueDate(task.recurrence.rule);
    const completionRecord = createCompletionRecord(nextDueDate);
    const changes: Partial<Task> = {
      status: 'notStarted' as const,
      dueDate: nextDueDate,
      scheduledDate: nextDueDate,
      completionHistory: [...(task.completionHistory || []), completionRecord]
    };

    // Show completion state briefly
    dispatch(updateTask({
      id: task.id,
      changes: { status: 'complete' }
    }));

    // Start animations
    setAnimateCheck(true);

    // After checkmark and flash animations, start fade out
    setTimeout(() => {
      setIsFadingOut(true);
      
      // After fade out completes, update the task
      setTimeout(() => {
        dispatch(updateTask({
          id: task.id,
          changes
        }));

        syncChanges('status', [{
          type: 'task',
          operation: 'update',
          id: task.id,
          data: changes
        }]);

        // Reset animations
        setAnimateCheck(false);
        setIsFadingOut(false);
      }, 500); // Match the fade-out duration
    }, 1000); // Wait for checkmark and flash animations
  };

  // Handle status changes
  const handleStatusClick = () => {
    let nextStatus: typeof STATUS_SEQUENCE[number];

    switch (task.status) {
      case 'notStarted':
        nextStatus = 'workingOnIt';
        setAnimateCheck(false);
        break;
      case 'workingOnIt':
        nextStatus = 'complete';
        // If it's a recurring task, handle differently
        if (shouldResetTask(task)) {
          handleRecurringComplete();
          return;
        }
        // Otherwise, just show checkmark for non-recurring task
        setAnimateCheck(true);
        break;
      case 'complete':
        nextStatus = 'notStarted';
        setAnimateCheck(false);
        break;
      default:
        nextStatus = 'notStarted';
        setAnimateCheck(false);
    }

    // For non-recurring tasks being completed, add completion record
    if (nextStatus === 'complete') {
      const completionRecord = createCompletionRecord();
      const changes: Partial<Task> = {
        status: nextStatus,
        completionHistory: [...(task.completionHistory || []), completionRecord]
      };

      dispatch(updateTask({
        id: task.id,
        changes
      }));

      syncChanges('status', [{
        type: 'task',
        operation: 'update',
        id: task.id,
        data: changes
      }]);
      return;
    }

    // For all other status changes
    const changes: Partial<Task> = { status: nextStatus };
    
    dispatch(updateTask({
      id: task.id,
      changes
    }));

    syncChanges('status', [{
      type: 'task',
      operation: 'update',
      id: task.id,
      data: changes
    }]);
  };

  // Drag handlers
  const handleDragStart = (e: React.DragEvent) => {
    e.dataTransfer.setData('text/task-id', task.id);
    e.dataTransfer.effectAllowed = 'move';
    setIsDragging(true);
  };

  const handleDragEnd = () => {
    setIsDragging(false);
  };

  return (
    <Card
      draggable={isDraggable}
      onDragStart={handleDragStart}
      onDragEnd={handleDragEnd}
      className={[
        'relative flex flex-col p-3 gap-2',
        isDraggable ? 'cursor-grab active:cursor-grabbing' : '',
        isDragging ? 'opacity-50' : '',
        task.status === 'complete' ? 'animate-completion' : '',
        isFadingOut ? 'fade-out' : '',
      ].filter(Boolean).join(' ')}
    >
      {/* Header with drag handle and title */}
      <div className="flex items-center gap-2">
        {isDraggable && (
          <div className="flex-shrink-0 text-muted-foreground">
            <GripVertical className="h-4 w-4" />
          </div>
        )}
        <div className="flex-1 min-w-0">
          <div className="text-sm font-medium truncate">
            {task.title}
          </div>
        </div>
      </div>

      {/* Status Bubble */}
      <button
        onClick={handleStatusClick}
        className={[
          'inline-flex items-center justify-center w-28 h-7 px-2 rounded-full text-xs relative',
          'status-bubble',
          STATUS_COLORS[task.status] || 'bg-gray-100 text-gray-800',
          animateCheck || task.status === 'complete' ? 'animate-check' : '',
          task.status === 'complete' ? 'status-complete' : '',
        ].join(' ')}
      >
        <div className="flex items-center gap-1">
          {task.status === 'complete' && (
            <Check className="status-check-icon h-4 w-4" />
          )}
          {STATUS_DISPLAY[task.status] || task.status}
        </div>
      </button>
    </Card>
  );
};

export default TaskCard;
--------------------------------------------------------------------------------
<File: frontend/src/components/task/TaskDetails.tsx>

import { Task } from '../../utils/types';
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "../ui/dialog";

interface TaskDetailsProps {
  task: Task;
  open: boolean;
  onOpenChange: (open: boolean) => void;
}

const TaskDetails = ({ task, open, onOpenChange }: TaskDetailsProps) => {
  const formatDate = (date: string | undefined) => {
    if (!date) return '-';
    return new Date(date).toLocaleDateString();
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-2xl">
        <DialogHeader>
          <DialogTitle>{task.title}</DialogTitle>
        </DialogHeader>
        
        <div className="grid gap-4 py-4">
          <div className="grid grid-cols-4 items-center gap-4">
            <div className="font-medium">Status</div>
            <div className="col-span-3 flex items-center gap-2">
              <div className={`w-2 h-2 rounded-full ${
                task.status === 'complete' ? 'bg-green-500' :
                task.status === 'workingOnIt' ? 'bg-yellow-500' :
                'bg-gray-500'
              }`} />
              {task.status === 'notStarted' ? 'Not Started' :
               task.status === 'workingOnIt' ? 'Working on It' :
               'Complete'}
            </div>
          </div>

          <div className="grid grid-cols-4 items-center gap-4">
            <div className="font-medium">Priority</div>
            <div className="col-span-3">
              <div className={`inline-flex px-2 py-1 rounded-full text-xs ${
                task.priority >= 80 ? 'bg-red-100 text-red-800' :
                task.priority >= 60 ? 'bg-orange-100 text-orange-800' :
                task.priority >= 40 ? 'bg-yellow-100 text-yellow-800' :
                task.priority >= 20 ? 'bg-green-100 text-green-800' :
                'bg-gray-100 text-gray-800'
              }`}>
                {task.priority}
              </div>
            </div>
          </div>

          <div className="grid grid-cols-4 items-center gap-4">
            <div className="font-medium">Due Date</div>
            <div className="col-span-3">{formatDate(task.dueDate)}</div>
          </div>

          <div className="grid grid-cols-4 items-center gap-4">
            <div className="font-medium">Scheduled</div>
            <div className="col-span-3">{formatDate(task.scheduledDate)}</div>
          </div>

          {task.notes && (
            <div className="grid grid-cols-4 items-start gap-4">
              <div className="font-medium">Notes</div>
              <div className="col-span-3 whitespace-pre-wrap">{task.notes}</div>
            </div>
          )}

          {task.recurrence?.isRecurring && task.recurrence.rule && (
            <div className="grid grid-cols-4 items-start gap-4">
              <div className="font-medium">Recurrence</div>
              <div className="col-span-3">
                Every {task.recurrence.rule.interval} {task.recurrence.rule.frequency}
                {task.recurrence.rule.endDate && ` until ${formatDate(task.recurrence.rule.endDate)}`}
              </div>
            </div>
          )}

          {task.completionHistory.length > 0 && (
            <div className="grid grid-cols-4 items-start gap-4">
              <div className="font-medium">History</div>
              <div className="col-span-3">
                <div className="space-y-2">
                  {task.completionHistory.map((entry, index) => (
                    <div key={index} className="text-sm">
                      Completed on {formatDate(entry.completedAt)}
                      {entry.completionNotes && (
                        <div className="text-gray-600 ml-4">{entry.completionNotes}</div>
                      )}
                    </div>
                  ))}
                </div>
              </div>
            </div>
          )}
        </div>
      </DialogContent>
    </Dialog>
  );
};

export default TaskDetails; 
--------------------------------------------------------------------------------
<File: frontend/src/components/task/TaskTable.tsx>
// File: src/components/task/TaskTable.tsx


import { Task } from '../../utils/types'; 
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from '../ui/table';
import TaskTableRow from './TaskTableRow';

interface TaskTableProps {
  tasks: Task[];
}

const TaskTable = ({ tasks }: TaskTableProps) => {
  return (
    <div className="w-full rounded-lg border bg-card shadow-sm">
      {/* Table title area */}
      <div className="px-4 py-3 border-b bg-muted/30 rounded-t-lg">
        <h2 className="text-lg font-semibold text-foreground">Tasks</h2>
      </div>

      {/* Main table */}
      <Table className="min-w-full text-sm">
        <TableHeader>
          <TableRow className="bg-muted/20 text-muted-foreground">
            <TableHead className="py-3 px-4 font-medium">Title</TableHead>
            <TableHead className="py-3 px-4 font-medium">Status</TableHead>
            <TableHead className="py-3 px-4 font-medium">Priority</TableHead>
            <TableHead className="py-3 px-4 font-medium">Effort</TableHead>
            <TableHead className="py-3 px-4 font-medium">Due Date</TableHead>
            <TableHead className="py-3 px-4 font-medium">Recurrence</TableHead>
            <TableHead className="py-3 px-4 font-medium">Notes</TableHead>
            <TableHead className="py-3 px-4 font-medium text-right">Actions</TableHead>
          </TableRow>
        </TableHeader>

        <TableBody>
          {tasks.map((task) => (
            <TaskTableRow key={task.id} task={task} />
          ))}

          {tasks.length === 0 && (
            <TableRow>
              <TableCell
                colSpan={8}
                className="p-4 text-center text-sm text-muted-foreground"
              >
                No tasks available.
              </TableCell>
            </TableRow>
          )}
        </TableBody>
      </Table>
    </div>
  );
};

export default TaskTable;

--------------------------------------------------------------------------------
<File: frontend/src/components/task/TaskTableRow.tsx>
// src/components/task/TaskTableRow.tsx
import { useState } from 'react';
import { TableCell, TableRow } from '../ui/table';
import { Button } from '../ui/button';
import { Eye, Trash2, Check } from 'lucide-react';
import { useToast } from "@/hooks/use-toast";
import TaskDetails from './TaskDetails';
import { Task } from '@/utils/types';
import {
  STATUS_DISPLAY,
  STATUS_COLORS,
  getPriorityDisplay,
  EFFORT_DISPLAY,
  getRecurrenceDisplay,
} from '@/utils/displayMappings';
import { syncChanges, store } from '@/state/syncEngine';
import { updateTask, deleteTask } from '@/state/slices/taskSlice';
import { calculateNextDueDate, createCompletionRecord, shouldResetTask, formatDate } from './Recurrence';
import '@/components/animations/animations.css';
import { Popover, PopoverContent, PopoverTrigger } from '../ui/popover';

const STATUS_SEQUENCE = ['notStarted', 'workingOnIt', 'complete'] as const;
const PRIORITY_SEQUENCE = [0, 20, 40, 60, 80];
const EFFORT_SEQUENCE = [1, 2, 3, 4, 5];

interface TaskTableRowProps {
  task: Task;
}

const TaskTableRow = ({ task }: TaskTableRowProps) => {
  const { toast } = useToast();
  const [showDetails, setShowDetails] = useState(false);
  const [animateCheck, setAnimateCheck] = useState(false);
  const [isResetting, setIsResetting] = useState(false);
  const [isDeleteOpen, setIsDeleteOpen] = useState(false);

  // Priority, Effort, Recurrence strings
  const priorityInfo = getPriorityDisplay(task.priority);
  const effortInfo = task.effort ? EFFORT_DISPLAY[task.effort] : null;
  const recurrenceLabel = getRecurrenceDisplay(
    task.recurrence?.isRecurring || false,
    task.recurrence?.rule?.frequency,
    task.recurrence?.rule?.interval
  );

  // Handle marking a recurring task as complete
  const handleRecurringComplete = () => {
    if (!task.recurrence?.rule) return;

    // Calculate next due date
    const nextDueDate = calculateNextDueDate(task.recurrence.rule);
    
    // Create completion record
    const completionRecord = createCompletionRecord(nextDueDate);

    // Show completion state briefly
    store.dispatch(updateTask({
      id: task.id,
      changes: { status: 'complete' }
    }));

    // Trigger animations
    setAnimateCheck(true);
    setTimeout(() => {
      setIsResetting(true);

      // Update task with new status, due date, and completion history
      store.dispatch(updateTask({
        id: task.id,
        changes: {
          status: 'notStarted',
          dueDate: nextDueDate,
          completionHistory: [...task.completionHistory, completionRecord]
        }
      }));

      // Sync changes to backend
      syncChanges('status', [{
        type: 'task',
        operation: 'update',
        id: task.id,
        data: {
          status: 'notStarted',
          dueDate: nextDueDate,
          completionHistory: [...task.completionHistory, completionRecord]
        }
      }]);

      // Show toast notification
      toast({
        title: "Task Reset",
        description: `${task.title} will be due again on ${formatDate(nextDueDate)}`,
      });

      // Reset animations
      setAnimateCheck(false);
      setTimeout(() => setIsResetting(false), 300);
    }, 1500);
  };

  // Handle status changes
  const handleStatusClick = () => {
    const currentIndex = STATUS_SEQUENCE.indexOf(task.status);
    const nextIndex = (currentIndex + 1) % STATUS_SEQUENCE.length;
    const nextStatus = STATUS_SEQUENCE[nextIndex];

    // If completing a recurring task
    if (nextStatus === 'complete' && shouldResetTask(task)) {
      handleRecurringComplete();
      return;
    }

    // Handle normal status change
    store.dispatch(updateTask({
      id: task.id,
      changes: { status: nextStatus }
    }));

    syncChanges('status', [{
      type: 'task',
      operation: 'update',
      id: task.id,
      data: { status: nextStatus }
    }]);

    // Update animation state based on status
    if (nextStatus === 'complete') {
      setAnimateCheck(true);
    } else {
      setAnimateCheck(false);
    }
  };

  // Handle priority changes
  const handlePriorityClick = () => {
    const currentIndex = PRIORITY_SEQUENCE.indexOf(task.priority);
    const safeIndex = currentIndex >= 0 ? currentIndex : 0;
    const nextIndex = (safeIndex + 1) % PRIORITY_SEQUENCE.length;
    const nextPriority = PRIORITY_SEQUENCE[nextIndex];

    store.dispatch(updateTask({
      id: task.id,
      changes: { priority: nextPriority }
    }));

    syncChanges('priority', [{
      type: 'task',
      operation: 'update',
      id: task.id,
      data: { priority: nextPriority }
    }]);
  };

  // Handle effort changes
  const handleEffortClick = () => {
    const currentEffort = task.effort || 1;
    const currentIndex = EFFORT_SEQUENCE.indexOf(currentEffort);
    const safeIndex = currentIndex >= 0 ? currentIndex : 0;
    const nextIndex = (safeIndex + 1) % EFFORT_SEQUENCE.length;
    const nextEffort = EFFORT_SEQUENCE[nextIndex];

    store.dispatch(updateTask({
      id: task.id,
      changes: { effort: nextEffort }
    }));

    syncChanges('priority', [{
      type: 'task',
      operation: 'update',
      id: task.id,
      data: { effort: nextEffort }
    }]);
  };

  // Delete task
  const handleDeleteTask = (id: string) => {
    store.dispatch(deleteTask(id));
    syncChanges('status', [{
      type: 'task',
      operation: 'delete',
      id
    }]);
  };

  return (
    <>
      <TableRow
        className={[
          'task-row hover:bg-muted/10 even:bg-muted/5 transition-colors',
          isResetting ? 'task-resetting' : '',
          task.status === 'complete' ? 'animate-completion' : '',
        ].filter(Boolean).join(' ')}
      >
        {/* TITLE */}
        <TableCell className="px-4 py-2">
          {task.title}
        </TableCell>

        {/* STATUS BUBBLE */}
        <TableCell className="px-4 py-2">
          <button
            onClick={handleStatusClick}
            className={[
              'inline-flex items-center justify-center w-28 h-8 px-2 py-1 rounded-full text-xs relative',
              'status-bubble',
              STATUS_COLORS[task.status] || 'bg-gray-100 text-gray-800',
              animateCheck || task.status === 'complete' ? 'animate-check' : '',
              task.status === 'complete' ? 'status-complete' : '',
            ].join(' ')}
          >
            <div className="flex items-center gap-1">
              {task.status === 'complete' && (
                <Check className="status-check-icon h-4 w-4" />
              )}
              {STATUS_DISPLAY[task.status] || task.status}
            </div>
          </button>
        </TableCell>

        {/* PRIORITY CHIP */}
        <TableCell className="px-4 py-2">
          <button
            onClick={handlePriorityClick}
            className={[
              'inline-flex items-center justify-center w-24 h-8 px-2 py-1 rounded-full text-xs font-medium',
              priorityInfo.colorClass,
              'cursor-pointer transition-transform hover:scale-105'
            ].join(' ')}
          >
            {priorityInfo.label}
          </button>
        </TableCell>

        {/* EFFORT CHIP */}
        <TableCell className="px-4 py-2">
          <button
            onClick={handleEffortClick}
            className={[
              'inline-flex items-center justify-center w-20 h-8 px-2 py-1 rounded-full text-xs font-medium',
              effortInfo ? effortInfo.colorClass : 'bg-gray-100 text-gray-800',
              'cursor-pointer transition-transform hover:scale-105'
            ].join(' ')}
          >
            {effortInfo ? effortInfo.label : 'N/A'}
          </button>
        </TableCell>

        {/* DUE DATE */}
        <TableCell className="px-4 py-2">
          {task.dueDate ? formatDate(task.dueDate) : '-'}
        </TableCell>

        {/* RECURRENCE */}
        <TableCell className="px-4 py-2">
          {recurrenceLabel}
        </TableCell>

        {/* NOTES */}
        <TableCell className="px-4 py-2 whitespace-nowrap max-w-xs overflow-hidden overflow-ellipsis">
          {task.notes?.trim() || '-'}
        </TableCell>

        {/* ACTIONS */}
        <TableCell className="px-4 py-2 text-right">
          <div className="flex items-center justify-end gap-2">
            <Button 
              variant="default" 
              size="sm" 
              onClick={() => setShowDetails(true)}
            >
              <Eye className="h-4 w-4" />
            </Button>
            <Popover open={isDeleteOpen} onOpenChange={setIsDeleteOpen}>
              <PopoverTrigger asChild>
                <Button
                  variant="default"
                  size="sm"
                >
                  <Trash2 className="h-4 w-4" />
                </Button>
              </PopoverTrigger>
              <PopoverContent className="w-48 p-2">
                <div className="flex flex-col gap-2">
                  <p className="text-sm font-medium">Delete this task?</p>
                  <div className="flex justify-end gap-2">
                    <Button
                      variant="ghost"
                      size="sm"
                      onClick={() => setIsDeleteOpen(false)}
                    >
                      Cancel
                    </Button>
                    <Button
                      variant="destructive"
                      size="sm"
                      onClick={() => {
                        handleDeleteTask(task.id);
                        setIsDeleteOpen(false);
                      }}
                    >
                      Delete
                    </Button>
                  </div>
                </div>
              </PopoverContent>
            </Popover>
          </div>
        </TableCell>
      </TableRow>

      {/* DETAILS DIALOG */}
      {showDetails && (
        <TaskDetails
          task={task}
          open={showDetails}
          onOpenChange={setShowDetails}
        />
      )}
    </>
  );
};

export default TaskTableRow;
--------------------------------------------------------------------------------
<File: frontend/src/components/ui/button.tsx>
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "../../utils/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "bg-transparent text-foreground hover:text-foreground border border-input transition-colors",
        destructive:
          "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
        outline:
          "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
        gray:
          "bg-grayButton text-grayButton-foreground hover:bg-grayButton-hover shadow-sm",
        transparent:
          "bg-transparent text-muted-foreground hover:text-foreground transition-colors",
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }
--------------------------------------------------------------------------------
<File: frontend/src/components/ui/calendar.tsx>
import * as React from "react"
import { ChevronLeft, ChevronRight } from "lucide-react"
import { DayPicker } from "react-day-picker"

import { cn } from "../../utils/utils"
import { buttonVariants } from "./button"

export type CalendarProps = React.ComponentProps<typeof DayPicker>

function Calendar({
  className,
  classNames,
  showOutsideDays = true,
  ...props
}: CalendarProps) {
  return (
    <DayPicker
      showOutsideDays={showOutsideDays}
      className={cn("p-3", className)}
      classNames={{
        months: "flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0",
        month: "space-y-4",
        caption: "flex justify-center pt-1 relative items-center",
        caption_label: "text-sm font-medium",
        nav: "space-x-1 flex items-center",
        nav_button: cn(
          buttonVariants({ variant: "outline" }),
          "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100"
        ),
        nav_button_previous: "absolute left-1",
        nav_button_next: "absolute right-1",
        table: "w-full border-collapse space-y-1",
        head_row: "flex",
        head_cell:
          "text-muted-foreground rounded-md w-8 font-normal text-[0.8rem]",
        row: "flex w-full mt-2",
        cell: cn(
          "relative p-0 text-center text-sm focus-within:relative focus-within:z-20 [&:has([aria-selected])]:bg-accent [&:has([aria-selected].day-outside)]:bg-accent/50 [&:has([aria-selected].day-range-end)]:rounded-r-md",
          props.mode === "range"
            ? "[&:has(>.day-range-end)]:rounded-r-md [&:has(>.day-range-start)]:rounded-l-md first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md"
            : "[&:has([aria-selected])]:rounded-md"
        ),
        day: cn(
          buttonVariants({ variant: "ghost" }),
          "h-8 w-8 p-0 font-normal aria-selected:opacity-100"
        ),
        day_range_start: "day-range-start",
        day_range_end: "day-range-end",
        day_selected:
          "bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground",
        day_today: "bg-accent text-accent-foreground",
        day_outside:
          "day-outside text-muted-foreground aria-selected:bg-accent/50 aria-selected:text-muted-foreground",
        day_disabled: "text-muted-foreground opacity-50",
        day_range_middle:
          "aria-selected:bg-accent aria-selected:text-accent-foreground",
        day_hidden: "invisible",
        ...classNames,
      }}
      components={{
        IconLeft: ({ className, ...props }) => (
          <ChevronLeft className={cn("h-4 w-4", className)} {...props} />
        ),
        IconRight: ({ className, ...props }) => (
          <ChevronRight className={cn("h-4 w-4", className)} {...props} />
        ),
      }}
      {...props}
    />
  )
}
Calendar.displayName = "Calendar"

export { Calendar }
--------------------------------------------------------------------------------
<File: frontend/src/components/ui/card.tsx>
import * as React from "react"

import { cn } from "../../utils/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-xl border bg-card text-card-foreground shadow",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("font-semibold leading-none tracking-tight", className)}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }

--------------------------------------------------------------------------------
<File: frontend/src/components/ui/checkbox.tsx>
import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { Check } from "lucide-react"

import { cn } from "../../utils/utils"

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary shadow focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn("flex items-center justify-center text-current")}
    >
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
))
Checkbox.displayName = CheckboxPrimitive.Root.displayName

export { Checkbox }

--------------------------------------------------------------------------------
<File: frontend/src/components/ui/dialog.tsx>
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"

import { cn } from "../../utils/utils"


const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogTrigger,
  DialogClose,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}

--------------------------------------------------------------------------------
<File: frontend/src/components/ui/input.tsx>
import * as React from "react"

import { cn } from "../../utils/utils"

const Input = React.forwardRef<HTMLInputElement, React.ComponentProps<"input">>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-base shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }

--------------------------------------------------------------------------------
<File: frontend/src/components/ui/label.tsx>
import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "../../utils/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }

--------------------------------------------------------------------------------
<File: frontend/src/components/ui/popover.tsx>
"use client"

import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

import { cn } from "../../utils/utils"

const Popover = PopoverPrimitive.Root

const PopoverTrigger = PopoverPrimitive.Trigger

const PopoverAnchor = PopoverPrimitive.Anchor

const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <PopoverPrimitive.Portal>
    <PopoverPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </PopoverPrimitive.Portal>
))
PopoverContent.displayName = PopoverPrimitive.Content.displayName

export { Popover, PopoverTrigger, PopoverContent, PopoverAnchor }

--------------------------------------------------------------------------------
<File: frontend/src/components/ui/select.tsx>
import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"

import { cn } from "../../utils/utils"

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-9 w-full items-center justify-between whitespace-nowrap rounded-md border border-input bg-transparent px-3 py-2 text-sm shadow-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-1 focus:ring-ring disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("px-2 py-1.5 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-2 pr-8 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute right-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>
    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}

--------------------------------------------------------------------------------
<File: frontend/src/components/ui/separator.tsx>
"use client"

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "../../utils/utils"

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
  (
    { className, orientation = "horizontal", decorative = true, ...props },
    ref
  ) => (
    <SeparatorPrimitive.Root
      ref={ref}
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "shrink-0 bg-border",
        orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
        className
      )}
      {...props}
    />
  )
)
Separator.displayName = SeparatorPrimitive.Root.displayName

export { Separator }

--------------------------------------------------------------------------------
<File: frontend/src/components/ui/skeleton.tsx>
import { cn } from "../../utils/utils"

function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-primary/10", className)}
      {...props}
    />
  )
}

export { Skeleton }

--------------------------------------------------------------------------------
<File: frontend/src/components/ui/table.tsx>
import * as React from "react"

import { cn } from "../../utils/utils"

const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="relative w-full overflow-auto">
    <table
      ref={ref}
      className={cn("w-full caption-bottom text-sm", className)}
      {...props}
    />
  </div>
))
Table.displayName = "Table"

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />
))
TableHeader.displayName = "TableHeader"

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn("[&_tr:last-child]:border-0", className)}
    {...props}
  />
))
TableBody.displayName = "TableBody"

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn(
      "border-t bg-muted/50 font-medium [&>tr]:last:border-b-0",
      className
    )}
    {...props}
  />
))
TableFooter.displayName = "TableFooter"

const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
      className
    )}
    {...props}
  />
))
TableRow.displayName = "TableRow"

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      "h-10 px-2 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
      className
    )}
    {...props}
  />
))
TableHead.displayName = "TableHead"

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn(
      "p-2 align-middle [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
      className
    )}
    {...props}
  />
))
TableCell.displayName = "TableCell"

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn("mt-4 text-sm text-muted-foreground", className)}
    {...props}
  />
))
TableCaption.displayName = "TableCaption"

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}

--------------------------------------------------------------------------------
<File: frontend/src/components/ui/toast.tsx>
import * as React from "react"
import * as ToastPrimitives from "@radix-ui/react-toast"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import { cn } from "../../utils/utils"

const ToastProvider = ToastPrimitives.Provider

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
      className
    )}
    {...props}
  />
))
ToastViewport.displayName = ToastPrimitives.Viewport.displayName

const toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-2 overflow-hidden rounded-md border p-4 pr-6 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border bg-background text-foreground",
        destructive:
          "destructive group border-destructive bg-destructive text-destructive-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  )
})
Toast.displayName = ToastPrimitives.Root.displayName

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium transition-colors hover:bg-secondary focus:outline-none focus:ring-1 focus:ring-ring disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
      className
    )}
    {...props}
  />
))
ToastAction.displayName = ToastPrimitives.Action.displayName

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      "absolute right-1 top-1 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-1 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      className
    )}
    toast-close=""
    {...props}
  >
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
))
ToastClose.displayName = ToastPrimitives.Close.displayName

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn("text-sm font-semibold [&+div]:text-xs", className)}
    {...props}
  />
))
ToastTitle.displayName = ToastPrimitives.Title.displayName

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn("text-sm opacity-90", className)}
    {...props}
  />
))
ToastDescription.displayName = ToastPrimitives.Description.displayName

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>

type ToastActionElement = React.ReactElement<typeof ToastAction>

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
}

--------------------------------------------------------------------------------
<File: frontend/src/components/ui/toaster.tsx>
import { useToast } from "@/hooks/use-toast"
import {
  Toast,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
} from "@/components/ui/toast"

export function Toaster() {
  const { toasts } = useToast()

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && (
                <ToastDescription>{description}</ToastDescription>
              )}
            </div>
            {action}
            <ToastClose />
          </Toast>
        )
      })}
      <ToastViewport />
    </ToastProvider>
  )
}

--------------------------------------------------------------------------------
<File: frontend/src/components/weekly-plan/DayColumn.tsx>
// src/components/weekly-plan/DayColumn.tsx
import { useDispatch } from 'react-redux';
import { Task } from '@/utils/types';
import TaskCard from '../task/TaskCard';
import { updateTask } from '@/state/slices/taskSlice';
import { syncChanges } from '@/state/syncEngine';

interface DayColumnProps {
  date: Date;
  tasks: Task[];
}

const DayColumn = ({ date, tasks }: DayColumnProps) => {
  const dispatch = useDispatch();

  const handleDrop = (e: React.DragEvent) => {
    e.preventDefault();
    const taskId = e.dataTransfer.getData('text/task-id');
    
    if (!taskId) return;

    const newScheduledDate = date.toISOString();

    // Optimistically update Redux
    dispatch(updateTask({
      id: taskId,
      changes: { scheduledDate: newScheduledDate }
    }));

    // Sync to backend
    syncChanges('drag', [{
      type: 'task',
      operation: 'update',
      id: taskId,
      data: { scheduledDate: newScheduledDate }
    }]);
  };

  const handleDragOver = (e: React.DragEvent) => {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
  };

  return (
    <div
      className="flex-1 p-2 overflow-y-auto"
      onDrop={handleDrop}
      onDragOver={handleDragOver}
    >
      <div className="space-y-2">
        {tasks.map(task => (
          <TaskCard
            key={task.id}
            task={task}
            isDraggable
          />
        ))}
        {tasks.length === 0 && (
          <div className="h-20 flex items-center justify-center border-2 border-dashed rounded-lg">
            <p className="text-sm text-muted-foreground">
              Drop tasks here
            </p>
          </div>
        )}
      </div>
    </div>
  );
};

export default DayColumn;
--------------------------------------------------------------------------------
<File: frontend/src/components/weekly-plan/UnscheduledTaskSidebar.tsx>
// src/components/weekly-plan/UnscheduledTasksSidebar.tsx
import { Task } from '@/utils/types';
import { Card, CardHeader, CardTitle, CardContent } from '@/components/ui/card';
import TaskCard from '../task/TaskCard';

interface UnscheduledTasksSidebarProps {
  tasks: Task[];
}

const UnscheduledTasksSidebar = ({ tasks }: UnscheduledTasksSidebarProps) => {
  return (
    <Card className="h-full">
      <CardHeader className="px-4 py-3">
        <CardTitle className="text-base font-medium">Unscheduled Tasks</CardTitle>
      </CardHeader>
      <CardContent className="p-2 overflow-y-auto">
        <div className="space-y-2">
          {tasks.map(task => (
            <TaskCard
              key={task.id}
              task={task}
              isDraggable
            />
          ))}
          {tasks.length === 0 && (
            <p className="text-sm text-muted-foreground text-center p-4">
              No unscheduled tasks
            </p>
          )}
        </div>
      </CardContent>
    </Card>
  );
};

export default UnscheduledTasksSidebar;
--------------------------------------------------------------------------------
<File: frontend/src/components/weekly-plan/WeeklyCalendar.tsx>
// src/components/weekly-plan/WeeklyCalendar.tsx
import { format, isSameDay } from 'date-fns';
import { Task } from '@/utils/types';
import DayColumn from './DayColumn';

interface WeeklyCalendarProps {
  weekDates: Date[];
  tasks: Task[];
}

const WeeklyCalendar = ({ weekDates, tasks }: WeeklyCalendarProps) => {
  // Function to get tasks for a specific date
  const getTasksForDate = (date: Date) => {
    return tasks.filter(task => {
      if (!task.scheduledDate) return false;
      return isSameDay(new Date(task.scheduledDate), date);
    });
  };

  return (
    <div className="h-full border rounded-lg bg-card">
      <div className="h-full flex divide-x">
        {weekDates.map(date => {
          const dayTasks = getTasksForDate(date);
          const isToday = isSameDay(date, new Date());
          
          return (
            <div 
              key={date.toISOString()} 
              className="flex-1 flex flex-col min-w-0"
            >
              {/* Day header */}
              <div className={`
                px-2 py-3 text-center border-b
                ${isToday ? 'bg-primary/5' : ''}
              `}>
                <div className="text-sm font-medium">
                  {format(date, 'EEEE')}
                </div>
                <div className={`
                  text-sm mt-1
                  ${isToday ? 'text-primary font-medium' : 'text-muted-foreground'}
                `}>
                  {format(date, 'MMM d')}
                </div>
              </div>

              {/* Day content */}
              <DayColumn 
                date={date} 
                tasks={dayTasks}
              />
            </div>
          );
        })}
      </div>
    </div>
  );
};

export default WeeklyCalendar;
--------------------------------------------------------------------------------
<File: frontend/src/hooks/use-toast.ts>
"use client"

// Inspired by react-hot-toast library
import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }

--------------------------------------------------------------------------------
<File: frontend/src/main.tsx>
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './styles/globals.css'
import App from './App.tsx'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
)

--------------------------------------------------------------------------------
<File: frontend/src/pages/HomePage.tsx>
import React from 'react';

const HomePage = () => {
  return (
    <div className="p-6">
      <h1 className="text-2xl font-bold mb-4">Home</h1>
      {/* Content will be added later */}
    </div>
  );
};

export default HomePage; 
--------------------------------------------------------------------------------
<File: frontend/src/pages/MasterListPage.tsx>
import React, { useState } from 'react';
import { useSelector } from 'react-redux';
import { Plus } from 'lucide-react';
import { RootState } from '../state/syncEngine';
import TaskTable from '../components/task/TaskTable';
import { AddTaskDialog } from '../components/task/AddTaskDialog';
import { Button } from '../components/ui/button';
import { Task } from '../utils/types';

const MasterListPage = () => {
  const [showAddDialog, setShowAddDialog] = useState(false);
  const tasksObj = useSelector((state: RootState) => state.tasks.items);
  const tasksArray: Task[] = Object.values(tasksObj);

  return (
    <div className="w-full space-y-4">
      <div className="flex justify-between items-center">
        <h1 className="text-2xl font-bold">Master List</h1>
        <Button onClick={() => setShowAddDialog(true)}>
          <Plus className="h-4 w-4 mr-2" />
          New Task
        </Button>
      </div>

      <div className="rounded-md border w-full">
        <TaskTable tasks={tasksArray} />
      </div>

      <AddTaskDialog 
        open={showAddDialog}
        onOpenChange={setShowAddDialog}
      />
    </div>
  );
};

export default MasterListPage;
--------------------------------------------------------------------------------
<File: frontend/src/pages/WeeklyPlanPage.tsx>
// src/pages/WeeklyPlanPage.tsx
import { useState } from 'react';
import { useSelector } from 'react-redux';
import { RootState } from '../state/syncEngine';
import { startOfWeek, addDays, format, addWeeks, subWeeks } from 'date-fns';
import { ChevronLeft, ChevronRight } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Task } from '@/utils/types';
import UnscheduledTasksSidebar from '@/components/weekly-plan/UnscheduledTaskSidebar';
import WeeklyCalendar from '@/components/weekly-plan/WeeklyCalendar';

const WeeklyPlanPage = () => {
  // State for the selected week's start date
  const [selectedWeekStart, setSelectedWeekStart] = useState(() => 
    startOfWeek(new Date(), { weekStartsOn: 0 }) // Start on Sunday
  );

  // Get all tasks from Redux
  const tasks = useSelector((state: RootState) => state.tasks.items);
  const tasksArray = Object.values(tasks);

  // Get unscheduled tasks (no scheduledDate)
  const unscheduledTasks = tasksArray.filter(task => !task.scheduledDate);

  // Navigation handlers
  const handlePreviousWeek = () => {
    setSelectedWeekStart(prev => subWeeks(prev, 1));
  };

  const handleNextWeek = () => {
    setSelectedWeekStart(prev => addWeeks(prev, 1));
  };

  // Generate array of dates for the week
  const weekDates = Array.from({ length: 7 }, (_, i) => 
    addDays(selectedWeekStart, i)
  );

  return (
    <div className="h-full flex flex-col space-y-4">
      {/* Header with navigation */}
      <div className="flex justify-between items-center">
        <h1 className="text-2xl font-bold">Weekly Plan</h1>
        <div className="flex items-center space-x-4">
          <div className="text-lg font-medium">
            {format(weekDates[0], 'MMM d')} - {format(weekDates[6], 'MMM d, yyyy')}
          </div>
          <div className="flex space-x-2">
            <Button
              variant="outline"
              size="icon"
              onClick={handlePreviousWeek}
            >
              <ChevronLeft className="h-4 w-4" />
            </Button>
            <Button
              variant="outline"
              size="icon"
              onClick={handleNextWeek}
            >
              <ChevronRight className="h-4 w-4" />
            </Button>
          </div>
        </div>
      </div>

      {/* Main content area */}
      <div className="flex-1 flex gap-4 min-h-0">
        {/* Unscheduled tasks sidebar */}
        <div className="w-80 flex-shrink-0">
          <UnscheduledTasksSidebar tasks={unscheduledTasks} />
        </div>

        {/* Weekly calendar grid */}
        <div className="flex-1">
          <WeeklyCalendar 
            weekDates={weekDates}
            tasks={tasksArray}
          />
        </div>
      </div>
    </div>
  );
};

export default WeeklyPlanPage;
--------------------------------------------------------------------------------
<File: frontend/src/state/logger.ts>
// src/state/logger.ts

import { Middleware, Action } from '@reduxjs/toolkit';
import { diff } from 'deep-object-diff';

// Helper to get a clean state diff
const getStateDiff = (prevState: any, nextState: any) => {
    const stateDiff = diff(prevState, nextState);
    return Object.keys(stateDiff).length ? stateDiff : null;
};

// Helper to format timestamps consistently
const getTimestamp = () => new Date().toISOString();

// Grouped console styling
const groupStyles = {
    init: 'color: #3f51b5; font-weight: bold;',     // Indigo for initialization
    action: 'color: #4CAF50; font-weight: bold;',    // Green for data changes
    sync: 'color: #9c27b0; font-weight: bold;',      // Purple for sync operations
    error: 'color: #f44336; font-weight: bold;'      // Red for errors
};

// Custom logger middleware for state changes
export const stateLogger: Middleware = (store) => (next) => (action: unknown) => {
    // Skip logging for sync status changes
    if ((action as Action).type === 'sync/setSyncStatus') {
        return next(action);
    }

    const timestamp = getTimestamp();
    const prevState = store.getState();
    const result = next(action);
    const nextState = store.getState();
    
    // Calculate meaningful state changes
    const stateDiff = getStateDiff(prevState, nextState);
    
    if (stateDiff) {
        const actionType = (action as Action).type;
        const style = actionType.startsWith('sync/') ? groupStyles.sync : groupStyles.action;
        
        console.groupCollapsed(`%c${actionType}`, style);
        console.log({
            type: actionType,
            payload: (action as any).payload,
            timestamp,
            changes: stateDiff
        });
        console.groupEnd();
    }
    
    return result;
};

// Sync operation logging functions
export const logSyncStarted = (changes: any[], changeType: string) => {
    console.groupCollapsed('%cSync Started', groupStyles.sync);
    console.log({
        type: 'sync/started',
        changeType,
        numChanges: changes.length,
        changes,
        timestamp: getTimestamp()
    });
    console.groupEnd();
};

export const logSyncCompleted = (syncedAt: string) => {
    console.groupCollapsed('%cSync Completed', groupStyles.sync);
    console.log({
        type: 'sync/completed',
        result: 'success',
        syncedAt,
        timestamp: getTimestamp()
    });
    console.groupEnd();
};

export const logSyncFailed = (error: unknown) => {
    console.group('%cSync Failed', groupStyles.error);
    console.log({
        type: 'sync/failed',
        error: {
            code: error instanceof Error ? error.name : 'UNKNOWN_ERROR',
            message: error instanceof Error ? error.message : 'An unknown error occurred'
        },
        timestamp: getTimestamp()
    });
    console.groupEnd();
};

// Initial load logging
export const logInitialState = (state: any) => {
    console.group('%cInitial Redux State', groupStyles.init);
    console.log('State:', state);
    console.log('Tasks:', Object.keys(state.tasks.items).length);
    console.log('Sync Status:', state.sync.status);
    console.log('Last Synced:', state.sync.lastSynced);
    console.groupEnd();
};
--------------------------------------------------------------------------------
<File: frontend/src/state/slices/syncSlice.ts>
import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import { SyncState } from '../../utils/types';

const initialState: SyncState = {
    status: 'idle',
    lastSynced: null,
    pendingChanges: 0
};

export const syncSlice = createSlice({
    name: 'sync',
    initialState,
    reducers: {
        setSyncStatus: (state, action: PayloadAction<'idle' | 'syncing' | 'error'>) => {
            state.status = action.payload;
        },
        setLastSynced: (state, action: PayloadAction<string | null>) => {
            state.lastSynced = action.payload;
        },
        incrementPendingChanges: (state) => {
            state.pendingChanges += 1;
        },
        decrementPendingChanges: (state) => {
            if (state.pendingChanges > 0) {
                state.pendingChanges -= 1;
            }
        },
        resetPendingChanges: (state) => {
            state.pendingChanges = 0;
        }
    }
});

export const {
    setSyncStatus,
    setLastSynced,
    incrementPendingChanges,
    decrementPendingChanges,
    resetPendingChanges
} = syncSlice.actions;

export default syncSlice.reducer; 
--------------------------------------------------------------------------------
<File: frontend/src/state/slices/taskSlice.ts>
// File: frontend/src/state/slices/taskSlice.ts

import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import { Task, TasksState, UUID } from '../../utils/types';

const initialState: TasksState = {
  items: {},
  loading: false,
  error: null
};

export const taskSlice = createSlice({
  name: 'tasks',
  initialState,
  reducers: {
    setLoading: (state, action: PayloadAction<boolean>) => {
      state.loading = action.payload;
    },
    setError: (state, action: PayloadAction<string | null>) => {
      state.error = action.payload;
    },

    /**
     * Add a single task to the dictionary.
     */
    addTask: (state, action: PayloadAction<Task>) => {
      state.items[action.payload.id] = action.payload;
    },

    /**
     * Update an existing task by its id.
     */
    updateTask: (state, action: PayloadAction<{ id: UUID; changes: Partial<Task> }>) => {
      const { id, changes } = action.payload;
      if (state.items[id]) {
        state.items[id] = { ...state.items[id], ...changes };
      } else {
        console.log('[updateTask] Task not found in store:', id);
      }
    },

    /**
     * Delete a task from the dictionary by its id.
     */
    deleteTask: (state, action: PayloadAction<UUID>) => {
      delete state.items[action.payload];
    },

    /**
     * Set an entire collection of tasks in the store. 
     * Accepts EITHER:
     *   1) A dictionary of tasks keyed by ID, OR
     *   2) An array of tasks
     * We convert arrays to a dictionary automatically.
     */
    setTasks: (
      state,
      action: PayloadAction<Record<UUID, Task> | Task[]>
    ) => {
      const payload = action.payload;

      if (Array.isArray(payload)) {
        // If payload is an array, convert it to a dictionary
        const record: Record<string, Task> = {};
        payload.forEach((task) => {
          record[task.id] = task;
        });
        state.items = record;
      } else {
        // If it's already a dictionary, just store it
        state.items = payload;
      }
    }
  }
});

// Export all of the action creators
export const {
  setLoading,
  setError,
  addTask,
  updateTask,
  deleteTask,
  setTasks
} = taskSlice.actions;

// Export the reducer to be included in your store
export default taskSlice.reducer;

--------------------------------------------------------------------------------
<File: frontend/src/state/syncEngine.ts>
// src/state/syncEngine.ts

import { configureStore } from '@reduxjs/toolkit';
import { debounce } from 'lodash';
import taskReducer, {
  setTasks,
  addTask,
  updateTask,
  deleteTask
} from './slices/taskSlice';
import syncReducer, {
  setSyncStatus,
  setLastSynced,
  resetPendingChanges
} from './slices/syncSlice';
import { api } from '../utils/api';
import { Task, UUID, ChangeType } from '../utils/types';
import {
  stateLogger,
  logSyncStarted,
  logSyncCompleted,
  logSyncFailed,
  logInitialState
} from './logger';

/**
 * Configure the Redux store
 */
export const store = configureStore({
  reducer: {
    tasks: taskReducer,
    sync: syncReducer
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      serializableCheck: {
        // Ignore these action types in serializability checks
        ignoredActions: ['sync/setLastSynced']
      }
    }).concat(stateLogger)
});

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;

/**
 * Sync configuration for each type of UI change
 */
const SYNC_CONFIG: Record<ChangeType, number> = {
  text: 2000,      // 2 seconds for text changes
  status: 500,     // 500ms for status changes
  priority: 1000,  // 1 second for priority changes
  drag: 500        // 500ms for drag operations
};

/**
 * Initialize data on app start
 */
export const initializeData = async () => {
  try {
    store.dispatch(setSyncStatus('syncing'));

    const userData = await api.getUserData();
    store.dispatch(setTasks(userData.tasks));
    store.dispatch(setLastSynced(userData.lastSyncedAt));

    store.dispatch(setSyncStatus('idle'));
    logInitialState(store.getState());
  } catch (error) {
    console.error('Failed to initialize data:', error);
    store.dispatch(setSyncStatus('error'));
  }
};

/**
 * Debounced sync functions (FIRE AND FORGET!)
 *
 * Each function logs the start, sets the store to 'syncing',
 * but does NOT await the result. We handle success/failure in then/catch.
 */
const debouncedSyncs = Object.entries(SYNC_CONFIG).reduce(
  (acc, [changeType, delay]) => {
    acc[changeType as ChangeType] = debounce((changes: Array<{
      type: 'task';
      operation: 'create' | 'update' | 'delete';
      id?: UUID;
      data?: Partial<Task>;
    }>) => {
      // 1) Log sync start in console
      logSyncStarted(changes, changeType);
      // 2) Set store to 'syncing' so top panel can show spinner
      store.dispatch(setSyncStatus('syncing'));

      const syncRequest = {
        changes: changes.map((change) => ({
          ...change,
          timestamp: new Date().toISOString(),
          changeType: changeType as ChangeType
        })),
        // fallback to "now" if we don't have lastSynced
        clientLastSync: store.getState().sync.lastSynced || new Date().toISOString()
      };

      // ===== Fire-and-forget: NO `await` here =====
      api.sync(syncRequest)
        .then((response) => {
          // Sync is done - just update sync status
          store.dispatch(setLastSynced(response.syncedAt));
          store.dispatch(setSyncStatus('idle'));
          store.dispatch(resetPendingChanges());

          logSyncCompleted(response.syncedAt);
        })
        .catch((error) => {
          logSyncFailed(error);
          // Mark the store as 'error', so top panel can show "sync error"
          store.dispatch(setSyncStatus('error'));
        });
    }, delay);

    return acc;
  },
  {} as Record<ChangeType, Function>
);

/**
 * Export a helper so components can queue changes
 */
export const syncChanges = (
  changeType: ChangeType,
  changes: Array<{
    type: 'task';
    operation: 'create' | 'update' | 'delete';
    id?: UUID;
    data?: Partial<Task>;
  }>
) => {
  debouncedSyncs[changeType](changes);
};

--------------------------------------------------------------------------------
<File: frontend/src/styles/globals.css>
@tailwind base;
@tailwind components;
@tailwind utilities;
 
@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%;

    --card: 0 0% 100%;
    --card-foreground: 222.2 84% 4.9%;
 
    --popover: 0 0% 100%;
    --popover-foreground: 222.2 84% 4.9%;
 
    --primary: 222.2 47.4% 11.2%;
    --primary-foreground: 210 40% 98%;
 
    --secondary: 210 40% 96.1%;
    --secondary-foreground: 222.2 47.4% 11.2%;
 
    --muted: 210 40% 96.1%;
    --muted-foreground: 215.4 16.3% 46.9%;
 
    --accent: 210 40% 96.1%;
    --accent-foreground: 222.2 47.4% 11.2%;
 
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 40% 98%;

    --border: 214.3 31.8% 91.4%;
    --input: 214.3 31.8% 91.4%;
    --ring: 222.2 84% 4.9%;
 
    --radius: 0.5rem;
  }
 
  .dark {
    --background: 222.2 84% 4.9%;
    --foreground: 210 40% 98%;
 
    --card: 222.2 84% 4.9%;
    --card-foreground: 210 40% 98%;
 
    --popover: 222.2 84% 4.9%;
    --popover-foreground: 210 40% 98%;
 
    --primary: 210 40% 98%;
    --primary-foreground: 222.2 47.4% 11.2%;
 
    --secondary: 217.2 32.6% 17.5%;
    --secondary-foreground: 210 40% 98%;
 
    --muted: 217.2 32.6% 17.5%;
    --muted-foreground: 215 20.2% 65.1%;
 
    --accent: 217.2 32.6% 17.5%;
    --accent-foreground: 210 40% 98%;
 
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 210 40% 98%;
 
    --border: 217.2 32.6% 17.5%;
    --input: 217.2 32.6% 17.5%;
    --ring: 212.7 26.8% 83.9%;
  }
}
 
@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}
--------------------------------------------------------------------------------
<File: frontend/src/utils/api.ts>
import { Task, UUID } from './types';

const API_BASE_URL = 'http://localhost:5000/api/v1';

interface ApiResponse<T> {
    success: boolean;
    data?: T;
    error?: {
        code: string;
        message: string;
        details?: any;
    };
    metadata?: {
        timestamp: string;
        requestId: string;
        pagination?: {
            total: number;
            page: number;
            pageSize: number;
            hasMore: boolean;
        };
    };
}

interface UserData {
    tasks: Record<UUID, Task>;
    lastSyncedAt: string;
}

interface SyncRequest {
    changes: Array<{
        type: 'task';
        operation: 'create' | 'update' | 'delete';
        id?: UUID;
        data?: Partial<Task>;
        timestamp: string;
        changeType?: 'text' | 'status' | 'priority' | 'drag';
    }>;
    clientLastSync: string;
}

interface SyncResponse {
    serverChanges?: Array<{
        type: 'task';
        operation: 'create' | 'update' | 'delete';
        id: UUID;
        data?: any;
        timestamp: string;
    }>;
    syncedAt: string;
}

class ApiClient {
    private userId: string = 'temp-user-id'; // TODO: Replace with actual auth

    private async request<T>(
        endpoint: string,
        options: RequestInit = {}
    ): Promise<ApiResponse<T>> {
        const url = `${API_BASE_URL}${endpoint}`;
        const headers = {
            'Content-Type': 'application/json',
            'X-User-ID': this.userId,
            'X-Request-ID': crypto.randomUUID(),
            ...options.headers,
        };

        try {
            const response = await fetch(url, { ...options, headers });
            const data: ApiResponse<T> = await response.json();

            if (!response.ok) {
                throw new Error(data.error?.message || 'An error occurred');
            }

            return data;
        } catch (error) {
            console.error('API request failed:', error);
            throw error;
        }
    }

    async getUserData(): Promise<UserData> {
        const response = await this.request<UserData>('/user-data');
        return response.data!;
    }

    async sync(changes: SyncRequest): Promise<SyncResponse> {
        const response = await this.request<SyncResponse>('/sync', {
            method: 'POST',
            body: JSON.stringify(changes),
        });
        return response.data!;
    }
}

export const api = new ApiClient(); 
--------------------------------------------------------------------------------
<File: frontend/src/utils/displayMappings.ts>
// File: src/utils/displayMappings.ts

/**
 * STATUS_DISPLAY - The user-facing text for each status
 */
export const STATUS_DISPLAY: Record<string, string> = {
    notStarted: 'Not Started',
    workingOnIt: 'Working on It',
    complete: 'Complete',
  };
  
  /**
   * STATUS_COLORS - Pastel backgrounds + darker text
   */
  export const STATUS_COLORS: Record<string, string> = {
    notStarted: 'bg-gray-100 text-gray-800',
    workingOnIt: 'bg-orange-100 text-orange-800',
    complete: 'bg-green-100 text-green-800',
  };
  
  /**
   * getPriorityDisplay - Return { label, colorClass } for each priority numeric range.
   * Example ranges:
   *   80+ -> Very High (bg-red-100 text-red-800)
   *   60+ -> High      (bg-pink-100 text-pink-800)
   *   40+ -> Medium    (bg-yellow-100 text-yellow-800)
   *   20+ -> Low       (bg-green-100 text-green-800)
   *   <20 -> Very Low  (bg-teal-100 text-teal-800)
   */
  export function getPriorityDisplay(priority: number) {
    if (priority >= 80) {
      return { label: 'Very High', colorClass: 'bg-red-100 text-red-800' };
    } else if (priority >= 60) {
      return { label: 'High', colorClass: 'bg-pink-100 text-pink-800' };
    } else if (priority >= 40) {
      return { label: 'Medium', colorClass: 'bg-yellow-100 text-yellow-800' };
    } else if (priority >= 20) {
      return { label: 'Low', colorClass: 'bg-green-100 text-green-800' };
    } else {
      return { label: 'Very Low', colorClass: 'bg-teal-100 text-teal-800' };
    }
  }
  
  /**
   * EFFORT_DISPLAY - Pastel scale from 1..5
   */
  export const EFFORT_DISPLAY: Record<number, { label: string; colorClass: string }> = {
    1: { label: 'Very Low',  colorClass: 'bg-purple-50  text-purple-600' },
    2: { label: 'Low',       colorClass: 'bg-purple-100 text-purple-700' },
    3: { label: 'Medium',    colorClass: 'bg-purple-200 text-purple-800' },
    4: { label: 'High',      colorClass: 'bg-purple-300 text-purple-900' },
    5: { label: 'Very High', colorClass: 'bg-purple-400 text-white'      },
  };
  
  /**
   * getRecurrenceDisplay - Example function to produce user-friendly text
   * (No color classes herejust returns a string.)
   */
  export function getRecurrenceDisplay(
    isRecurring: boolean,
    frequency?: string,
    interval?: number
  ): string {
    if (!isRecurring) return 'None';
    if (!frequency) return 'Recurring (?)';
  
    // e.g., "Every 2 weekly," "Weekly," etc.
    if (interval && interval > 1) {
      return `Every ${interval} ${frequency}`;
    }
    return frequency[0].toUpperCase() + frequency.slice(1); // 'Daily', 'Weekly', etc.
  }
  
--------------------------------------------------------------------------------
<File: frontend/src/utils/types.ts>
// Common Types
export type UUID = string;
export type ISODateString = string;

export type Status = 'notStarted' | 'workingOnIt' | 'complete';
export type RecurrenceFrequency = 'daily' | 'weekly' | 'monthly' | 'yearly';
export type TimeRange = 'day' | 'week' | 'month';
export type ChangeType = 'text' | 'status' | 'priority' | 'drag';

export interface CompletionEntry {
    completedAt: ISODateString;
    nextDueDate?: ISODateString;
    completionNotes?: string;
}

export interface RecurrenceRule {
    frequency: RecurrenceFrequency;
    interval: number;
    endDate?: ISODateString;
    maxOccurrences?: number;
    daysOfWeek?: number[];  // 0-6 for weekly
    dayOfMonth?: number;    // 1-31 for monthly
    months?: number[];      // 1-12 for yearly
    weekOfMonth?: number;   // -1 to 5 (-1 for last)
}

// Task Interface
export interface Task {
    id: UUID;
    userId: UUID;
    type: 'task';
    title: string;
    status: Status;
    priority: number;
    dynamicPriority: number;
    effort?: number;
    notes?: string;
    dueDate?: ISODateString;
    scheduledDate?: ISODateString;
    createdAt: ISODateString;
    updatedAt: ISODateString;
    
    completionHistory: CompletionEntry[];
    
    recurrence?: {
        isRecurring: boolean;
        rule?: RecurrenceRule;
    };
    
    tags?: string[];
}

// Redux State Types
export interface TasksState {
    items: Record<UUID, Task>;
    loading: boolean;
    error: string | null;
}

export interface SyncState {
    status: 'idle' | 'syncing' | 'error';
    lastSynced: string | null;
    pendingChanges: number;
}

export interface LayoutState {
    sidebarCollapsed: boolean;
}

export interface RootState {
    tasks: TasksState;
    sync: SyncState;
    layout: LayoutState;
} 
--------------------------------------------------------------------------------
<File: frontend/src/utils/utils.ts>
import { type ClassValue, clsx } from 'clsx';
import { twMerge } from 'tailwind-merge';

export function cn(...inputs: ClassValue[]) {
    return twMerge(clsx(inputs));
}

--------------------------------------------------------------------------------
<File: frontend/src/vite-env.d.ts>
/// <reference types="vite/client" />

--------------------------------------------------------------------------------
<File: frontend/tailwind.config.js>
/** @type {import('tailwindcss').Config} */
export default {
	darkMode: ["class"],
	content: [
	  './index.html',
	  './src/**/*.{js,ts,jsx,tsx}',
	],
	theme: {
	  container: {
		center: true,
		padding: "2rem",
		screens: {
		  "2xl": "1400px",
		},
	  },
	  extend: {
		colors: {
		  border: "hsl(var(--border))",
		  input: "hsl(var(--input))",
		  ring: "hsl(var(--ring))",
		  background: "hsl(var(--background))",
		  foreground: "hsl(var(--foreground))",
		  primary: {
			DEFAULT: "hsl(var(--primary))",
			foreground: "hsl(var(--primary-foreground))",
		  },
		  secondary: {
			DEFAULT: "hsl(var(--secondary))",
			foreground: "hsl(var(--secondary-foreground))",
		  },
		  destructive: {
			DEFAULT: "hsl(var(--destructive))",
			foreground: "hsl(var(--destructive-foreground))",
		  },
		  muted: {
			DEFAULT: "hsl(var(--muted))",
			foreground: "hsl(var(--muted-foreground))",
		  },
		  accent: {
			DEFAULT: "hsl(var(--accent))",
			foreground: "hsl(var(--accent-foreground))",
		  },
		  popover: {
			DEFAULT: "hsl(var(--popover))",
			foreground: "hsl(var(--popover-foreground))",
		  },
		  card: {
			DEFAULT: "hsl(var(--card))",
			foreground: "hsl(var(--card-foreground))",
		  },
		},
		borderRadius: {
		  lg: "var(--radius)",
		  md: "calc(var(--radius) - 2px)",
		  sm: "calc(var(--radius) - 4px)",
		},
		keyframes: {
		  "accordion-down": {
			from: { height: "0" },
			to: { height: "var(--radix-accordion-content-height)" },
		  },
		  "accordion-up": {
			from: { height: "var(--radix-accordion-content-height)" },
			to: { height: "0" },
		  },
		},
		animation: {
		  "accordion-down": "accordion-down 0.2s ease-out",
		  "accordion-up": "accordion-up 0.2s ease-out",
		},
	  },
	},
	plugins: ["tailwindcss-animate"],
  }
--------------------------------------------------------------------------------
<File: frontend/tsconfig.app.json>
{
  "compilerOptions": {
    "incremental": true,
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["src"]
}

--------------------------------------------------------------------------------
<File: frontend/tsconfig.json>
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,

    /* Path Aliases */
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}

--------------------------------------------------------------------------------
<File: frontend/tsconfig.node.json>
{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true
  },
  "include": ["vite.config.ts"]
}

--------------------------------------------------------------------------------
<File: frontend/vite.config.ts>
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import { fileURLToPath } from 'url'
import { dirname, resolve } from 'path'

const __filename = fileURLToPath(import.meta.url)
const __dirname = dirname(__filename)

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      "@": resolve(__dirname, "./src"),
    },
  },
})

--------------------------------------------------------------------------------
<File: README.md>
# tbd

--------------------------------------------------------------------------------

<end codebase> 

