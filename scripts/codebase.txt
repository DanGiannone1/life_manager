Here is my codebase:

<File: backend/app.py>
from flask import Flask, request, jsonify, make_response
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address
from flask_cors import CORS
from datetime import datetime, timezone
from typing import Dict, Any, List, Optional, TypedDict, Union
import os
import uuid
from dotenv import load_dotenv
from cosmos_db import CosmosDBManager
import humps
import traceback

# Load environment variables
load_dotenv()

# Initialize Flask app
app = Flask(__name__)
CORS(app)  # Enable CORS for all routes

# Initialize rate limiter
limiter = Limiter(
    app=app,
    key_func=get_remote_address,
    default_limits=["600 per day", "150 per hour"]
)

# Initialize CosmosDB manager
cosmos_db = CosmosDBManager()

class ApiResponse(TypedDict):
    success: bool
    data: Optional[Dict[str, Any]]
    error: Optional[Dict[str, Any]]
    metadata: Optional[Dict[str, Any]]

def create_api_response(
    success: bool,
    data: Optional[Dict[str, Any]] = None,
    error: Optional[Dict[str, Any]] = None,
    metadata: Optional[Dict[str, Any]] = None
) -> ApiResponse:
    """Create a standardized API response following the design document format."""
    response: ApiResponse = {
        "success": success,
        "data": data,
        "error": error,
        "metadata": {
            "timestamp": datetime.now(timezone.utc).isoformat(),
            "requestId": request.headers.get("X-Request-ID", ""),
            **(metadata or {})
        }
    }
    return response

def add_rate_limit_headers(response):
    """Add rate limit headers to the response."""
    if hasattr(request, "view_rate_limit"):
        window_stats = getattr(request, "view_rate_limit")
        response.headers.add(
            "X-RateLimit-Limit",
            str(window_stats.limit)
        )
        response.headers.add(
            "X-RateLimit-Remaining",
            str(window_stats.remaining)
        )
        response.headers.add(
            "X-RateLimit-Reset",
            str(window_stats.reset)
        )
    return response

# Fields that need case conversion for their values
CASE_CONVERTIBLE_FIELDS = ["status"]  # Add more fields here as needed

def convert_case(value: str, to_camel: bool) -> str:
    """Convert a string between snake_case and camelCase."""
    if to_camel:
        return humps.camelize(value)
    return humps.decamelize(value)

def convert_enum_values(data: Union[Dict, List], is_snake_to_camel: bool) -> Union[Dict, List]:
    """Convert enumerated values between snake_case and camelCase."""
    if isinstance(data, list):
        return [convert_enum_values(item, is_snake_to_camel) for item in data]
    
    if not isinstance(data, dict):
        return data
    
    result = {}
    for key, value in data.items():
        if isinstance(value, (dict, list)):
            value = convert_enum_values(value, is_snake_to_camel)
        elif isinstance(value, str) and key in CASE_CONVERTIBLE_FIELDS:
            value = convert_case(value, is_snake_to_camel)
        result[key] = value
    return result

def snake_to_camel(data: Union[Dict, List]) -> Union[Dict, List]:
    """Convert snake_case keys to camelCase and convert enumerated values."""
    # First convert the enum values
    data = convert_enum_values(data, is_snake_to_camel=True)
    # Then convert the keys
    return humps.camelize(data)

def camel_to_snake(data: Union[Dict, List]) -> Union[Dict, List]:
    """Convert camelCase keys to snake_case and convert enumerated values."""
    # First convert the keys
    data = humps.decamelize(data)
    # Then convert the enum values
    return convert_enum_values(data, is_snake_to_camel=False)

@app.errorhandler(Exception)
def handle_error(error: Exception) -> tuple[Dict[str, Any], int]:
    """Global error handler to ensure consistent error responses."""
    if hasattr(error, "code") and hasattr(error, "description"):
        # Handle Flask/HTTP errors
        status_code = error.code
        error_message = error.description
    else:
        # Handle other exceptions
        status_code = 500
        error_message = str(error)

    app.logger.error(f"Error: {error}")
    app.logger.error(traceback.format_exc())

    response = create_api_response(
        success=False,
        error={
            "code": status_code,
            "message": error_message
        }
    )
    return jsonify(response), status_code

@app.route("/api/v1/user-data", methods=["GET"])
@limiter.limit("180 per hour")
def get_user_data():
    """
    Get all data for a user (tasks, goals, categories, dashboard).
    Rate limit: 180 requests per hour
    """
    try:
        # Get user_id from auth token (placeholder - implement actual auth)
        user_id = request.headers.get("X-User-ID")
        user_id = "test-user"
        print("Fetching user data for user_id:", user_id)
        if not user_id:
            raise ValueError("User ID is required")

        # Get all user data using the new get_user_data method
        user_data = cosmos_db.get_user_data(user_id)

        # Convert to camelCase for frontend
        response_data = {
            "tasks": snake_to_camel(user_data["tasks"]),
            "goals": snake_to_camel(user_data["goals"]),
            "categories": snake_to_camel(user_data["categories"]),
            "dashboard": snake_to_camel(user_data["dashboard"]) if user_data["dashboard"] else None,
            "lastSyncedAt": datetime.now(timezone.utc).isoformat()
        }

        response = make_response(jsonify(create_api_response(success=True, data=response_data)))
        return add_rate_limit_headers(response)

    except Exception as e:
        raise

@app.route("/api/v1/sync", methods=["POST"])
@limiter.limit("360 per minute")
def sync_changes():
    """
    Sync changes between frontend and backend.
    Rate limit: 360 requests per minute
    """
    try:
        # Get user_id from auth token (placeholder - implement actual auth)
        user_id = request.headers.get("X-User-ID")
        user_id = "test-user"
        if not user_id:
            raise ValueError("User ID is required")

        # Get request data
        data = request.get_json()
        if not data:
            raise ValueError("Request body is required")

        changes = data.get("changes", [])
        client_last_sync = data.get("clientLastSync")

        if not client_last_sync:
            raise ValueError("clientLastSync is required")

        # Process each change
        server_changes = []
        has_errors = False

        for change in changes:
            change_type = change.get("type")
            operation = change.get("operation")
            item_id = change.get("id")
            item_data = camel_to_snake(change.get("data", {}))

            if item_data:
                item_data["user_id"] = user_id
                item_data["type"] = change_type
                item_data["updated_at"] = datetime.now(timezone.utc).isoformat()

            try:
                if operation == "create":
                    if not item_data:
                        raise ValueError("Data is required for create operation")
                    item_data["id"] = item_id or str(uuid.uuid4())
                    result = cosmos_db.create_item(item_data)
                    if result:
                        server_changes.append({
                            "type": change_type,
                            "operation": "create",
                            "id": result["id"],
                            "data": snake_to_camel(result),
                            "timestamp": result["updated_at"]
                        })

                elif operation == "update":
                    if not item_id:
                        raise ValueError("Item ID is required for update operation")
                    result = cosmos_db.update_item(item_id, item_data)
                    if result:
                        server_changes.append({
                            "type": change_type,
                            "operation": "update",
                            "id": result["id"],
                            "data": snake_to_camel(result),
                            "timestamp": result["updated_at"]
                        })

                elif operation == "delete":
                    if not item_id:
                        raise ValueError("Item ID is required for delete operation")
                    if cosmos_db.delete_item(item_id, user_id):
                        server_changes.append({
                            "type": change_type,
                            "operation": "delete",
                            "id": item_id,
                            "timestamp": datetime.now(timezone.utc).isoformat()
                        })

            except Exception as operation_error:
                app.logger.error(f"Error processing change: {operation_error}")
                app.logger.error(traceback.format_exc())
                has_errors = True
                error_response = create_api_response(
                    success=False,
                    error=str(operation_error),
                    data={"serverChanges": server_changes}
                )
                response = make_response(jsonify(error_response), 500)
                return add_rate_limit_headers(response)

        # Only proceed with server changes if no errors occurred
        if not has_errors:
            # Get any server-side changes newer than client_last_sync
            server_items = cosmos_db.get_changes_since(user_id, client_last_sync)

            # Add server items to server_changes if they're not already included
            processed_ids = {change["id"] for change in server_changes}
            for item in server_items:
                if item["id"] not in processed_ids:
                    server_changes.append({
                        "type": item["type"],
                        "operation": "update",
                        "id": item["id"],
                        "data": snake_to_camel(item),
                        "timestamp": item["updated_at"]
                    })

            response_data = {
                "serverChanges": server_changes,
                "syncedAt": datetime.now(timezone.utc).isoformat()
            }

            response = make_response(jsonify(create_api_response(success=True, data=response_data)))
            return add_rate_limit_headers(response)

    except Exception as e:
        app.logger.error(f"Unexpected error in sync: {e}")
        app.logger.error(traceback.format_exc())
        error_response = create_api_response(success=False, error=str(e))
        response = make_response(jsonify(error_response), 500)
        return add_rate_limit_headers(response)

if __name__ == "__main__":
    app.run(debug=True)

--------------------------------------------------------------------------------
<File: backend/cosmos_db.py>
# File: backend/cosmos_db.py

import os
from typing import List, Dict, Any, Optional
from dotenv import load_dotenv
from azure.cosmos import CosmosClient, exceptions, PartitionKey
from azure.cosmos.container import ContainerProxy
from azure.cosmos.database import DatabaseProxy
from azure.identity import DefaultAzureCredential
from datetime import datetime, timezone, timedelta
import traceback

class CosmosDBManager:
    def __init__(self, cosmos_host=None, cosmos_database_id=None, cosmos_container_id=None):
        self._load_env_variables(cosmos_host, cosmos_database_id, cosmos_container_id)
        self.client = self._get_cosmos_client()
        self.database: Optional[DatabaseProxy] = None
        self.container: Optional[ContainerProxy] = None
        self._initialize_database_and_container()

    def _load_env_variables(self, cosmos_host=None, cosmos_database_id=None, cosmos_container_id=None):
        load_dotenv()
        self.cosmos_host = cosmos_host or os.environ.get("COSMOS_HOST")
        self.cosmos_database_id = cosmos_database_id or os.environ.get("COSMOS_DATABASE_ID")
        self.cosmos_container_id = cosmos_container_id or os.environ.get("COSMOS_CONTAINER_ID")
        self.tenant_id = os.environ.get("TENANT_ID", '16b3c013-d300-468d-ac64-7eda0820b6d3')

        if not all([self.cosmos_host, self.cosmos_database_id, self.cosmos_container_id]):
            raise ValueError("Cosmos DB configuration is incomplete")

    def _get_cosmos_client(self) -> CosmosClient:
        print("Initializing Cosmos DB client")
        print("Using DefaultAzureCredential for Cosmos DB authentication")
        credential = DefaultAzureCredential(
            interactive_browser_tenant_id=self.tenant_id,
            visual_studio_code_tenant_id=self.tenant_id,
            workload_identity_tenant_id=self.tenant_id,
            shared_cache_tenant_id=self.tenant_id
        )
        return CosmosClient(self.cosmos_host, credential=credential)

    def _initialize_database_and_container(self) -> None:
        try:
            self.database = self._create_or_get_database()
            self.container = self._create_or_get_container()
        except exceptions.CosmosHttpResponseError as e:
            print(f'An error occurred: {e.message}')
            raise

    def _create_or_get_database(self) -> DatabaseProxy:
        try:
            database = self.client.create_database(id=self.cosmos_database_id)
            print(f'Database with id \'{self.cosmos_database_id}\' created')
        except exceptions.CosmosResourceExistsError:
            database = self.client.get_database_client(self.cosmos_database_id)
            print(f'Database with id \'{self.cosmos_database_id}\' was found')
        return database

    def _create_or_get_container(self) -> ContainerProxy:
        try:
            container = self.database.create_container(
                id=self.cosmos_container_id, 
                partition_key=PartitionKey(path='/user_id')
            )
            print(f'Container with id \'{self.cosmos_container_id}\' created')
        except exceptions.CosmosResourceExistsError:
            container = self.database.get_container_client(self.cosmos_container_id)
            print(f'Container with id \'{self.cosmos_container_id}\' was found')
        return container

    # Core CRUD Operations
    def get_item_by_id(self, item_id: str, user_id: str) -> Optional[Dict[str, Any]]:
        """Get a single item by its ID and user_id (partition key)."""
        try:
            item = self.container.read_item(item=item_id, partition_key=user_id)
            return item
        except exceptions.CosmosResourceNotFoundError:
            return None
        except Exception as e:
            print(f"Error retrieving item {item_id}: {str(e)}")
            raise

    def create_item(self, item: Dict[str, Any]) -> Dict[str, Any]:
        """Create a new item in the container."""
        try:
            if 'user_id' not in item:
                raise ValueError("user_id (partition key) is required for create operation")
            
            # Ensure timestamps are set
            current_time = datetime.now(timezone.utc).isoformat()
            item['created_at'] = current_time
            item['updated_at'] = current_time
            
            created_item = self.container.create_item(body=item)
            print(f"Item created with id: {created_item['id']}")
            return created_item
        except exceptions.CosmosResourceExistsError:
            print(f"Item with id {item.get('id')} already exists")
            raise
        except Exception as e:
            print(f"Error creating item: {str(e)}")
            raise

    def update_item(self, item_id: str, updates: Dict[str, Any]) -> Dict[str, Any]:
        """Update an existing item with new values."""
        try:
            # Get the existing item
            existing_item = self.get_item_by_id(item_id, updates['user_id'])
            if not existing_item:
                raise ValueError(f"Item with id {item_id} not found")

            # Update the item with new values
            existing_item.update(updates)
            existing_item['updated_at'] = datetime.now(timezone.utc).isoformat()

            # Replace the item in the container
            updated_item = self.container.replace_item(
                item=item_id,
                body=existing_item
            )
            return updated_item
        except Exception as e:
            print(f"Error updating item {item_id}: {str(e)}")
            raise

    def delete_item(self, item_id: str, user_id: str) -> bool:
        """Delete an item by its ID."""
        try:
            self.container.delete_item(item=item_id, partition_key=user_id)
            return True
        except exceptions.CosmosResourceNotFoundError:
            return False
        except Exception as e:
            print(f"Error deleting item {item_id}: {str(e)}")
            raise

    def get_user_data(self, user_id: str) -> Dict[str, List[Dict[str, Any]]]:
        """Get all data for a user (tasks, goals, categories, dashboard)."""
        try:
            query = """
            SELECT * FROM c 
            WHERE c.user_id = @user_id
            """
            items = list(self.container.query_items(
                query=query,
                parameters=[{"name": "@user_id", "value": user_id}],
                enable_cross_partition_query=False
            ))

            # Organize items by type
            result = {
                "tasks": [],
                "goals": [],
                "categories": [],
                "dashboard": None
            }

            for item in items:
                item_type = item.get("type")
                if item_type == "task":
                    result["tasks"].append(item)
                elif item_type == "goal":
                    result["goals"].append(item)
                elif item_type == "category":
                    result["categories"].append(item)
                elif item_type == "dashboard":
                    result["dashboard"] = item

            return result
        except Exception as e:
            print(f"Error getting user data: {str(e)}")
            raise

    def get_changes_since(self, user_id: str, since_timestamp: str) -> List[Dict[str, Any]]:
        """Get all items that have been updated since a given timestamp."""
        try:
            query = """
            SELECT * FROM c 
            WHERE c.user_id = @user_id 
            AND c.updated_at > @since_timestamp
            """
            items = list(self.container.query_items(
                query=query,
                parameters=[
                    {"name": "@user_id", "value": user_id},
                    {"name": "@since_timestamp", "value": since_timestamp}
                ],
                enable_cross_partition_query=False
            ))
            return items
        except Exception as e:
            print(f"Error getting changes since timestamp: {str(e)}")
            raise



--------------------------------------------------------------------------------
<File: backend/testing.py>

from cosmos_db import CosmosDBManager
from datetime import datetime, timedelta, timezone
import uuid

def cleanup_test_data(cosmos_manager: CosmosDBManager, user_id: str):
    """Delete all existing documents for the test user"""
    try:
        # Query for all items belonging to this user
        query = "SELECT * FROM c WHERE c.user_id = @user_id"
        items = list(cosmos_manager.container.query_items(
            query=query,
            parameters=[{"name": "@user_id", "value": user_id}],
            enable_cross_partition_query=False
        ))
        
        # Delete each item
        for item in items:
            cosmos_manager.delete_item(item['id'], user_id)
            print(f"Deleted existing item: {item['id']}")
        
        print(f"Cleaned up {len(items)} existing items for user {user_id}")
    except Exception as e:
        print(f"Error during cleanup: {str(e)}")
        raise

def create_iso_date(days_from_now=0):
    """Create ISO formatted date string for a date N days from now"""
    date = datetime.now(timezone.utc) + timedelta(days=days_from_now)
    return date.isoformat()

def generate_sample_tasks():
    """Generate 5 sample tasks with different characteristics"""
    test_user_id = "test-user"
    
    tasks = [
        {
            "id": str(uuid.uuid4()),
            "user_id": test_user_id,
            "type": "task",
            
            "title": "Daily Exercise Routine",
            "status": "not_started",
            "priority": 80,
            "dynamic_priority": 85,
            "effort": 3,
            "notes": "30 minutes of cardio followed by strength training",
            "due_date": create_iso_date(1),
            "scheduled_date": create_iso_date(1),
            "completion_history": [],
            "recurrence": {
                "is_recurring": True,
                "rule": {
                    "frequency": "daily",
                    "interval": 1,
                    "days_of_week": [0, 1, 2, 3, 4]  # Weekdays only
                }
            }
        },
        {
            "id": str(uuid.uuid4()),
            "user_id": test_user_id,
            "type": "task",
            
            "title": "Quarterly Financial Review",
            "status": "working_on_it",
            "priority": 90,
            "dynamic_priority": 95,
            "effort": 5,
            "notes": "Review Q1 financial statements and prepare report",
            "due_date": create_iso_date(14),
            "scheduled_date": None,
            "completion_history": [],
            "recurrence": {
                "is_recurring": False,
                "rule": None
            }
        },
        {
            "id": str(uuid.uuid4()),
            "user_id": test_user_id,
            "type": "task",
            
            "title": "Weekly Team Meeting",
            "status": "not_started",
            "priority": 70,
            "dynamic_priority": 70,
            "effort": 2,
            "notes": None,
            "due_date": None,
            "scheduled_date": create_iso_date(7),
            "completion_history": [],
            "recurrence": {
                "is_recurring": True,
                "rule": {
                    "frequency": "weekly",
                    "interval": 1,
                    "days_of_week": [1],  # Monday
                    "day_of_month": None,
                    "months": None,
                    "week_of_month": None
                }
            }
        },
        {
            "id": str(uuid.uuid4()),
            "user_id": test_user_id,
            "type": "task",
            
            "title": "Read 'Deep Work' Book",
            "status": "working_on_it",
            "priority": 40,
            "dynamic_priority": 45,
            "effort": 3,
            "notes": "Complete chapters 4-6",
            "due_date": create_iso_date(30),
            "scheduled_date": None,
            "completion_history": [],
            "recurrence": {
                "is_recurring": False,
                "rule": None
            }
        },
        {
            "id": str(uuid.uuid4()),
            "user_id": test_user_id,
            "type": "task",
            
            "title": "Update Personal Website",
            "status": "complete",
            "priority": 60,
            "dynamic_priority": 0,  # Completed tasks have 0 dynamic priority
            "effort": 4,
            "notes": "Refresh portfolio and add recent projects",
            "due_date": create_iso_date(-2),
            "scheduled_date": None,
            "completion_history": [{
                "completed_at": create_iso_date(-1),
                "next_due_date": None,
                "completion_notes": "Added three new projects and updated bio"
            }],
            "recurrence": {
                "is_recurring": False,
                "rule": None
            }
        }
    ]
    
    return tasks

def main():
    try:
        # Initialize the CosmosDB manager
        cosmos_manager = CosmosDBManager()
        
        # Clean up any existing test data
        print("\nCleaning up existing test data...")
        cleanup_test_data(cosmos_manager, "test-user")
        
        print("\nGenerating and loading new test data...")
        # Generate sample tasks
        tasks = generate_sample_tasks()
        
        # Create each task in Cosmos DB
        created_tasks = []
        for task in tasks:
            try:
                # Note: create_item will automatically add created_at and updated_at
                created_task = cosmos_manager.create_item(task)
                created_tasks.append(created_task)
                print(f"Created task: {created_task['title']}")
            except Exception as e:
                print(f"Error creating task '{task['title']}': {str(e)}")
        
        # Verify the data was loaded
        user_data = cosmos_manager.get_user_data("test-user")
        print(f"\nSuccessfully loaded {len(user_data['tasks'])} tasks for test-user")
        
        # Print sample verification data
        if created_tasks:
            sample_task = created_tasks[0]
            print("\nSample task verification:")
            print(f"ID: {sample_task['id']}")
            print(f"Created At: {sample_task['created_at']}")
            print(f"Updated At: {sample_task['updated_at']}")
            print(f"Title: {sample_task['title']}")
            print(f"Status: {sample_task['status']}")
        
    except Exception as e:
        print(f"Error in main: {str(e)}")

if __name__ == "__main__":
    main()
--------------------------------------------------------------------------------
<File: docs/design_document.md>
# Life Manager Design Document

## Table of Contents

1. [Core Architecture](#core-architecture)
   - [Technology Stack](#technology-stack)
   - [State Management](#state-management)
   - [Data Flow & Sync Strategy](#data-flow--sync-strategy)

2. [Data Models](#data-models)
   - [Frontend Data Models (TypeScript)](#frontend-data-models-typescript)
     - [Interface Usage Guidelines](#interface-usage-guidelines)
     - [Common Types](#common-types)
     - [Task Interface](#task-interface)
   - [Backend Data Models (CosmosDB)](#backend-data-models-cosmosdb)
     - [Container Strategy & Querying](#container-strategy--querying)
     - [Indexing Strategy](#indexing-strategy)
     - [Document Models](#document-models)

3. [APIs](#apis)
   - [Base URL](#base-url)
   - [Common Response Format](#common-response-format)
   - [Error Codes](#error-codes)
   - [Core Endpoints](#core-endpoints)

4. [Logging](#logging)
   - [Initial Load](#initial-load)
   - [State Changes](#state-changes)
   - [Backend Sync Operations](#backend-sync-operations)

5. [Features & Implementation](#features--implementation)
   - [Sidebar & Top Panel](#sidebar--top-panel)
   - [Home Page](#home-page)
   - [Weekly Plan Page](#weekly-plan-page)
   - [Master List Page](#master-list-page)
   
6. [Styling & UI](#styling--ui)
    - [High-Level Strategy](#high-level-strategy)
    - [Layout Architecture](#layout-architecture)
    - [Design Tokens](#design-tokens)
    - [Interactive Elements](#interactive-elements)
    - [Component Architecture](#component-architecture)





## Core Architecture

### Technology Stack
- Frontend: React/Vite, TailwindCSS, Shadcn Components, Redux Toolkit
- Backend: Python, Flask
- Database: CosmosDB

### State Management

#### Global State (Redux)
All persistent data lives in Redux, serving as the single source of truth for the application. This includes:

1. **User Data**
   - Tasks

2. **Application State**
   - Sync status (success, error)
   - Last sync timestamp

3. **Store Structure**
```typescript
interface RootState {
    tasks: {
        items: Record<UUID, Task>;
        loading: boolean;
        error: string | null;
    };
    sync: {
        status: 'idle' | 'syncing' | 'error';
        lastSynced: string | null;
        pendingChanges: number;
    };
}
```

#### Local State
Used only for temporary UI states within components:
- Form input values before submission
- Modal/dropdown open/closed states
- Component-specific loading states
- Any temporary data that doesn't need to persist

### Data Flow & Sync Strategy

#### User Login / Initial Load
```mermaid
flowchart LR
    DB[(CosmosDB)] --> 
    API[(/api/v1/user-data)] --> 
    Store[(Redux Store)] --> 
    UI[Application UI]

    classDef storeNode fill:#FF8C00,stroke:#333,stroke-width:2px,color:white
    classDef apiNode fill:#50C878,stroke:#333,stroke-width:2px,color:white
    classDef dbNode fill:#FF69B4,stroke:#333,stroke-width:2px,color:white
    classDef uiNode fill:#9370DB,stroke:#333,stroke-width:2px,color:white

    class Store storeNode
    class API apiNode
    class DB dbNode
    class UI uiNode
```



#### User Interactions
```mermaid
flowchart LR
    Actions[User Actions] -->
    Store[(Redux Store)] -->
    UI[Application UI]
    Store -.->|Debounced Sync| API[(/api/v1/user-data)] -->
    DB[(CosmosDB)]

    classDef storeNode fill:#FF8C00,stroke:#333,stroke-width:2px,color:white
    classDef apiNode fill:#50C878,stroke:#333,stroke-width:2px,color:white
    classDef actionNode fill:#4169E1,stroke:#333,stroke-width:1px,color:white
    classDef dbNode fill:#FF69B4,stroke:#333,stroke-width:2px,color:white
    classDef uiNode fill:#9370DB,stroke:#333,stroke-width:2px,color:white

    class Store storeNode
    class API apiNode
    class Actions actionNode
    class DB dbNode
    class UI uiNode
```


#### 1. Initial Load
```
// In the application's root component (e.g., _app.tsx)
// On initial load:
// 1. Dispatch a loading action to set the application state to loading.
// 2. Call the API to fetch initial user data.
// 3. On successful data fetch:
//    - Dispatch an action to initialize the Redux store with the fetched data.
// 4. On error:
//    - Dispatch an action to set the error state with the error message.
// 5. Finally:
//    - Dispatch a loading action to set the application state to not loading.
```

#### 2. State Updates
```
// The useStateSync hook provides a consistent way to handle state updates.
// It takes a change type (e.g., 'text', 'status', 'priority', 'drag') and an item with changes.
// 1. On change:
//    - Dispatch a Redux action to immediately update the store with the changes.
//      This dispatch triggers a Redux reducer that updates the state.
//    - Trigger a debounced backend sync operation based on the change type.
// The hook returns a handleChange function that components can use to update state.
// The SYNC_CONFIG object defines the debounce time for each change type.
```

#### 3. Component Integration
```
// All components use the same state management pattern to handle data modifications.
// For example, a TaskCard component:
// 1. Uses the handleChange function from useStateSync.
// 2. When the task title input changes:
//    - Calls handleChange with the 'text' change type, the task object, and the new title.
// 3. When the task status changes:
//    - Calls handleChange with the 'status' change type, the task object, and the new status and updated status history.
```

#### 4. Sync Status Management
```
// The SyncIndicator component provides visual feedback on the sync status.
// 1. It uses a Redux selector to get the current sync state.
// 2. If the sync status is 'syncing', it displays a spinner.
// 3. If the sync status is 'error', it displays an error icon.
//    The error icon will be displayed during retry attempts and after all retries have failed.
// 4. If the sync status is 'idle' and there is a last synced timestamp, it displays the last saved time.
```

#### 5. Error Handling
```
// The handleSyncError function handles failed sync operations.
// 1. It takes an error object and an optional retry attempt counter.
// 2. If the retry attempt is less than the maximum number of retries:
//    - It waits for an exponentially increasing amount of time.
//    - It calls the performSync function to retry the sync operation.
// 3. If the maximum number of retries is reached:
//    - It dispatches an action to set the sync error state with the error message.
```


This architecture provides:
- Single source of truth in Redux
- Consistent state update pattern
- Optimistic updates with backend sync
- Clear sync status feedback
- Automatic error handling and retries
- Simple component integration

## Data Models

### Frontend Data Models (TypeScript)

#### Interface Usage Guidelines

1. **Strict Type Adherence**
   - All frontend components must strictly implement these interfaces
   - No extending interfaces without documentation and team review
   - No bypassing optional fields with type assertions (`!` or `as`)
   - All interface extensions must be backwards compatible

2. **State Management**
   - Redux store must maintain normalized data matching these interfaces
   - All API responses must be validated against these interfaces
   - No storing derived data that can be computed from interface fields
   - Use selectors for computing derived data

3. **Component Props**
   - Components should accept the smallest necessary subset of interfaces
   - Use TypeScript utility types to create precise prop interfaces:
     ```typescript
     // Good
     interface TaskTitleProps {
         task: Pick<Task, 'id' | 'title'>;
     }

     // Avoid
     interface TaskTitleProps {
         task: Task;  // Exposes unnecessary fields
     }
     ```
   - Document required vs optional props

4. **Modification Rules**
   - Interface changes require documentation update
   - Breaking changes must be versioned
   - Additions to interfaces must be optional fields
   - Update all relevant type definitions when modifying interfaces

#### Common Types
```typescript
type UUID = string;
type ISODateString = string;

type Status = 'notStarted' | 'workingOnIt' | 'complete';
type RecurrenceFrequency = 'daily' | 'weekly' | 'monthly' | 'yearly';
type TimeRange = 'day' | 'week' | 'month';

interface CompletionEntry {
    completedAt: ISODateString;
    nextDueDate?: ISODateString;
    completionNotes?: string;
}

interface RecurrenceRule {
    frequency: RecurrenceFrequency;
    interval: number;
    endDate?: ISODateString;
    maxOccurrences?: number;
    daysOfWeek?: number[];  // 0-6 for weekly
    dayOfMonth?: number;    // 1-31 for monthly
    months?: number[];      // 1-12 for yearly
    weekOfMonth?: number;   // -1 to 5 (-1 for last)
}
```

#### Task Interface
```typescript
interface Task {
    id: UUID;
    userId: UUID;
    type: 'task';
    title: string;
    status: Status;
    priority: number;
    dynamicPriority: number;
    effort?: number;
    notes?: string;
    dueDate?: ISODateString;
    scheduledDate?: ISODateString;
    createdAt: ISODateString;
    updatedAt: ISODateString;
    
    completionHistory: CompletionEntry[];
    
    recurrence?: {
        isRecurring: boolean;
        rule?: RecurrenceRule;
    };
    
    tags?: string[];
}
```

### Display Mappings

#### Status Display Mapping
```typescript
const STATUS_DISPLAY = {
    notStarted: 'Not Started',
    workingOnIt: 'Working on It',
    complete: 'Complete'
};

const STATUS_COLORS = {
    notStarted: 'gray.500',
    workingOnIt: 'yellow.500',
    complete: 'green.500'
};
```

#### Priority Display Mapping
```typescript
const PRIORITY_DISPLAY = {
    ranges: [
        { min: 80, label: 'Very High', color: 'red.500' },
        { min: 60, label: 'High', color: 'orange.500' },
        { min: 40, label: 'Medium', color: 'yellow.500' },
        { min: 20, label: 'Low', color: 'green.500' },
        { min: 0, label: 'Very Low', color: 'green.250' }
    ]
};
```

#### Effort Display Mapping
```typescript
const EFFORT_DISPLAY = {
    1: {
        label: 'Very Low',
        color: 'green.300'  // Light green for minimal effort
    },
    2: {
        label: 'Low',
        color: 'green.500'  // Medium green for low effort
    },
    3: {
        label: 'Medium',
        color: 'yellow.500'  // Yellow for moderate effort
    },
    4: {
        label: 'High',
        color: 'orange.500'  // Orange for high effort
    },
    5: {
        label: 'Very High',
        color: 'red.500'  // Red for maximum effort
    }
};
```

#### Time Range Display Mapping
```typescript
const TIME_RANGE_DISPLAY = {
    day: 'Daily',
    week: 'Weekly',
    month: 'Monthly'
};
```

### Backend Data Models (CosmosDB)

All variable names are in snake_case. All documents are stored in a single container to enable efficient querying of a user's complete data set.
The frontend uses camelCase for its data models. A manual conversion process is used to handle the differences in naming conventions during API requests and responses.

#### Case Conversion Functions

All data transformations between the backend's `snake_case` data models and the frontend's `camelCase` data models are handled on the backend. This ensures that the frontend receives data in the expected format without needing to perform any conversion logic.

The backend uses two types of case conversion:

1. **Key Case Conversion**: All object keys are converted between snake_case and camelCase.
   ```python
   # Example key conversion:
   "user_id" <-> "userId"
   "created_at" <-> "createdAt"
   "due_date" <-> "dueDate"
   ```

2. **Value Case Conversion**: Certain enumerated string values are also converted between cases.
   ```python
   # Fields that need value case conversion:
   CASE_CONVERTIBLE_FIELDS = ["status"]  # Add more fields as needed

   # Example value conversion for status:
   "not_started" <-> "notStarted"
   "working_on_it" <-> "workingOnIt"
   ```

The conversion process:
1. For frontend responses (snake_to_camel):
   - First converts enumerated values to camelCase
   - Then converts all keys to camelCase

2. For backend storage (camel_to_snake):
   - First converts all keys to snake_case
   - Then converts enumerated values to snake_case

This approach:
- Centralizes the transformation logic
- Makes it easy to add new fields that need value conversion
- Ensures consistency across all API responses
- Simplifies frontend code by removing the need for any data conversion logic
- Makes debugging easier with explicit string manipulation

#### Container Strategy & Querying
The application uses a single container strategy where:
- All task documents live in one container
- Documents are partitioned by `user_id`
- The `type` field enables filtering within a user's partition
- Single query can efficiently retrieve all data for a user

Example query to get all user data:
```sql
SELECT * FROM c
WHERE c.user_id = @userId
```

#### Indexing Strategy
The container uses these indexes to optimize common query patterns:
```json
{
    "indexingPolicy": {
        "includedPaths": [
            {
                "path": "/user_id/?",
                "indexes": [
                    {
                        "kind": "Range",
                        "dataType": "String"
                    }
                ]
            },
            {
                "path": "/type/?",
                "indexes": [
                    {
                        "kind": "Range",
                        "dataType": "String"
                    }
                ]
            },
            {
                "path": "/updated_at/?",
                "indexes": [
                    {
                        "kind": "Range",
                        "dataType": "String"
                    }
                ]
            }
        ]
    }
}
```

#### Document Models

##### Task Document
```json
{
    // Metadata
    "id": "string (UUID)",
    "user_id": "string (UUID)",
    "type": "task",
    "partition_key": "string (user_id)",
    
    // Core Fields
    "title": "string",
    "status": "string (enum: not_started, working_on_it, complete)",
    "priority": "number (0-100)",
    "dynamic_priority": "number (0-100)",
    "effort": "number (1-5, optional)",
    "notes": "string (optional)",
    
    // Dates
    "due_date": "string (ISO date, optional)",
    "scheduled_date": "string (ISO date, optional)",
    "created_at": "string (ISO date)",
    "updated_at": "string (ISO date)",
    
    "completion_history": [
        {
            "completed_at": "string (ISO date)",
            "next_due_date": "string (ISO date, optional)",
            "completion_notes": "string (optional)"
        }
    ],
    

    // Recurrence
    "recurrence": {
        "is_recurring": "boolean",
        "rule": {
            "frequency": "string (enum: daily, weekly, monthly, yearly)",
            "interval": "number",
            "days_of_week": "number[] (0-6, optional)",
            "day_of_month": "number (1-31, optional)",
            "months": "number[] (1-12, optional)",
            "week_of_month": "number (-1 to 5, optional)"
        }
    }

}
```

## APIs

### Base URL
```
https://api.lifemanager.app/v1
```

### Common Response Format
All API responses follow a consistent format:

```typescript
interface ApiResponse<T> {
    success: boolean;
    data?: T;
    error?: {
        code: string;
        message: string;
        details?: any;
    };
    metadata?: {
        timestamp: string;
        requestId: string;
        pagination?: {
            total: number;
            page: number;
            pageSize: number;
            hasMore: boolean;
        };
    };
}
```

### Error Codes
Standard HTTP status codes are used along with custom error codes.
The API response will include the HTTP status code and the custom error code in the error object.

| HTTP Status | Error Code | Description |
|------------|------------|-------------|
| 400 | INVALID_REQUEST | Malformed request or invalid parameters |
| 404 | NOT_FOUND | Resource not found |
| 409 | CONFLICT | Resource conflict (e.g., duplicate) |
| 422 | VALIDATION_ERROR | Request validation failed |
| 500 | INTERNAL_ERROR | Server error |
| 503 | SERVICE_UNAVAILABLE | Service temporarily unavailable |

### Core Endpoints

#### Initial Data Load
```http
GET /api/v1/user-data
Description: Loads all user data at application startup. This is the only bulk data fetch operation.

Response: {
    success: true,
    data: {
        tasks: Record<UUID, Task>;
        lastSyncedAt: string; // ISO date
    }
}
```

#### Sync Changes
```http
POST /api/v1/sync
Description: Debounced endpoint that receives changes from the frontend. Called automatically after user actions with configured debounce times per change type.

Request Body: {
    changes: Array<{
        type: 'task';
        operation: 'create' | 'update' | 'delete';
        id?: UUID;  // Required for update/delete
        data?: Partial<Task>;  // Required for create/update
        timestamp: string;  // ISO date of when change occurred
        changeType?: 'text' | 'status' | 'priority' | 'drag';  // For debounce configuration
    }>;
    clientLastSync: string;  // ISO date of last successful sync
}

Response: {
    success: true,
    data: {
        // Only sent if server has newer changes
        serverChanges?: Array<{
            type: 'task';
            operation: 'create' | 'update' | 'delete';
            id: UUID;
            data?: any;
            timestamp: string;
        }>;
        syncedAt: string;  // ISO date of this sync
    }
}
```

###  Logging

#### Initial Load
On application load, the entire Redux state is logged to the console:
```typescript
// In store configuration
const store = configureStore({
  reducer: rootReducer,
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware().concat(logger),
});

// Custom logger middleware
const logger = store => next => action => {
  if (action.type === '@@INIT') {
    console.log('Initial Redux State:', store.getState());
  }
  return next(action);
};
```

#### State Changes
Every Redux state change is logged to the console with:
- The action type
- The specific state changes (diff)
- Timestamp of the change

```typescript
// Example console output for a task update
{
  type: 'tasks/updateTask',
  payload: {
    id: '123',
    changes: {
      title: 'Updated Task Title',
      status: 'workingOnIt'
    }
  },
  timestamp: '2024-01-20T12:34:56.789Z'
}
```

#### Backend Sync Operations
Each sync operation is logged with:
- The changes being synced
- The sync result (success/failure)
- Any error messages if applicable

```typescript
// Example console output for sync operation
{
  type: 'sync/started',
  changes: [
    {
      type: 'task',
      operation: 'update',
      id: '123',
      data: { title: 'Updated Task Title' }
    }
  ],
  timestamp: '2024-01-20T12:34:57.789Z'
}

// Success case
{
  type: 'sync/completed',
  result: 'success',
  syncedAt: '2024-01-20T12:34:58.789Z'
}

// Failure case
{
  type: 'sync/failed',
  error: {
    code: 'NETWORK_ERROR',
    message: 'Failed to connect to server'
  },
  timestamp: '2024-01-20T12:34:58.789Z'
}
```






## Features & Implementation

### Sidebar & Top Panel

#### Overview
The application includes a persistent global sidebar (on the left) and a top panel (header bar) that remain visible across all pages. These two navigation and control areas ensure quick access to core features and important indicators (sync status, settings, login/logout, etc.).

#### Goals & Requirements

##### Centralized Navigation
- Provide quick links to core pages (Home, Weekly Plan, Master List, etc.)
- Allow easy navigation without refreshing or reloading the application

##### Persistent Visibility
- Remain visible/accessible at all times, regardless of the active page
- Collapse or expand the sidebar in response to user preference or screen size

##### Key Controls in Top Panel
- Settings button for user preferences, theme toggles, or account info
- Sync/Save Indicator to reflect the real-time sync status from the Redux store
- Login/Logout button/indicator to manage authentication state

##### Responsive & Accessible
- Adapt layout for mobile, tablet, and desktop screen sizes
- Provide clear focus states, ARIA labels, and keyboard navigation

#### Layout & Components
```
+------------------------------------------------------------------------+
| [App Logo / Title]            [Sync Indicator]  [Settings]  [Logout]   |
+------------------+-----------------------------------------------------+
|   Sidebar        |  Main Content Area                       |
|   [Nav Links]    |  (Home / Weekly Plan / Master List etc.) |
|   [User Info]    |                                          |
|   [Collapse Btn] |                                          |
+------------------+-----------------------------------------------------+
```

#### Sidebar

##### Navigation Links
- Home
- Weekly Plan
- Master List


##### User Info / Profile Section 
- Empty for now

##### Collapse/Expand Control
- A button (e.g., a hamburger icon or double-chevron) that toggles the sidebar's width
- Uses local React state since it only affects the layout

##### Responsive Behavior
- Mobile: The sidebar may slide in/out over the content
- Desktop: The sidebar remains docked on the left

##### Implementation Details
- Housed in a `<Sidebar>` component, rendered at the same level as the main content
- All navigation items are stored in an array or config object (e.g., `NAV_LINKS = [{ path: '/home', label: 'Home', icon: ... }, ...]`), then mapped to `<NavLink>` items
- Uses local React state for collapse state since it only affects the layout


#### Top Panel

##### Position & Layout
- Stays at the top of the viewport, spanning the full width

##### Content Components
- App Logo or Title: Left-aligned; navigates back to Home or a landing page
- Sync/Save Indicator:
  - Reflects the Redux sync state (idle, syncing, error)
  - Could be a small icon + text (e.g., "All changes saved" or a spinner if syncing)
  - Ties into the same sync slice that other pages use (see Core Architecture > State Management)
  - Top right corner
- Settings Button:
  - Opens a modal or dedicated page with user-configurable settings (theme, notifications, account details, etc.)
  - Could be an icon button that triggers `<SettingsModal>`
  - Inactive for now
  - Top right corner
- Login/Logout Button:
  - Shows "Login" if user is not authenticated, "Logout" if user is authenticated
  - On click, dispatches an auth action or navigates to a login page
  - Top right corner
  - Inactive for now






## Styling & UI

### Core Principles
- Use Tailwind CSS as the primary styling solution
- Configure core design tokens (colors, typography, spacing) in `tailwind.config.js`
- Leverage shadcn/ui components for common UI elements
- Minimize component-specific styling
- Maintain consistent responsive behavior across all pages
- lucide icons

### Global Configuration

#### Tailwind Setup
```javascript
// tailwind.config.js
module.exports = {
  theme: {
    extend: {
      colors: {
        // Core brand colors
        primary: '#1D4ED8',
        secondary: '#9333EA',
        accent: '#F59E0B'
      },
      fontFamily: {
        sans: ['Inter', 'sans-serif']
      }
    }
  }
}
```

#### Component Library
- Use shadcn/ui components for standard UI elements (buttons, inputs, modals)
- Maintain default shadcn styling unless specific requirements dictate otherwise
- Configure component themes through shadcn's built-in theming system

### Layout Structure
- Global layout wrapper handles standard page structure
- Responsive design uses Tailwind's breakpoint system
- Consistent spacing and container widths across pages

### Styling Guidelines
1. Use Tailwind utility classes for layout and basic styling
2. Apply component-specific styles only when required by design specs
3. Keep custom CSS minimal and well-documented
4. Maintain consistent spacing, typography, and color usage across components

### Visual Feedback
- Status indicators follow predefined color schemes
- Loading states use consistent animations
- Error states maintain uniform styling
- Toast notifications follow a standard design pattern
--------------------------------------------------------------------------------
<File: docs/project_structure.md>
# Project Tree

```text
life-manager/
 docs/
    design_document.md         # Complete system design document
    project_structure.md       # This file - explains the project organization
    task_plan.md              # Development tasks and timeline

 backend/
    app.py                    # Routes and business logic
    cosmos_db.py             # Database operations
    testing.py               # Test data generation and cleanup
    requirements.txt
    .env

 frontend/
    index.html
    package.json
    vite.config.ts
    tsconfig.json
    tsconfig.app.json        # App-specific TypeScript config
    tsconfig.node.json       # Node-specific TypeScript config
    tailwind.config.js
    postcss.config.js
    eslint.config.js         # ESLint configuration
    components.json          # shadcn/ui component configuration
   
    src/
       main.tsx            # Application entry point
       App.tsx            # Root component and routing
      
       components/
          animations/    # CSS animations
             StatusCheckAnimation.css
         
          layouts/      # Layout components
             AppLayout.tsx
             Sidebar.tsx
             TopPanel.tsx
         
          ui/           # shadcn/ui components
             button.tsx
             card.tsx
             checkbox.tsx
             dialog.tsx
             input.tsx
             select.tsx
             separator.tsx
             skeleton.tsx
             table.tsx
         
          task/        # Task-specific components
              TaskCard.tsx     # Compact, draggable version
              TaskDetails.tsx  # Detailed task view dialog
              TaskTable.tsx    # Table container & sorting
              TaskTableRow.tsx # Full task info in tabular format
      
       pages/
          HomePage.tsx
          WeeklyPlanPage.tsx    # Uses TaskCard for calendar
          MasterListPage.tsx    # Uses TaskTable + TaskTableRow
      
       state/
          slices/
             taskSlice.ts     # Task state and reducers
             syncSlice.ts     # Sync state and reducers
          logger.ts            # Logging middleware and utilities
          syncEngine.ts        # Store setup + sync orchestration
      
       utils/
          api.ts              # API client
          displayMappings.ts  # UI display configurations
          types.ts            # TypeScript interfaces
          utils.ts            # Utility functions
      
       styles/
           globals.css         # Global styles and Tailwind imports
   
    public/
        assets/

 README.md
 .gitignore
```

# Frontend Hierarchy & Styling Architecture

## Core Style Configuration

### 1. Type Definitions (`src/utils/types.ts`)
- TypeScript interfaces and type definitions for:
  - Task interfaces
  - Status types
  - Recurrence types
  - State interfaces
  - Common type definitions

### 2. Display Mappings (`src/utils/displayMappings.ts`)
- Status colors and display text
- Priority range definitions and colors
- Effort level display configurations
- Recurrence display formatting
- All UI-related constants and helper functions
- Color definitions for statuses, priorities, etc.

### 3. Theme Configuration (`tailwind.config.js`)
- Core design tokens:
  - Base color palette
  - Typography settings
  - Spacing scales
  - Border radius values
  - Dark/light mode variables

### 4. Global Styles (`src/styles/globals.css`)
- Tailwind imports
- CSS variables
- Dark/light mode schemes
- Base element styles

### 5. UI Components (`src/components/ui/`)
- shadcn/ui base components
- Consistent styling patterns
- Theme token usage

## Component Hierarchy

### Root Component (`App.tsx`)
- Redux Provider configuration
- Router implementation
- AppLayout wrapper

### Layout Components

#### `AppLayout.tsx` (`src/components/layouts/`)
- Main layout wrapper
- Core page structure
- Sidebar state management
- Responsive layout handling
- TopPanel and Sidebar integration

#### `TopPanel.tsx` (`src/components/layouts/`)
- Application header
- Sync status display
- Settings controls
- Authentication controls

#### `Sidebar.tsx` (`src/components/layouts/`)
- Navigation menu
- Collapsible functionality
- Route management
- Active state handling

### Content Pages (`src/pages/`)
- HomePage.tsx
- WeeklyPlanPage.tsx
- MasterListPage.tsx

### Task Components (`src/components/task/`)

#### `TaskTable.tsx`
- Task list container
- Table structure
- Column management

#### `TaskTableRow.tsx`
- Individual task display
- Status management
- Priority display
- Action handlers

#### `TaskCard.tsx`
- Compact task display
- Drag-and-drop support
- Status indicators

#### `TaskDetails.tsx`
- Full task information
- Edit capabilities
- Modal dialog

### Animation Components (`src/components/animations/`)
- StatusCheckAnimation.css
- Task status transitions
- UI feedback animations


--------------------------------------------------------------------------------
<File: docs/task_plan.md>
# Task Plan

1. Backend 
   - [x] Validate that app.py adheres to the design document and everything is implemented correctly

2. Frontend Setup 
   - [x] Create a React Vite app with TypeScript named 'frontend'
   - [x] Install packages necessary to adhere to design doc
   - [x] Set up initial configuration (TypeScript, Tailwind, shadcn/ui)
   - [x] Create scaffolding for the frontend:
       [x] Set up Redux store structure (tasks and sync slices)
       [x] Set up API client and sync engine
       [x] Create base layout components:
           [x] Sidebar component with navigation
           [x] Top panel with sync status

3. Core Pages 
   - [ ] HomePage.tsx (scaffolded)
   - [ ] WeeklyPlanPage.tsx  (scaffolded)
   - [x] MasterListPage.tsx (implemented with TaskTable)

4. Task Components 
   - [x] TaskTable.tsx (complete with sorting and display)
   - [x] TaskTableRow.tsx (complete with actions and status updates)
   - [x] TaskDetails.tsx (dialog for viewing task details)
   - [x] TaskCard.tsx (basic structure)


5. Add Task Creation Flow
   - [ ] Create AddTaskDialog Component
       - [ ] Create basic dialog structure using shadcn Dialog
       - [ ] Add form fields for required task properties:
           - [ ] Title (required)
           - [ ] Priority (optional)
           - [ ] Effort (optional)
           - [ ] Due Date (optional)
           - [ ] Notes (optional)
       - [ ] Add form fields for recurrence:
           - [ ] Is Recurring checkbox
           - [ ] Frequency select (daily, weekly, monthly, yearly)
           - [ ] Interval input
           - [ ] Additional fields based on frequency

   
   - [ ] Implement Task Creation in Redux
       - [ ] Add createTask action to taskSlice
       - [ ] Update syncEngine to handle task creation
       - [ ] Ensure task creation adheres to core design strategy of optimistic updates, immediate feedback, and debouncing syncs to the backend via syncEngine

   - [ ] Add Task Creation Button
       - [ ] Add action button in MasterListPage




1. Add "Add Task" functionality
    -  Create AddTaskDialog component
    -  Implement task creation flow in Redux
    -  Add create task API integration (/sync)
    -  Validate task creation flow adheres to core design strategy

2. Core Functionality 
    - Add recurrence logic -> when a task with a recurrence is marked complete, reset the status to not started and update the due date based on the recurrence. Add a record of the completion to the completion_history field. 
    - Add the ability to edit task details (Due Date, Notes, Title) 

3. Create collapsable filter and sort scaffolding 
--------------------------------------------------------------------------------
<File: frontend/components.json>
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": false,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.js",
    "css": "src/index.css",
    "baseColor": "gray",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}
--------------------------------------------------------------------------------
<File: frontend/eslint.config.js>
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'

export default tseslint.config(
  { ignores: ['dist'] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ['**/*.{ts,tsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
)

--------------------------------------------------------------------------------
<File: frontend/index.html>
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React + TS</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

--------------------------------------------------------------------------------
<File: frontend/package.json>
{
  "name": "frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@radix-ui/react-checkbox": "^1.1.3",
    "@radix-ui/react-dialog": "^1.1.4",
    "@radix-ui/react-label": "^2.1.1",
    "@radix-ui/react-popover": "^1.1.4",
    "@radix-ui/react-select": "^2.1.4",
    "@radix-ui/react-separator": "^1.1.1",
    "@radix-ui/react-slot": "^1.1.1",
    "@radix-ui/react-toast": "^1.2.4",
    "@reduxjs/toolkit": "^2.5.0",
    "@types/lodash": "^4.17.14",
    "@types/react-router-dom": "^5.3.3",
    "@types/uuid": "^10.0.0",
    "autoprefixer": "^10.4.20",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "date-fns": "^4.1.0",
    "deep-object-diff": "^1.1.9",
    "lodash": "^4.17.21",
    "lucide-react": "^0.471.0",
    "postcss": "^8.4.49",
    "react": "^18.3.1",
    "react-day-picker": "^8.10.1",
    "react-dom": "^18.3.1",
    "react-redux": "^9.2.0",
    "react-router-dom": "^7.1.1",
    "tailwind-merge": "^2.6.0",
    "tailwindcss": "^3.4.17",
    "uuid": "^11.0.5"
  },
  "devDependencies": {
    "@eslint/js": "^9.17.0",
    "@types/node": "^22.10.5",
    "@types/react": "^18.3.18",
    "@types/react-dom": "^18.3.5",
    "@vitejs/plugin-react": "^4.3.4",
    "eslint": "^9.17.0",
    "eslint-plugin-react-hooks": "^5.0.0",
    "eslint-plugin-react-refresh": "^0.4.16",
    "globals": "^15.14.0",
    "tailwindcss-animate": "^1.0.7",
    "typescript": "~5.6.2",
    "typescript-eslint": "^8.18.2",
    "vite": "^6.0.5"
  }
}

--------------------------------------------------------------------------------
<File: frontend/postcss.config.js>
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

--------------------------------------------------------------------------------
<File: frontend/README.md>
# React + TypeScript + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react/README.md) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## Expanding the ESLint configuration

If you are developing a production application, we recommend updating the configuration to enable type aware lint rules:

- Configure the top-level `parserOptions` property like this:

```js
export default tseslint.config({
  languageOptions: {
    // other options...
    parserOptions: {
      project: ['./tsconfig.node.json', './tsconfig.app.json'],
      tsconfigRootDir: import.meta.dirname,
    },
  },
})
```

- Replace `tseslint.configs.recommended` to `tseslint.configs.recommendedTypeChecked` or `tseslint.configs.strictTypeChecked`
- Optionally add `...tseslint.configs.stylisticTypeChecked`
- Install [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) and update the config:

```js
// eslint.config.js
import react from 'eslint-plugin-react'

export default tseslint.config({
  // Set the react version
  settings: { react: { version: '18.3' } },
  plugins: {
    // Add the react plugin
    react,
  },
  rules: {
    // other rules...
    // Enable its recommended rules
    ...react.configs.recommended.rules,
    ...react.configs['jsx-runtime'].rules,
  },
})
```

--------------------------------------------------------------------------------
<File: frontend/src/App.css>
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}

--------------------------------------------------------------------------------
<File: frontend/src/App.tsx>
// src/App.tsx
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import { Provider } from 'react-redux';
import { store } from './state/syncEngine';
import { Toaster } from "@/components/ui/toaster";

// Pages
import HomePage from './pages/HomePage';
import WeeklyPlanPage from './pages/WeeklyPlanPage';
import MasterListPage from './pages/MasterListPage';

// Layout components
import { AppLayout } from './components/layouts/AppLayout';

function App() {
  return (
    <Provider store={store}>
      <Router>
        <Routes>
          <Route element={<AppLayout />}>
            <Route path="/" element={<HomePage />} />
            <Route path="/weekly-plan" element={<WeeklyPlanPage />} />
            <Route path="/master-list" element={<MasterListPage />} />
          </Route>
        </Routes>
        <Toaster />
      </Router>
    </Provider>
  );
}

export default App;
--------------------------------------------------------------------------------
<File: frontend/src/components/animations/animations.css>
/* src/components/animations/StatusCheckAnimation.css */

/* Attach this class to the overall bubble, so we can position the check icon absolutely within it. */
.status-bubble {
    position: relative;
    width: 7rem; 
    height: 2rem; 
    /* or keep auto width, but if so, test that the icon doesn't overlap text */
  }
  
  /* The check icon itself (initially hidden & scaled down) */
  .status-check-icon {
    position: absolute;
    left: 0.4rem;              /* place it on the left side */
    top: 50%;
    transform: translateY(-50%) scale(0);
    opacity: 0;
    transition: transform 0.3s ease, opacity 0.3s ease;
    /* color: #xxx; or keep text-current if you want it to match text color */
  }
  
  /* When .animate-check is active, pop the check in */
  .animate-check .status-check-icon {
    transform: translateY(-50%) scale(1);
    opacity: 1;
  }
  
--------------------------------------------------------------------------------
<File: frontend/src/components/layouts/AppLayout.tsx>
import { useEffect, useState } from 'react';
import { Outlet } from 'react-router-dom';
import { initializeData } from '../../state/syncEngine';
import { Sidebar } from './Sidebar';
import { TopPanel } from './TopPanel';

export function AppLayout() {
  const [isCollapsed, setIsCollapsed] = useState(false);

  useEffect(() => {
    // Initialize data when the app loads
    initializeData();
  }, []);

  return (
    <div className="flex min-h-screen">
      {/* Sidebar */}
      <Sidebar 
        isCollapsed={isCollapsed} 
        onCollapsedChange={setIsCollapsed} 
      />

      {/* Main content area with TopPanel */}
      <div className="flex flex-col flex-1">
        <TopPanel />
        <main className="flex-1 p-4 md:p-8 overflow-y-auto">
          <Outlet />
        </main>
      </div>
    </div>
  );
}

--------------------------------------------------------------------------------
<File: frontend/src/components/layouts/Sidebar.tsx>
import { NavLink } from 'react-router-dom';
import { Home, Calendar, List, ChevronLeft, ChevronRight } from 'lucide-react';
import { cn } from '../../utils/utils';
import { Button } from '../ui/button';

interface SidebarProps {
  isCollapsed: boolean;
  onCollapsedChange: (collapsed: boolean) => void;
}

export const Sidebar = ({ isCollapsed, onCollapsedChange }: SidebarProps) => {
  const navItems = [
    { path: '/', label: 'Home', icon: Home },
    { path: '/weekly-plan', label: 'Weekly Plan', icon: Calendar },
    { path: '/master-list', label: 'Master List', icon: List },
  ];

  return (
    <div
      className={cn(
        'bg-card border-r transition-all duration-300',
        isCollapsed ? 'w-16' : 'w-64'
      )}
    >
      <div className="flex flex-col h-full">
        <div className="p-4 flex items-center justify-between">
          {!isCollapsed && (
            <span className="text-xl font-bold">Life Manager</span>
          )}
          <Button
            variant="default"
            size="icon"
            onClick={() => onCollapsedChange(!isCollapsed)}
          >
            {isCollapsed ? <ChevronRight size={16} /> : <ChevronLeft size={16} />}
          </Button>
        </div>

        <nav className="flex-1 px-2 py-4">
          {navItems.map(({ path, label, icon: Icon }) => (
            <NavLink
              key={path}
              to={path}
              className={({ isActive }) =>
                cn(
                  'flex items-center px-4 py-2 my-1 rounded-md transition-colors',
                  'hover:bg-accent hover:text-accent-foreground',
                  isActive ? 'bg-accent text-accent-foreground' : 'text-muted-foreground',
                  isCollapsed && 'justify-center'
                )
              }
            >
              <Icon size={20} />
              {!isCollapsed && <span className="ml-3">{label}</span>}
            </NavLink>
          ))}
        </nav>
      </div>
    </div>
  );
}; 
--------------------------------------------------------------------------------
<File: frontend/src/components/layouts/TopPanel.tsx>
import { useSelector } from 'react-redux';
import { Check, Loader2, AlertCircle } from 'lucide-react';
import { RootState } from '../../state/syncEngine';
import { Button } from '../ui/button';

export function TopPanel() {
    const syncStatus = useSelector((state: RootState) => state.sync.status);
    const lastSynced = useSelector((state: RootState) => state.sync.lastSynced);

    const renderSyncStatus = () => {
        switch (syncStatus) {
            case 'syncing':
                return (
                    <div className="flex items-center">
                        <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                        <span>Syncing...</span>
                    </div>
                );
            case 'error':
                return (
                    <div className="flex items-center text-destructive">
                        <AlertCircle className="mr-2 h-4 w-4" />
                        <span>Sync error</span>
                    </div>
                );
            case 'idle':
                return (
                    <div className="flex items-center">
                        <Check className="mr-2 h-4 w-4 text-emerald-500" />
                        <span className="text-foreground whitespace-nowrap">
                            {lastSynced
                                ? `Last saved at ${new Date(lastSynced).toLocaleTimeString()}`
                                : 'All changes saved'}
                        </span>
                    </div>
                );
        }
    };

    return (
        <header className="sticky top-0 z-50 w-full border-b bg-background/95 backdrop-blur">
            <div className="mx-8">
                <div className="flex h-14 items-center justify-end">
                    {/* Right Side Controls */}
                    <div className="flex items-center gap-6">
                        {/* Sync Status */}
                        <div className="flex-shrink-0">
                            {renderSyncStatus()}
                        </div>

                        {/* Settings Button - Inactive for now */}
                        <Button
                            variant="default"
                            size="sm"
                            aria-label="Settings (coming soon)"
                        >
                            Settings
                        </Button>

                        {/* Login/Logout Button - Inactive for now */}
                        <Button
                            variant="default"
                            size="sm"
                            aria-label="Login (coming soon)"
                        >
                            Login
                        </Button>
                    </div>
                </div>
            </div>
        </header>
    );
} 
--------------------------------------------------------------------------------
<File: frontend/src/components/task/AddTaskDialog.tsx>
import React, { useState } from 'react';
import { useDispatch } from 'react-redux';
import { v4 as uuidv4 } from 'uuid';
import { format } from "date-fns";
import { Calendar as CalendarIcon } from "lucide-react";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import { Calendar } from "@/components/ui/calendar";
import { Checkbox } from '@/components/ui/checkbox';
import { Task, RecurrenceFrequency } from '@/utils/types';
import { addTask } from '@/state/slices/taskSlice';
import { syncChanges } from '@/state/syncEngine';
import { EFFORT_DISPLAY } from '@/utils/displayMappings';
import { cn } from '@/utils/utils';

interface AddTaskDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
}

export function AddTaskDialog({ open, onOpenChange }: AddTaskDialogProps) {
  const dispatch = useDispatch();
  
  // Form state
  const [title, setTitle] = useState('');
  const [priority, setPriority] = useState<number>(40); // Default to Medium
  const [effort, setEffort] = useState<number>(3); // Default to Medium
  const [dueDate, setDueDate] = useState<Date>();
  const [notes, setNotes] = useState('');
  const [isRecurring, setIsRecurring] = useState(false);
  const [recurrenceFrequency, setRecurrenceFrequency] = useState<RecurrenceFrequency>('daily');
  const [recurrenceInterval, setRecurrenceInterval] = useState(1);

  // Form validation state
  const [errors, setErrors] = useState<Record<string, string>>({});

  const validateForm = (): boolean => {
    const newErrors: Record<string, string> = {};

    if (!title.trim()) {
      newErrors.title = 'Title is required';
    }

    if (isRecurring && recurrenceInterval < 1) {
      newErrors.recurrenceInterval = 'Interval must be at least 1';
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();

    if (!validateForm()) {
      return;
    }

    const now = new Date().toISOString();
    const newTask: Task = {
      id: uuidv4(),
      userId: 'test-user', // TODO: Get from auth context
      type: 'task',
      title: title.trim(),
      status: 'notStarted',
      priority: priority,
      dynamicPriority: priority, // Initially same as priority
      effort: effort,
      notes: notes.trim() || undefined,
      dueDate: dueDate?.toISOString(),
      scheduledDate: undefined,
      createdAt: now,
      updatedAt: now,
      completionHistory: [],
      recurrence: isRecurring
        ? {
            isRecurring: true,
            rule: {
              frequency: recurrenceFrequency,
              interval: recurrenceInterval,
            },
          }
        : undefined,
    };

    // Dispatch to Redux (optimistic update)
    dispatch(addTask(newTask));

    // Sync to backend
    syncChanges('text', [
      {
        type: 'task',
        operation: 'create',
        id: newTask.id,
        data: newTask,
      },
    ]);

    // Reset form and close dialog
    resetForm();
    onOpenChange(false);
  };

  const resetForm = () => {
    setTitle('');
    setPriority(40);
    setEffort(3);
    setDueDate(undefined);
    setNotes('');
    setIsRecurring(false);
    setRecurrenceFrequency('daily');
    setRecurrenceInterval(1);
    setErrors({});
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-[425px]">
        <DialogHeader>
          <DialogTitle>Add New Task</DialogTitle>
          <DialogDescription>
            Create a new task. Add title and any additional details needed.
          </DialogDescription>
        </DialogHeader>

        <form onSubmit={handleSubmit} className="space-y-6">
          {/* Title Input */}
          <div className="space-y-2">
            <Label htmlFor="title">
              Title <span className="text-destructive">*</span>
            </Label>
            <Input
              id="title"
              value={title}
              onChange={(e) => setTitle(e.target.value)}
              className={errors.title ? 'border-destructive' : ''}
            />
            {errors.title && (
              <p className="text-sm text-destructive">{errors.title}</p>
            )}
          </div>

          {/* Priority Select */}
          <div className="space-y-2">
            <Label htmlFor="priority">Priority</Label>
            <Select
              value={priority.toString()}
              onValueChange={(value) => setPriority(parseInt(value))}
            >
              <SelectTrigger id="priority">
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                <SelectGroup>
                  <SelectLabel>Priority Level</SelectLabel>
                  <SelectItem value="80">Very High</SelectItem>
                  <SelectItem value="60">High</SelectItem>
                  <SelectItem value="40">Medium</SelectItem>
                  <SelectItem value="20">Low</SelectItem>
                  <SelectItem value="0">Very Low</SelectItem>
                </SelectGroup>
              </SelectContent>
            </Select>
          </div>

          {/* Effort Select */}
          <div className="space-y-2">
            <Label htmlFor="effort">Effort</Label>
            <Select
              value={effort.toString()}
              onValueChange={(value) => setEffort(parseInt(value))}
            >
              <SelectTrigger id="effort">
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                <SelectGroup>
                  <SelectLabel>Effort Level</SelectLabel>
                  {Object.entries(EFFORT_DISPLAY).map(([value, { label }]) => (
                    <SelectItem key={value} value={value}>
                      {label}
                    </SelectItem>
                  ))}
                </SelectGroup>
              </SelectContent>
            </Select>
          </div>

          {/* Due Date Input */}
          <div className="space-y-2">
            <Label htmlFor="dueDate">Due Date</Label>
            <Popover>
              <PopoverTrigger asChild>
                <Button
                  variant={"outline"}
                  className={cn(
                    "w-full justify-start text-left font-normal",
                    !dueDate && "text-muted-foreground"
                  )}
                >
                  <CalendarIcon className="mr-2 h-4 w-4" />
                  {dueDate ? format(dueDate, "PPP") : "Pick a date"}
                </Button>
              </PopoverTrigger>
              <PopoverContent className="w-auto p-0" align="start">
                <Calendar
                  mode="single"
                  selected={dueDate}
                  onSelect={setDueDate}
                  initialFocus
                />
              </PopoverContent>
            </Popover>
          </div>

          {/* Notes Input */}
          <div className="space-y-2">
            <Label htmlFor="notes">Notes</Label>
            <Input
              id="notes"
              value={notes}
              onChange={(e) => setNotes(e.target.value)}
            />
          </div>

          {/* Recurrence Section */}
          <div className="space-y-4">
            <div className="flex items-center space-x-2">
              <Checkbox
                id="isRecurring"
                checked={isRecurring}
                onCheckedChange={(checked) => setIsRecurring(!!checked)}
              />
              <Label htmlFor="isRecurring">Recurring Task</Label>
            </div>

            {isRecurring && (
              <div className="space-y-4 pl-6">
                <div className="space-y-2">
                  <Label htmlFor="recurrenceFrequency">Frequency</Label>
                  <Select
                    value={recurrenceFrequency}
                    onValueChange={(value) => 
                      setRecurrenceFrequency(value as RecurrenceFrequency)
                    }
                  >
                    <SelectTrigger id="recurrenceFrequency">
                      <SelectValue />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectGroup>
                        <SelectItem value="daily">Daily</SelectItem>
                        <SelectItem value="weekly">Weekly</SelectItem>
                        <SelectItem value="monthly">Monthly</SelectItem>
                        <SelectItem value="yearly">Yearly</SelectItem>
                      </SelectGroup>
                    </SelectContent>
                  </Select>
                </div>

                <div className="space-y-2">
                  <Label htmlFor="recurrenceInterval">
                    Repeat Every
                  </Label>
                  <Input
                    id="recurrenceInterval"
                    type="number"
                    min="1"
                    value={recurrenceInterval}
                    onChange={(e) => 
                      setRecurrenceInterval(parseInt(e.target.value) || 1)
                    }
                    className={errors.recurrenceInterval ? 'border-destructive' : ''}
                  />
                  {errors.recurrenceInterval && (
                    <p className="text-sm text-destructive">
                      {errors.recurrenceInterval}
                    </p>
                  )}
                </div>
              </div>
            )}
          </div>

          {/* Submit Button */}
          <div className="flex justify-end">
            <Button type="submit" variant="default">
              Create Task
            </Button>
          </div>
        </form>
      </DialogContent>
    </Dialog>
  );
}
--------------------------------------------------------------------------------
<File: frontend/src/components/task/Recurrence.tsx>
//src/components/task/Recurrence.ts

import { format, addDays, addWeeks, addMonths, addYears } from 'date-fns';
import { RecurrenceRule, CompletionEntry } from '@/utils/types';

/**
 * Calculate the next due date based on a recurrence rule
 */
export function calculateNextDueDate(
  currentDueDate: string | undefined,
  rule: RecurrenceRule
): string {
  // Use current due date or today as base
  const baseDate = currentDueDate ? new Date(currentDueDate) : new Date();
  
  // Calculate next date based on frequency and interval
  let nextDate: Date;
  switch (rule.frequency) {
    case 'daily':
      nextDate = addDays(baseDate, rule.interval);
      break;
    case 'weekly':
      nextDate = addWeeks(baseDate, rule.interval);
      break;
    case 'monthly':
      nextDate = addMonths(baseDate, rule.interval);
      break;
    case 'yearly':
      nextDate = addYears(baseDate, rule.interval);
      break;
    default:
      throw new Error(`Unknown frequency: ${rule.frequency}`);
  }

  // Handle day constraints for weekly frequency
  if (rule.frequency === 'weekly' && rule.daysOfWeek?.length) {
    // Find the next allowed day of week
    while (!rule.daysOfWeek.includes(nextDate.getDay())) {
      nextDate = addDays(nextDate, 1);
    }
  }

  // Handle month/day constraints for monthly frequency
  if (rule.frequency === 'monthly' && rule.dayOfMonth) {
    // Set to specified day of month, handling end of month cases
    const maxDays = new Date(nextDate.getFullYear(), nextDate.getMonth() + 1, 0).getDate();
    const targetDay = Math.min(rule.dayOfMonth, maxDays);
    nextDate.setDate(targetDay);
  }

  return nextDate.toISOString();
}

/**
 * Create a completion record for a task
 */
export function createCompletionRecord(
  nextDueDate?: string,
  notes?: string
): CompletionEntry {
  return {
    completedAt: new Date().toISOString(),
    nextDueDate,
    completionNotes: notes
  };
}

/**
 * Format a date for display
 */
export function formatDate(date: string | Date): string {
  return format(new Date(date), 'PPP');
}

/**
 * Check if a task should be reset based on its recurrence rule
 */
export function shouldResetTask(
  task: { recurrence?: { isRecurring: boolean; rule?: RecurrenceRule } }
): boolean {
  return Boolean(
    task.recurrence?.isRecurring && 
    task.recurrence.rule &&
    task.recurrence.rule.frequency
  );
}
--------------------------------------------------------------------------------
<File: frontend/src/components/task/TaskCard.tsx>

import { Task } from '../../utils/types';

interface TaskCardProps {
  task: Task;
}

const TaskCard = ({ task }: TaskCardProps) => {
  return (
    <div className="p-4 border rounded-lg shadow-sm">
      {/* Card content will be added later */}
    </div>
  );
};

export default TaskCard; 
--------------------------------------------------------------------------------
<File: frontend/src/components/task/TaskDetails.tsx>

import { Task } from '../../utils/types';
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "../ui/dialog";

interface TaskDetailsProps {
  task: Task;
  open: boolean;
  onOpenChange: (open: boolean) => void;
}

const TaskDetails = ({ task, open, onOpenChange }: TaskDetailsProps) => {
  const formatDate = (date: string | undefined) => {
    if (!date) return '-';
    return new Date(date).toLocaleDateString();
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-2xl">
        <DialogHeader>
          <DialogTitle>{task.title}</DialogTitle>
        </DialogHeader>
        
        <div className="grid gap-4 py-4">
          <div className="grid grid-cols-4 items-center gap-4">
            <div className="font-medium">Status</div>
            <div className="col-span-3 flex items-center gap-2">
              <div className={`w-2 h-2 rounded-full ${
                task.status === 'complete' ? 'bg-green-500' :
                task.status === 'workingOnIt' ? 'bg-yellow-500' :
                'bg-gray-500'
              }`} />
              {task.status === 'notStarted' ? 'Not Started' :
               task.status === 'workingOnIt' ? 'Working on It' :
               'Complete'}
            </div>
          </div>

          <div className="grid grid-cols-4 items-center gap-4">
            <div className="font-medium">Priority</div>
            <div className="col-span-3">
              <div className={`inline-flex px-2 py-1 rounded-full text-xs ${
                task.priority >= 80 ? 'bg-red-100 text-red-800' :
                task.priority >= 60 ? 'bg-orange-100 text-orange-800' :
                task.priority >= 40 ? 'bg-yellow-100 text-yellow-800' :
                task.priority >= 20 ? 'bg-green-100 text-green-800' :
                'bg-gray-100 text-gray-800'
              }`}>
                {task.priority}
              </div>
            </div>
          </div>

          <div className="grid grid-cols-4 items-center gap-4">
            <div className="font-medium">Due Date</div>
            <div className="col-span-3">{formatDate(task.dueDate)}</div>
          </div>

          <div className="grid grid-cols-4 items-center gap-4">
            <div className="font-medium">Scheduled</div>
            <div className="col-span-3">{formatDate(task.scheduledDate)}</div>
          </div>

          {task.notes && (
            <div className="grid grid-cols-4 items-start gap-4">
              <div className="font-medium">Notes</div>
              <div className="col-span-3 whitespace-pre-wrap">{task.notes}</div>
            </div>
          )}

          {task.recurrence?.isRecurring && task.recurrence.rule && (
            <div className="grid grid-cols-4 items-start gap-4">
              <div className="font-medium">Recurrence</div>
              <div className="col-span-3">
                Every {task.recurrence.rule.interval} {task.recurrence.rule.frequency}
                {task.recurrence.rule.endDate && ` until ${formatDate(task.recurrence.rule.endDate)}`}
              </div>
            </div>
          )}

          {task.completionHistory.length > 0 && (
            <div className="grid grid-cols-4 items-start gap-4">
              <div className="font-medium">History</div>
              <div className="col-span-3">
                <div className="space-y-2">
                  {task.completionHistory.map((entry, index) => (
                    <div key={index} className="text-sm">
                      Completed on {formatDate(entry.completedAt)}
                      {entry.completionNotes && (
                        <div className="text-gray-600 ml-4">{entry.completionNotes}</div>
                      )}
                    </div>
                  ))}
                </div>
              </div>
            </div>
          )}
        </div>
      </DialogContent>
    </Dialog>
  );
};

export default TaskDetails; 
--------------------------------------------------------------------------------
<File: frontend/src/components/task/TaskTable.tsx>
// File: src/components/task/TaskTable.tsx


import { Task } from '../../utils/types'; 
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from '../ui/table';
import TaskTableRow from './TaskTableRow';

interface TaskTableProps {
  tasks: Task[];
}

const TaskTable = ({ tasks }: TaskTableProps) => {
  return (
    <div className="w-full rounded-lg border bg-card shadow-sm">
      {/* Table title area */}
      <div className="px-4 py-3 border-b bg-muted/30 rounded-t-lg">
        <h2 className="text-lg font-semibold text-foreground">Tasks</h2>
      </div>

      {/* Main table */}
      <Table className="min-w-full text-sm">
        <TableHeader>
          <TableRow className="bg-muted/20 text-muted-foreground">
            <TableHead className="py-3 px-4 font-medium">Title</TableHead>
            <TableHead className="py-3 px-4 font-medium">Status</TableHead>
            <TableHead className="py-3 px-4 font-medium">Priority</TableHead>
            <TableHead className="py-3 px-4 font-medium">Effort</TableHead>
            <TableHead className="py-3 px-4 font-medium">Due Date</TableHead>
            <TableHead className="py-3 px-4 font-medium">Recurrence</TableHead>
            <TableHead className="py-3 px-4 font-medium">Notes</TableHead>
            <TableHead className="py-3 px-4 font-medium text-right">Actions</TableHead>
          </TableRow>
        </TableHeader>

        <TableBody>
          {tasks.map((task) => (
            <TaskTableRow key={task.id} task={task} />
          ))}

          {tasks.length === 0 && (
            <TableRow>
              <TableCell
                colSpan={8}
                className="p-4 text-center text-sm text-muted-foreground"
              >
                No tasks available.
              </TableCell>
            </TableRow>
          )}
        </TableBody>
      </Table>
    </div>
  );
};

export default TaskTable;

--------------------------------------------------------------------------------
<File: frontend/src/components/task/TaskTableRow.tsx>
// src/components/task/TaskTableRow.tsx
import { useState } from 'react';
import { TableCell, TableRow } from '../ui/table';
import { Button } from '../ui/button';
import { Eye, Trash2, Check } from 'lucide-react';
import { useToast } from "@/components/ui/useToast";
import TaskDetails from './TaskDetails';
import { Task } from '@/utils/types';
import {
  STATUS_DISPLAY,
  STATUS_COLORS,
  getPriorityDisplay,
  EFFORT_DISPLAY,
  getRecurrenceDisplay,
} from '@/utils/displayMappings';
import { syncChanges, store } from '@/state/syncEngine';
import { updateTask, deleteTask } from '@/state/slices/taskSlice';
import { calculateNextDueDate, createCompletionRecord, shouldResetTask, formatDate } from './Recurrence';
import '@/components/animations/animations.css';

const STATUS_SEQUENCE = ['notStarted', 'workingOnIt', 'complete'] as const;
const PRIORITY_SEQUENCE = [0, 20, 40, 60, 80];
const EFFORT_SEQUENCE = [1, 2, 3, 4, 5];

interface TaskTableRowProps {
  task: Task;
}

const TaskTableRow = ({ task }: TaskTableRowProps) => {
  const { toast } = useToast();
  const [showDetails, setShowDetails] = useState(false);
  const [animateCheck, setAnimateCheck] = useState(false);
  const [isResetting, setIsResetting] = useState(false);

  // Priority, Effort, Recurrence strings
  const priorityInfo = getPriorityDisplay(task.priority);
  const effortInfo = task.effort ? EFFORT_DISPLAY[task.effort] : null;
  const recurrenceLabel = getRecurrenceDisplay(
    task.recurrence?.isRecurring || false,
    task.recurrence?.rule?.frequency,
    task.recurrence?.rule?.interval
  );

  // Handle marking a recurring task as complete
  const handleRecurringComplete = () => {
    if (!task.recurrence?.rule) return;

    // Calculate next due date
    const nextDueDate = calculateNextDueDate(task.dueDate, task.recurrence.rule);
    
    // Create completion record
    const completionRecord = createCompletionRecord(nextDueDate);

    // Show completion state briefly
    store.dispatch(updateTask({
      id: task.id,
      changes: { status: 'complete' }
    }));

    // Trigger animations
    setAnimateCheck(true);
    setTimeout(() => setAnimateCheck(false), 1000);

    // After a delay, reset the task
    setTimeout(() => {
      setIsResetting(true);

      // Update task with new status, due date, and completion history
      store.dispatch(updateTask({
        id: task.id,
        changes: {
          status: 'notStarted',
          dueDate: nextDueDate,
          completionHistory: [...task.completionHistory, completionRecord]
        }
      }));

      // Sync changes to backend
      syncChanges('status', [{
        type: 'task',
        operation: 'update',
        id: task.id,
        data: {
          status: 'notStarted',
          dueDate: nextDueDate,
          completionHistory: [...task.completionHistory, completionRecord]
        }
      }]);

      // Show toast notification
      toast({
        title: "Task Reset",
        description: `${task.title} will be due again on ${formatDate(nextDueDate)}`,
      });

      // Remove resetting state
      setTimeout(() => setIsResetting(false), 300);
    }, 1500);
  };

  // Handle status changes
  const handleStatusClick = () => {
    const currentIndex = STATUS_SEQUENCE.indexOf(task.status);
    const nextIndex = (currentIndex + 1) % STATUS_SEQUENCE.length;
    const nextStatus = STATUS_SEQUENCE[nextIndex];

    // If completing a recurring task
    if (nextStatus === 'complete' && shouldResetTask(task)) {
      handleRecurringComplete();
      return;
    }

    // Handle normal status change
    store.dispatch(updateTask({
      id: task.id,
      changes: { status: nextStatus }
    }));

    syncChanges('status', [{
      type: 'task',
      operation: 'update',
      id: task.id,
      data: { status: nextStatus }
    }]);

    if (nextStatus === 'complete') {
      setAnimateCheck(true);
      setTimeout(() => setAnimateCheck(false), 1000);
    } else {
      setAnimateCheck(false);
    }
  };

  // Handle priority changes
  const handlePriorityClick = () => {
    const currentIndex = PRIORITY_SEQUENCE.indexOf(task.priority);
    const safeIndex = currentIndex >= 0 ? currentIndex : 0;
    const nextIndex = (safeIndex + 1) % PRIORITY_SEQUENCE.length;
    const nextPriority = PRIORITY_SEQUENCE[nextIndex];

    store.dispatch(updateTask({
      id: task.id,
      changes: { priority: nextPriority }
    }));

    syncChanges('priority', [{
      type: 'task',
      operation: 'update',
      id: task.id,
      data: { priority: nextPriority }
    }]);
  };

  // Handle effort changes
  const handleEffortClick = () => {
    const currentEffort = task.effort || 1;
    const currentIndex = EFFORT_SEQUENCE.indexOf(currentEffort);
    const safeIndex = currentIndex >= 0 ? currentIndex : 0;
    const nextIndex = (safeIndex + 1) % EFFORT_SEQUENCE.length;
    const nextEffort = EFFORT_SEQUENCE[nextIndex];

    store.dispatch(updateTask({
      id: task.id,
      changes: { effort: nextEffort }
    }));

    syncChanges('priority', [{
      type: 'task',
      operation: 'update',
      id: task.id,
      data: { effort: nextEffort }
    }]);
  };

  // Delete task
  const handleDeleteTask = (id: string) => {
    store.dispatch(deleteTask(id));
    syncChanges('status', [{
      type: 'task',
      operation: 'delete',
      id
    }]);
  };

  return (
    <>
      <TableRow
        className={[
          'task-row hover:bg-muted/10 even:bg-muted/5 transition-colors',
          isResetting ? 'task-resetting' : '',
          task.status === 'complete' ? 'animate-completion' : '',
        ].filter(Boolean).join(' ')}
      >
        {/* TITLE */}
        <TableCell className="px-4 py-2">
          {task.title}
        </TableCell>

        {/* STATUS BUBBLE */}
        <TableCell className="px-4 py-2">
          <button
            onClick={handleStatusClick}
            className={[
              'inline-flex items-center justify-center w-28 h-8 px-2 py-1 rounded-full text-xs relative',
              'status-bubble',
              STATUS_COLORS[task.status] || 'bg-gray-100 text-gray-800',
              animateCheck ? 'animate-check' : '',
            ].join(' ')}
          >
            {STATUS_DISPLAY[task.status] || task.status}
            <Check className="status-check-icon h-4 w-4" />
          </button>
        </TableCell>

        {/* PRIORITY CHIP */}
        <TableCell className="px-4 py-2">
          <button
            onClick={handlePriorityClick}
            className={[
              'inline-flex items-center justify-center w-24 h-8 px-2 py-1 rounded-full text-xs font-medium',
              priorityInfo.colorClass,
              'cursor-pointer transition-transform hover:scale-105'
            ].join(' ')}
          >
            {priorityInfo.label}
          </button>
        </TableCell>

        {/* EFFORT CHIP */}
        <TableCell className="px-4 py-2">
          <button
            onClick={handleEffortClick}
            className={[
              'inline-flex items-center justify-center w-20 h-8 px-2 py-1 rounded-full text-xs font-medium',
              effortInfo ? effortInfo.colorClass : 'bg-gray-100 text-gray-800',
              'cursor-pointer transition-transform hover:scale-105'
            ].join(' ')}
          >
            {effortInfo ? effortInfo.label : 'N/A'}
          </button>
        </TableCell>

        {/* DUE DATE */}
        <TableCell className="px-4 py-2">
          {task.dueDate ? formatDate(task.dueDate) : '-'}
        </TableCell>

        {/* RECURRENCE */}
        <TableCell className="px-4 py-2">
          {recurrenceLabel}
        </TableCell>

        {/* NOTES */}
        <TableCell className="px-4 py-2 whitespace-nowrap max-w-xs overflow-hidden overflow-ellipsis">
          {task.notes?.trim() || '-'}
        </TableCell>

        {/* ACTIONS */}
        <TableCell className="px-4 py-2 text-right">
          <div className="flex items-center justify-end gap-2">
            <Button 
              variant="default" 
              size="sm" 
              onClick={() => setShowDetails(true)}
            >
              <Eye className="h-4 w-4" />
            </Button>
            <Button
              variant="default"
              size="sm"
              onClick={() => handleDeleteTask(task.id)}
            >
              <Trash2 className="h-4 w-4" />
            </Button>
          </div>
        </TableCell>
      </TableRow>

      {/* DETAILS DIALOG */}
      {showDetails && (
        <TaskDetails
          task={task}
          open={showDetails}
          onOpenChange={setShowDetails}
        />
      )}
    </>
  );
};

export default TaskTableRow;
--------------------------------------------------------------------------------
<File: frontend/src/components/ui/button.tsx>
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "../../utils/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "bg-transparent text-foreground hover:text-foreground border border-input transition-colors",
        destructive:
          "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
        outline:
          "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
        gray:
          "bg-grayButton text-grayButton-foreground hover:bg-grayButton-hover shadow-sm",
        transparent:
          "bg-transparent text-muted-foreground hover:text-foreground transition-colors",
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }
--------------------------------------------------------------------------------
<File: frontend/src/components/ui/calendar.tsx>
import * as React from "react"
import { ChevronLeft, ChevronRight } from "lucide-react"
import { DayPicker } from "react-day-picker"

import { cn } from "../../utils/utils"
import { buttonVariants } from "./button"

export type CalendarProps = React.ComponentProps<typeof DayPicker>

function Calendar({
  className,
  classNames,
  showOutsideDays = true,
  ...props
}: CalendarProps) {
  return (
    <DayPicker
      showOutsideDays={showOutsideDays}
      className={cn("p-3", className)}
      classNames={{
        months: "flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0",
        month: "space-y-4",
        caption: "flex justify-center pt-1 relative items-center",
        caption_label: "text-sm font-medium",
        nav: "space-x-1 flex items-center",
        nav_button: cn(
          buttonVariants({ variant: "outline" }),
          "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100"
        ),
        nav_button_previous: "absolute left-1",
        nav_button_next: "absolute right-1",
        table: "w-full border-collapse space-y-1",
        head_row: "flex",
        head_cell:
          "text-muted-foreground rounded-md w-8 font-normal text-[0.8rem]",
        row: "flex w-full mt-2",
        cell: cn(
          "relative p-0 text-center text-sm focus-within:relative focus-within:z-20 [&:has([aria-selected])]:bg-accent [&:has([aria-selected].day-outside)]:bg-accent/50 [&:has([aria-selected].day-range-end)]:rounded-r-md",
          props.mode === "range"
            ? "[&:has(>.day-range-end)]:rounded-r-md [&:has(>.day-range-start)]:rounded-l-md first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md"
            : "[&:has([aria-selected])]:rounded-md"
        ),
        day: cn(
          buttonVariants({ variant: "ghost" }),
          "h-8 w-8 p-0 font-normal aria-selected:opacity-100"
        ),
        day_range_start: "day-range-start",
        day_range_end: "day-range-end",
        day_selected:
          "bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground",
        day_today: "bg-accent text-accent-foreground",
        day_outside:
          "day-outside text-muted-foreground aria-selected:bg-accent/50 aria-selected:text-muted-foreground",
        day_disabled: "text-muted-foreground opacity-50",
        day_range_middle:
          "aria-selected:bg-accent aria-selected:text-accent-foreground",
        day_hidden: "invisible",
        ...classNames,
      }}
      components={{
        IconLeft: ({ className, ...props }) => (
          <ChevronLeft className={cn("h-4 w-4", className)} {...props} />
        ),
        IconRight: ({ className, ...props }) => (
          <ChevronRight className={cn("h-4 w-4", className)} {...props} />
        ),
      }}
      {...props}
    />
  )
}
Calendar.displayName = "Calendar"

export { Calendar }
--------------------------------------------------------------------------------
<File: frontend/src/components/ui/card.tsx>
import * as React from "react"

import { cn } from "../../utils/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-xl border bg-card text-card-foreground shadow",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("font-semibold leading-none tracking-tight", className)}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }

--------------------------------------------------------------------------------
<File: frontend/src/components/ui/checkbox.tsx>
import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { Check } from "lucide-react"

import { cn } from "../../utils/utils"

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary shadow focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn("flex items-center justify-center text-current")}
    >
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
))
Checkbox.displayName = CheckboxPrimitive.Root.displayName

export { Checkbox }

--------------------------------------------------------------------------------
<File: frontend/src/components/ui/dialog.tsx>
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"

import { cn } from "../../utils/utils"


const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogTrigger,
  DialogClose,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}

--------------------------------------------------------------------------------
<File: frontend/src/components/ui/input.tsx>
import * as React from "react"

import { cn } from "../../utils/utils"

const Input = React.forwardRef<HTMLInputElement, React.ComponentProps<"input">>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-base shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }

--------------------------------------------------------------------------------
<File: frontend/src/components/ui/label.tsx>
import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "../../utils/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }

--------------------------------------------------------------------------------
<File: frontend/src/components/ui/popover.tsx>
"use client"

import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

import { cn } from "../../utils/utils"

const Popover = PopoverPrimitive.Root

const PopoverTrigger = PopoverPrimitive.Trigger

const PopoverAnchor = PopoverPrimitive.Anchor

const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <PopoverPrimitive.Portal>
    <PopoverPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </PopoverPrimitive.Portal>
))
PopoverContent.displayName = PopoverPrimitive.Content.displayName

export { Popover, PopoverTrigger, PopoverContent, PopoverAnchor }

--------------------------------------------------------------------------------
<File: frontend/src/components/ui/select.tsx>
import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"

import { cn } from "../../utils/utils"

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-9 w-full items-center justify-between whitespace-nowrap rounded-md border border-input bg-transparent px-3 py-2 text-sm shadow-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-1 focus:ring-ring disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("px-2 py-1.5 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-2 pr-8 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute right-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>
    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}

--------------------------------------------------------------------------------
<File: frontend/src/components/ui/separator.tsx>
"use client"

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
  (
    { className, orientation = "horizontal", decorative = true, ...props },
    ref
  ) => (
    <SeparatorPrimitive.Root
      ref={ref}
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "shrink-0 bg-border",
        orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
        className
      )}
      {...props}
    />
  )
)
Separator.displayName = SeparatorPrimitive.Root.displayName

export { Separator }

--------------------------------------------------------------------------------
<File: frontend/src/components/ui/skeleton.tsx>
import { cn } from "@/lib/utils"

function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-primary/10", className)}
      {...props}
    />
  )
}

export { Skeleton }

--------------------------------------------------------------------------------
<File: frontend/src/components/ui/table.tsx>
import * as React from "react"

import { cn } from "../../utils/utils"

const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="relative w-full overflow-auto">
    <table
      ref={ref}
      className={cn("w-full caption-bottom text-sm", className)}
      {...props}
    />
  </div>
))
Table.displayName = "Table"

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />
))
TableHeader.displayName = "TableHeader"

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn("[&_tr:last-child]:border-0", className)}
    {...props}
  />
))
TableBody.displayName = "TableBody"

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn(
      "border-t bg-muted/50 font-medium [&>tr]:last:border-b-0",
      className
    )}
    {...props}
  />
))
TableFooter.displayName = "TableFooter"

const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
      className
    )}
    {...props}
  />
))
TableRow.displayName = "TableRow"

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      "h-10 px-2 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
      className
    )}
    {...props}
  />
))
TableHead.displayName = "TableHead"

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn(
      "p-2 align-middle [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
      className
    )}
    {...props}
  />
))
TableCell.displayName = "TableCell"

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn("mt-4 text-sm text-muted-foreground", className)}
    {...props}
  />
))
TableCaption.displayName = "TableCaption"

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}

--------------------------------------------------------------------------------
<File: frontend/src/components/ui/toast.tsx>
import * as React from "react"
import * as ToastPrimitives from "@radix-ui/react-toast"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import { cn } from "../../utils/utils"

const ToastProvider = ToastPrimitives.Provider

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
      className
    )}
    {...props}
  />
))
ToastViewport.displayName = ToastPrimitives.Viewport.displayName

const toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-2 overflow-hidden rounded-md border p-4 pr-6 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border bg-background text-foreground",
        destructive:
          "destructive group border-destructive bg-destructive text-destructive-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  )
})
Toast.displayName = ToastPrimitives.Root.displayName

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium transition-colors hover:bg-secondary focus:outline-none focus:ring-1 focus:ring-ring disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
      className
    )}
    {...props}
  />
))
ToastAction.displayName = ToastPrimitives.Action.displayName

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      "absolute right-1 top-1 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-1 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      className
    )}
    toast-close=""
    {...props}
  >
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
))
ToastClose.displayName = ToastPrimitives.Close.displayName

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn("text-sm font-semibold [&+div]:text-xs", className)}
    {...props}
  />
))
ToastTitle.displayName = ToastPrimitives.Title.displayName

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn("text-sm opacity-90", className)}
    {...props}
  />
))
ToastDescription.displayName = ToastPrimitives.Description.displayName

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>

type ToastActionElement = React.ReactElement<typeof ToastAction>

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
}

--------------------------------------------------------------------------------
<File: frontend/src/components/ui/toaster.tsx>
import { useToast } from "@/hooks/use-toast"
import {
  Toast,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
} from "@/components/ui/toast"

export function Toaster() {
  const { toasts } = useToast()

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && (
                <ToastDescription>{description}</ToastDescription>
              )}
            </div>
            {action}
            <ToastClose />
          </Toast>
        )
      })}
      <ToastViewport />
    </ToastProvider>
  )
}

--------------------------------------------------------------------------------
<File: frontend/src/components/ui/useToast.tsx>
// src/components/ui/use-toast.ts
import * as React from "react"
import { type ToastActionElement, type ToastProps } from "@/components/ui/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 3000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_VALUE
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }

    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

interface Toast extends Omit<ToasterToast, "id"> {}

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }
--------------------------------------------------------------------------------
<File: frontend/src/hooks/use-toast.ts>
"use client"

// Inspired by react-hot-toast library
import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }

--------------------------------------------------------------------------------
<File: frontend/src/main.tsx>
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './styles/globals.css'
import App from './App.tsx'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
)

--------------------------------------------------------------------------------
<File: frontend/src/pages/HomePage.tsx>
import React from 'react';

const HomePage = () => {
  return (
    <div className="p-6">
      <h1 className="text-2xl font-bold mb-4">Home</h1>
      {/* Content will be added later */}
    </div>
  );
};

export default HomePage; 
--------------------------------------------------------------------------------
<File: frontend/src/pages/MasterListPage.tsx>
import React, { useState } from 'react';
import { useSelector } from 'react-redux';
import { Plus } from 'lucide-react';
import { RootState } from '../state/syncEngine';
import TaskTable from '../components/task/TaskTable';
import { AddTaskDialog } from '../components/task/AddTaskDialog';
import { Button } from '../components/ui/button';
import { Task } from '../utils/types';

const MasterListPage = () => {
  const [showAddDialog, setShowAddDialog] = useState(false);
  const tasksObj = useSelector((state: RootState) => state.tasks.items);
  const tasksArray: Task[] = Object.values(tasksObj);

  return (
    <div className="w-full space-y-4">
      <div className="flex justify-between items-center">
        <h1 className="text-2xl font-bold">Master List</h1>
        <Button onClick={() => setShowAddDialog(true)}>
          <Plus className="h-4 w-4 mr-2" />
          New Task
        </Button>
      </div>

      <div className="rounded-md border w-full">
        <TaskTable tasks={tasksArray} />
      </div>

      <AddTaskDialog 
        open={showAddDialog}
        onOpenChange={setShowAddDialog}
      />
    </div>
  );
};

export default MasterListPage;
--------------------------------------------------------------------------------
<File: frontend/src/pages/WeeklyPlanPage.tsx>
import React from 'react';

const WeeklyPlanPage = () => {
  return (
    <div className="p-6">
      <h1 className="text-2xl font-bold mb-4">Weekly Plan</h1>
      {/* Content will be added later */}
    </div>
  );
};

export default WeeklyPlanPage; 
--------------------------------------------------------------------------------
<File: frontend/src/state/logger.ts>
// src/state/logger.ts

import { Middleware, Action } from '@reduxjs/toolkit';
import { diff } from 'deep-object-diff';

// Helper to get a clean state diff
const getStateDiff = (prevState: any, nextState: any) => {
    const stateDiff = diff(prevState, nextState);
    return Object.keys(stateDiff).length ? stateDiff : null;
};

// Helper to format timestamps consistently
const getTimestamp = () => new Date().toISOString();

// Grouped console styling
const groupStyles = {
    init: 'color: #3f51b5; font-weight: bold;',     // Indigo for initialization
    action: 'color: #4CAF50; font-weight: bold;',    // Green for data changes
    sync: 'color: #9c27b0; font-weight: bold;',      // Purple for sync operations
    error: 'color: #f44336; font-weight: bold;'      // Red for errors
};

// Custom logger middleware for state changes
export const stateLogger: Middleware = (store) => (next) => (action: unknown) => {
    // Skip logging for sync status changes
    if ((action as Action).type === 'sync/setSyncStatus') {
        return next(action);
    }

    const timestamp = getTimestamp();
    const prevState = store.getState();
    const result = next(action);
    const nextState = store.getState();
    
    // Calculate meaningful state changes
    const stateDiff = getStateDiff(prevState, nextState);
    
    if (stateDiff) {
        const actionType = (action as Action).type;
        const style = actionType.startsWith('sync/') ? groupStyles.sync : groupStyles.action;
        
        console.groupCollapsed(`%c${actionType}`, style);
        console.log({
            type: actionType,
            payload: (action as any).payload,
            timestamp,
            changes: stateDiff
        });
        console.groupEnd();
    }
    
    return result;
};

// Sync operation logging functions
export const logSyncStarted = (changes: any[], changeType: string) => {
    console.groupCollapsed('%cSync Started', groupStyles.sync);
    console.log({
        type: 'sync/started',
        changeType,
        numChanges: changes.length,
        changes,
        timestamp: getTimestamp()
    });
    console.groupEnd();
};

export const logSyncCompleted = (syncedAt: string) => {
    console.groupCollapsed('%cSync Completed', groupStyles.sync);
    console.log({
        type: 'sync/completed',
        result: 'success',
        syncedAt,
        timestamp: getTimestamp()
    });
    console.groupEnd();
};

export const logSyncFailed = (error: unknown) => {
    console.group('%cSync Failed', groupStyles.error);
    console.log({
        type: 'sync/failed',
        error: {
            code: error instanceof Error ? error.name : 'UNKNOWN_ERROR',
            message: error instanceof Error ? error.message : 'An unknown error occurred'
        },
        timestamp: getTimestamp()
    });
    console.groupEnd();
};

// Initial load logging
export const logInitialState = (state: any) => {
    console.group('%cInitial Redux State', groupStyles.init);
    console.log('State:', state);
    console.log('Tasks:', Object.keys(state.tasks.items).length);
    console.log('Sync Status:', state.sync.status);
    console.log('Last Synced:', state.sync.lastSynced);
    console.groupEnd();
};
--------------------------------------------------------------------------------
<File: frontend/src/state/slices/syncSlice.ts>
import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import { SyncState } from '../../utils/types';

const initialState: SyncState = {
    status: 'idle',
    lastSynced: null,
    pendingChanges: 0
};

export const syncSlice = createSlice({
    name: 'sync',
    initialState,
    reducers: {
        setSyncStatus: (state, action: PayloadAction<'idle' | 'syncing' | 'error'>) => {
            state.status = action.payload;
        },
        setLastSynced: (state, action: PayloadAction<string | null>) => {
            state.lastSynced = action.payload;
        },
        incrementPendingChanges: (state) => {
            state.pendingChanges += 1;
        },
        decrementPendingChanges: (state) => {
            if (state.pendingChanges > 0) {
                state.pendingChanges -= 1;
            }
        },
        resetPendingChanges: (state) => {
            state.pendingChanges = 0;
        }
    }
});

export const {
    setSyncStatus,
    setLastSynced,
    incrementPendingChanges,
    decrementPendingChanges,
    resetPendingChanges
} = syncSlice.actions;

export default syncSlice.reducer; 
--------------------------------------------------------------------------------
<File: frontend/src/state/slices/taskSlice.ts>
// File: frontend/src/state/slices/taskSlice.ts

import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import { Task, TasksState, UUID } from '../../utils/types';

const initialState: TasksState = {
  items: {},
  loading: false,
  error: null
};

export const taskSlice = createSlice({
  name: 'tasks',
  initialState,
  reducers: {
    setLoading: (state, action: PayloadAction<boolean>) => {
      state.loading = action.payload;
    },
    setError: (state, action: PayloadAction<string | null>) => {
      state.error = action.payload;
    },

    /**
     * Add a single task to the dictionary.
     */
    addTask: (state, action: PayloadAction<Task>) => {
      state.items[action.payload.id] = action.payload;
    },

    /**
     * Update an existing task by its id.
     */
    updateTask: (state, action: PayloadAction<{ id: UUID; changes: Partial<Task> }>) => {
      const { id, changes } = action.payload;
      if (state.items[id]) {
        state.items[id] = { ...state.items[id], ...changes };
      } else {
        console.log('[updateTask] Task not found in store:', id);
      }
    },

    /**
     * Delete a task from the dictionary by its id.
     */
    deleteTask: (state, action: PayloadAction<UUID>) => {
      delete state.items[action.payload];
    },

    /**
     * Set an entire collection of tasks in the store. 
     * Accepts EITHER:
     *   1) A dictionary of tasks keyed by ID, OR
     *   2) An array of tasks
     * We convert arrays to a dictionary automatically.
     */
    setTasks: (
      state,
      action: PayloadAction<Record<UUID, Task> | Task[]>
    ) => {
      const payload = action.payload;

      if (Array.isArray(payload)) {
        // If payload is an array, convert it to a dictionary
        const record: Record<string, Task> = {};
        payload.forEach((task) => {
          record[task.id] = task;
        });
        state.items = record;
      } else {
        // If it's already a dictionary, just store it
        state.items = payload;
      }
    }
  }
});

// Export all of the action creators
export const {
  setLoading,
  setError,
  addTask,
  updateTask,
  deleteTask,
  setTasks
} = taskSlice.actions;

// Export the reducer to be included in your store
export default taskSlice.reducer;

--------------------------------------------------------------------------------
<File: frontend/src/state/syncEngine.ts>
// src/state/syncEngine.ts

import { configureStore } from '@reduxjs/toolkit';
import { debounce } from 'lodash';
import taskReducer, {
  setTasks,
  addTask,
  updateTask,
  deleteTask
} from './slices/taskSlice';
import syncReducer, {
  setSyncStatus,
  setLastSynced,
  resetPendingChanges
} from './slices/syncSlice';
import { api } from '../utils/api';
import { Task, UUID, ChangeType } from '../utils/types';
import {
  stateLogger,
  logSyncStarted,
  logSyncCompleted,
  logSyncFailed,
  logInitialState
} from './logger';

/**
 * Configure the Redux store
 */
export const store = configureStore({
  reducer: {
    tasks: taskReducer,
    sync: syncReducer
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      serializableCheck: {
        // Ignore these action types in serializability checks
        ignoredActions: ['sync/setLastSynced']
      }
    }).concat(stateLogger)
});

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;

/**
 * Sync configuration for each type of UI change
 */
const SYNC_CONFIG: Record<ChangeType, number> = {
  text: 2000,      // 2 seconds for text changes
  status: 500,     // 500ms for status changes
  priority: 1000,  // 1 second for priority changes
  drag: 500        // 500ms for drag operations
};

/**
 * Initialize data on app start
 */
export const initializeData = async () => {
  try {
    store.dispatch(setSyncStatus('syncing'));

    const userData = await api.getUserData();
    store.dispatch(setTasks(userData.tasks));
    store.dispatch(setLastSynced(userData.lastSyncedAt));

    store.dispatch(setSyncStatus('idle'));
    logInitialState(store.getState());
  } catch (error) {
    console.error('Failed to initialize data:', error);
    store.dispatch(setSyncStatus('error'));
  }
};

/**
 * Debounced sync functions (FIRE AND FORGET!)
 *
 * Each function logs the start, sets the store to 'syncing',
 * but does NOT await the result. We handle success/failure in then/catch.
 */
const debouncedSyncs = Object.entries(SYNC_CONFIG).reduce(
  (acc, [changeType, delay]) => {
    acc[changeType as ChangeType] = debounce((changes: Array<{
      type: 'task';
      operation: 'create' | 'update' | 'delete';
      id?: UUID;
      data?: Partial<Task>;
    }>) => {
      // 1) Log sync start in console
      logSyncStarted(changes, changeType);
      // 2) Set store to 'syncing' so top panel can show spinner
      store.dispatch(setSyncStatus('syncing'));

      const syncRequest = {
        changes: changes.map((change) => ({
          ...change,
          timestamp: new Date().toISOString(),
          changeType: changeType as ChangeType
        })),
        // fallback to "now" if we don't have lastSynced
        clientLastSync: store.getState().sync.lastSynced || new Date().toISOString()
      };

      // ===== Fire-and-forget: NO `await` here =====
      api.sync(syncRequest)
        .then((response) => {
          // If the server has new changes, apply them
          if (response.serverChanges?.length) {
            response.serverChanges.forEach((change) => {
              switch (change.operation) {
                case 'create':
                  if (change.data) {
                    store.dispatch(addTask(change.data));
                  }
                  break;
                case 'update':
                  if (change.data) {
                    store.dispatch(
                      updateTask({
                        id: change.id,
                        changes: change.data
                      })
                    );
                  }
                  break;
                case 'delete':
                  store.dispatch(deleteTask(change.id));
                  break;
              }
            });
          }

          // Sync is done
          store.dispatch(setLastSynced(response.syncedAt));
          store.dispatch(setSyncStatus('idle'));
          store.dispatch(resetPendingChanges());

          logSyncCompleted(response.syncedAt);
        })
        .catch((error) => {
          logSyncFailed(error);
          // Mark the store as 'error', so top panel can show sync error
          store.dispatch(setSyncStatus('error'));
        });
    }, delay);

    return acc;
  },
  {} as Record<ChangeType, Function>
);

/**
 * Export a helper so components can queue changes
 */
export const syncChanges = (
  changeType: ChangeType,
  changes: Array<{
    type: 'task';
    operation: 'create' | 'update' | 'delete';
    id?: UUID;
    data?: Partial<Task>;
  }>
) => {
  debouncedSyncs[changeType](changes);
};

--------------------------------------------------------------------------------
<File: frontend/src/styles/globals.css>
@tailwind base;
@tailwind components;
@tailwind utilities;
 
@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%;

    --card: 0 0% 100%;
    --card-foreground: 222.2 84% 4.9%;
 
    --popover: 0 0% 100%;
    --popover-foreground: 222.2 84% 4.9%;
 
    --primary: 222.2 47.4% 11.2%;
    --primary-foreground: 210 40% 98%;
 
    --secondary: 210 40% 96.1%;
    --secondary-foreground: 222.2 47.4% 11.2%;
 
    --muted: 210 40% 96.1%;
    --muted-foreground: 215.4 16.3% 46.9%;
 
    --accent: 210 40% 96.1%;
    --accent-foreground: 222.2 47.4% 11.2%;
 
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 40% 98%;

    --border: 214.3 31.8% 91.4%;
    --input: 214.3 31.8% 91.4%;
    --ring: 222.2 84% 4.9%;
 
    --radius: 0.5rem;
  }
 
  .dark {
    --background: 222.2 84% 4.9%;
    --foreground: 210 40% 98%;
 
    --card: 222.2 84% 4.9%;
    --card-foreground: 210 40% 98%;
 
    --popover: 222.2 84% 4.9%;
    --popover-foreground: 210 40% 98%;
 
    --primary: 210 40% 98%;
    --primary-foreground: 222.2 47.4% 11.2%;
 
    --secondary: 217.2 32.6% 17.5%;
    --secondary-foreground: 210 40% 98%;
 
    --muted: 217.2 32.6% 17.5%;
    --muted-foreground: 215 20.2% 65.1%;
 
    --accent: 217.2 32.6% 17.5%;
    --accent-foreground: 210 40% 98%;
 
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 210 40% 98%;
 
    --border: 217.2 32.6% 17.5%;
    --input: 217.2 32.6% 17.5%;
    --ring: 212.7 26.8% 83.9%;
  }
}
 
@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}
--------------------------------------------------------------------------------
<File: frontend/src/utils/api.ts>
import { Task, UUID } from './types';

const API_BASE_URL = 'http://localhost:5000/api/v1';

interface ApiResponse<T> {
    success: boolean;
    data?: T;
    error?: {
        code: string;
        message: string;
        details?: any;
    };
    metadata?: {
        timestamp: string;
        requestId: string;
        pagination?: {
            total: number;
            page: number;
            pageSize: number;
            hasMore: boolean;
        };
    };
}

interface UserData {
    tasks: Record<UUID, Task>;
    lastSyncedAt: string;
}

interface SyncRequest {
    changes: Array<{
        type: 'task';
        operation: 'create' | 'update' | 'delete';
        id?: UUID;
        data?: Partial<Task>;
        timestamp: string;
        changeType?: 'text' | 'status' | 'priority' | 'drag';
    }>;
    clientLastSync: string;
}

interface SyncResponse {
    serverChanges?: Array<{
        type: 'task';
        operation: 'create' | 'update' | 'delete';
        id: UUID;
        data?: any;
        timestamp: string;
    }>;
    syncedAt: string;
}

class ApiClient {
    private userId: string = 'temp-user-id'; // TODO: Replace with actual auth

    private async request<T>(
        endpoint: string,
        options: RequestInit = {}
    ): Promise<ApiResponse<T>> {
        const url = `${API_BASE_URL}${endpoint}`;
        const headers = {
            'Content-Type': 'application/json',
            'X-User-ID': this.userId,
            'X-Request-ID': crypto.randomUUID(),
            ...options.headers,
        };

        try {
            const response = await fetch(url, { ...options, headers });
            const data: ApiResponse<T> = await response.json();

            if (!response.ok) {
                throw new Error(data.error?.message || 'An error occurred');
            }

            return data;
        } catch (error) {
            console.error('API request failed:', error);
            throw error;
        }
    }

    async getUserData(): Promise<UserData> {
        const response = await this.request<UserData>('/user-data');
        return response.data!;
    }

    async sync(changes: SyncRequest): Promise<SyncResponse> {
        const response = await this.request<SyncResponse>('/sync', {
            method: 'POST',
            body: JSON.stringify(changes),
        });
        return response.data!;
    }
}

export const api = new ApiClient(); 
--------------------------------------------------------------------------------
<File: frontend/src/utils/displayMappings.ts>
// File: src/utils/displayMappings.ts

/**
 * STATUS_DISPLAY - The user-facing text for each status
 */
export const STATUS_DISPLAY: Record<string, string> = {
    notStarted: 'Not Started',
    workingOnIt: 'Working on It',
    complete: 'Complete',
  };
  
  /**
   * STATUS_COLORS - Pastel backgrounds + darker text
   */
  export const STATUS_COLORS: Record<string, string> = {
    notStarted: 'bg-gray-100 text-gray-800',
    workingOnIt: 'bg-orange-100 text-orange-800',
    complete: 'bg-green-100 text-green-800',
  };
  
  /**
   * getPriorityDisplay - Return { label, colorClass } for each priority numeric range.
   * Example ranges:
   *   80+ -> Very High (bg-red-100 text-red-800)
   *   60+ -> High      (bg-pink-100 text-pink-800)
   *   40+ -> Medium    (bg-yellow-100 text-yellow-800)
   *   20+ -> Low       (bg-green-100 text-green-800)
   *   <20 -> Very Low  (bg-teal-100 text-teal-800)
   */
  export function getPriorityDisplay(priority: number) {
    if (priority >= 80) {
      return { label: 'Very High', colorClass: 'bg-red-100 text-red-800' };
    } else if (priority >= 60) {
      return { label: 'High', colorClass: 'bg-pink-100 text-pink-800' };
    } else if (priority >= 40) {
      return { label: 'Medium', colorClass: 'bg-yellow-100 text-yellow-800' };
    } else if (priority >= 20) {
      return { label: 'Low', colorClass: 'bg-green-100 text-green-800' };
    } else {
      return { label: 'Very Low', colorClass: 'bg-teal-100 text-teal-800' };
    }
  }
  
  /**
   * EFFORT_DISPLAY - Pastel scale from 1..5
   */
  export const EFFORT_DISPLAY: Record<number, { label: string; colorClass: string }> = {
    1: { label: 'Very Low',  colorClass: 'bg-purple-50  text-purple-600' },
    2: { label: 'Low',       colorClass: 'bg-purple-100 text-purple-700' },
    3: { label: 'Medium',    colorClass: 'bg-purple-200 text-purple-800' },
    4: { label: 'High',      colorClass: 'bg-purple-300 text-purple-900' },
    5: { label: 'Very High', colorClass: 'bg-purple-400 text-white'      },
  };
  
  /**
   * getRecurrenceDisplay - Example function to produce user-friendly text
   * (No color classes herejust returns a string.)
   */
  export function getRecurrenceDisplay(
    isRecurring: boolean,
    frequency?: string,
    interval?: number
  ): string {
    if (!isRecurring) return 'None';
    if (!frequency) return 'Recurring (?)';
  
    // e.g., "Every 2 weekly," "Weekly," etc.
    if (interval && interval > 1) {
      return `Every ${interval} ${frequency}`;
    }
    return frequency[0].toUpperCase() + frequency.slice(1); // 'Daily', 'Weekly', etc.
  }
  
--------------------------------------------------------------------------------
<File: frontend/src/utils/types.ts>
// Common Types
export type UUID = string;
export type ISODateString = string;

export type Status = 'notStarted' | 'workingOnIt' | 'complete';
export type RecurrenceFrequency = 'daily' | 'weekly' | 'monthly' | 'yearly';
export type TimeRange = 'day' | 'week' | 'month';
export type ChangeType = 'text' | 'status' | 'priority' | 'drag';

export interface CompletionEntry {
    completedAt: ISODateString;
    nextDueDate?: ISODateString;
    completionNotes?: string;
}

export interface RecurrenceRule {
    frequency: RecurrenceFrequency;
    interval: number;
    endDate?: ISODateString;
    maxOccurrences?: number;
    daysOfWeek?: number[];  // 0-6 for weekly
    dayOfMonth?: number;    // 1-31 for monthly
    months?: number[];      // 1-12 for yearly
    weekOfMonth?: number;   // -1 to 5 (-1 for last)
}

// Task Interface
export interface Task {
    id: UUID;
    userId: UUID;
    type: 'task';
    title: string;
    status: Status;
    priority: number;
    dynamicPriority: number;
    effort?: number;
    notes?: string;
    dueDate?: ISODateString;
    scheduledDate?: ISODateString;
    createdAt: ISODateString;
    updatedAt: ISODateString;
    
    completionHistory: CompletionEntry[];
    
    recurrence?: {
        isRecurring: boolean;
        rule?: RecurrenceRule;
    };
    
    tags?: string[];
}

// Redux State Types
export interface TasksState {
    items: Record<UUID, Task>;
    loading: boolean;
    error: string | null;
}

export interface SyncState {
    status: 'idle' | 'syncing' | 'error';
    lastSynced: string | null;
    pendingChanges: number;
}

export interface LayoutState {
    sidebarCollapsed: boolean;
}

export interface RootState {
    tasks: TasksState;
    sync: SyncState;
    layout: LayoutState;
} 
--------------------------------------------------------------------------------
<File: frontend/src/utils/utils.ts>
import { type ClassValue, clsx } from 'clsx';
import { twMerge } from 'tailwind-merge';

export function cn(...inputs: ClassValue[]) {
    return twMerge(clsx(inputs));
}

--------------------------------------------------------------------------------
<File: frontend/src/vite-env.d.ts>
/// <reference types="vite/client" />

--------------------------------------------------------------------------------
<File: frontend/tailwind.config.js>
/** @type {import('tailwindcss').Config} */
export default {
	darkMode: ["class"],
	content: [
	  './index.html',
	  './src/**/*.{js,ts,jsx,tsx}',
	],
	theme: {
	  container: {
		center: true,
		padding: "2rem",
		screens: {
		  "2xl": "1400px",
		},
	  },
	  extend: {
		colors: {
		  border: "hsl(var(--border))",
		  input: "hsl(var(--input))",
		  ring: "hsl(var(--ring))",
		  background: "hsl(var(--background))",
		  foreground: "hsl(var(--foreground))",
		  primary: {
			DEFAULT: "hsl(var(--primary))",
			foreground: "hsl(var(--primary-foreground))",
		  },
		  secondary: {
			DEFAULT: "hsl(var(--secondary))",
			foreground: "hsl(var(--secondary-foreground))",
		  },
		  destructive: {
			DEFAULT: "hsl(var(--destructive))",
			foreground: "hsl(var(--destructive-foreground))",
		  },
		  muted: {
			DEFAULT: "hsl(var(--muted))",
			foreground: "hsl(var(--muted-foreground))",
		  },
		  accent: {
			DEFAULT: "hsl(var(--accent))",
			foreground: "hsl(var(--accent-foreground))",
		  },
		  popover: {
			DEFAULT: "hsl(var(--popover))",
			foreground: "hsl(var(--popover-foreground))",
		  },
		  card: {
			DEFAULT: "hsl(var(--card))",
			foreground: "hsl(var(--card-foreground))",
		  },
		},
		borderRadius: {
		  lg: "var(--radius)",
		  md: "calc(var(--radius) - 2px)",
		  sm: "calc(var(--radius) - 4px)",
		},
		keyframes: {
		  "accordion-down": {
			from: { height: "0" },
			to: { height: "var(--radix-accordion-content-height)" },
		  },
		  "accordion-up": {
			from: { height: "var(--radix-accordion-content-height)" },
			to: { height: "0" },
		  },
		},
		animation: {
		  "accordion-down": "accordion-down 0.2s ease-out",
		  "accordion-up": "accordion-up 0.2s ease-out",
		},
	  },
	},
	plugins: ["tailwindcss-animate"],
  }
--------------------------------------------------------------------------------
<File: frontend/tsconfig.app.json>
{
  "compilerOptions": {
    "incremental": true,
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["src"]
}

--------------------------------------------------------------------------------
<File: frontend/tsconfig.json>
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,

    /* Path Aliases */
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}

--------------------------------------------------------------------------------
<File: frontend/tsconfig.node.json>
{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true
  },
  "include": ["vite.config.ts"]
}

--------------------------------------------------------------------------------
<File: frontend/vite.config.ts>
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import { fileURLToPath } from 'url'
import { dirname, resolve } from 'path'

const __filename = fileURLToPath(import.meta.url)
const __dirname = dirname(__filename)

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      "@": resolve(__dirname, "./src"),
    },
  },
})

--------------------------------------------------------------------------------
<File: README.md>
# tbd

--------------------------------------------------------------------------------

<end codebase> 

