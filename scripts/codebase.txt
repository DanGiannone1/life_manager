Here is my codebase:

<File: app.py>
# File: backend/app.py

from flask import Flask, request, jsonify
from flask_cors import CORS
from cosmos_db import CosmosDBManager
import hashlib
import secrets
from datetime import datetime, timezone, timedelta
import uuid

import re
import json

app = Flask(__name__)
CORS(app)

# Initialize CosmosDB manager
cosmos_db = CosmosDBManager()

# Status mapping for display
STATUS_MAP = {
    'not_started': 'Not Started',
    'working_on_it': 'Working On It',
    'complete': 'Complete'
}

def to_snake_case(data: dict) -> dict:
    """Convert a dictionary's keys from camelCase to snake_case recursively."""
    if not isinstance(data, dict):
        return data

    new_dict = {}
    for key, value in data.items():
        snake_key = re.sub('([a-z0-9])([A-Z])', r'\1_\2', key).lower()
        if isinstance(value, dict):
            new_dict[snake_key] = to_snake_case(value)
        elif isinstance(value, list):
            new_dict[snake_key] = [to_snake_case(item) if isinstance(item, dict) else item for item in value]
        else:
            new_dict[snake_key] = value
    return new_dict

def to_camel_case(data: dict) -> dict:
    """Convert a dictionary's keys from snake_case to camelCase recursively."""
    if not isinstance(data, dict):
        return data

    new_dict = {}
    for key, value in data.items():
        components = key.split('_')
        camel_key = components[0] + ''.join(x.title() for x in components[1:])
        
        if isinstance(value, dict):
            new_dict[camel_key] = to_camel_case(value)
        elif isinstance(value, list):
            new_dict[camel_key] = [to_camel_case(item) if isinstance(item, dict) else item for item in value]
        else:
            new_dict[camel_key] = value
    return new_dict

def generate_hash_id(user_id: str, title: str, timestamp: str) -> str:
    if not all([user_id, title, timestamp]):
        raise ValueError("Missing required parameters for hash generation")
    salt = secrets.token_hex(2)  # 2 bytes = 4 hex characters
    user_id = user_id.strip()
    title = title.strip()
    combined = f"{user_id}::{title}::{timestamp}::{salt}"
    hash_object = hashlib.sha256(combined.encode('utf-8'))
    short_hash = hash_object.hexdigest()[:19]
    return f"{short_hash}_{salt}"

@app.route('/api/create-item', methods=['POST'])
def create_item():
    try:
        data = to_snake_case(request.json)
        
        # Validate required fields
        required_fields = ['title', 'user_id', 'type']
        missing_fields = [field for field in required_fields if not data.get(field)]
        if missing_fields:
            return jsonify({'error': f'Missing required fields: {", ".join(missing_fields)}'}), 400
            
        if data['type'] not in ['task', 'goal']:
            return jsonify({'error': 'Invalid type'}), 400

        # Validate and convert status
        status = data.get('status', 'not_started').lower().replace(' ', '_')
        valid_statuses = ['not_started', 'working_on_it', 'complete']
        if status not in valid_statuses:
            return jsonify({'error': f'Invalid status value. Must be one of: {", ".join(valid_statuses)}'}), 400

        # Validate and map priority (0-100 scale)
        priority_map = {
            'Very High': 90,
            'High': 70,
            'Medium': 50,
            'Low': 30,
            'Very Low': 10
        }
        priority = data.get('priority', 'Medium')
        if priority not in priority_map:
            return jsonify({'error': f'Invalid priority value. Must be one of: {", ".join(priority_map.keys())}'}), 400
        
        current_time = datetime.now(timezone.utc).replace(microsecond=0).isoformat()
        try:
            hash_id = generate_hash_id(
                user_id=data['user_id'],
                title=data['title'],
                timestamp=current_time
            )
        except ValueError as e:
            return jsonify({'error': str(e)}), 400

        type_prefix = 't' if data['type'] == 'task' else 'g'
        item_id = f"{type_prefix}_{hash_id}"

        item = {
            'id': item_id,
            'user_id': data['user_id'],
            'type': data['type'],
            'title': data['title'],
            'status': status,
            'priority': priority_map[priority],
            'dynamic_priority': priority_map[priority],
            'notes': data.get('notes'),
            'due_date': data.get('due_date'),
            'created_at': current_time,
            'updated_at': current_time,
            'category_id': data.get('category_id'),
            'subcategory_id': data.get('subcategory_id'),
            'is_recurring': data.get('is_recurring', False),
            'frequency_in_days': data.get('frequency_in_days'),
            'completion_history': []
        }

        # Type-specific fields
        if data['type'] == 'task':
            item['goal_ids'] = data.get('goal_ids', [])
        else:
            item['target_date'] = data.get('target_date')
            item['associated_task_ids'] = data.get('associated_task_ids', [])

        created_item = cosmos_db.create_item(item)
        if created_item:
            return jsonify({'message': 'Item created successfully'}), 201
        else:
            return jsonify({'error': 'Failed to create item'}), 500
            
    except Exception as e:
        return jsonify({'error': str(e)}), 400

@app.route('/api/get-master-list', methods=['GET'])
def get_master_list():
    try:
        # Hardcode for test user
        user_id = 'test-user'
        
        statuses = request.args.get('statuses', '').split(',') if request.args.get('statuses') else None
        sort_by = request.args.get('sortBy', 'priority')
        sort_direction = request.args.get('sortDirection', 'asc')
        item_type = request.args.get('type')

        query = "SELECT * FROM c WHERE c.user_id = @user_id"
        params = [{"name": "@user_id", "value": user_id}]
        
        if item_type:
            query += " AND c.type = @type"
            params.append({"name": "@type", "value": item_type})
        
        if statuses and len(statuses) > 0 and not (len(statuses) == 1 and statuses[0] == ''):
            status_map = {
                'Not Started': 'not_started',
                'Working On It': 'working_on_it',
                'Complete': 'complete'
            }
            status_conditions = []
            for i, status in enumerate(statuses):
                param_name = f"@status{i}"
                status_conditions.append(f"c.status = {param_name}")
                params.append({"name": param_name, "value": status_map.get(status, status.lower().replace(' ', '_'))})
            query += f" AND ({' OR '.join(status_conditions)})"

        sort_field = {
            'priority': 'c.priority',
            'dueDate': 'c.due_date',
            'createdAt': 'c.created_at'
        }.get(sort_by, 'c.priority')

        # For priority, we want asc to mean highest priority first (so invert if sort_by=priority)
        if sort_by == 'priority':
            sort_direction = 'asc' if sort_direction == 'desc' else 'desc'
        query += f" ORDER BY {sort_field} {sort_direction.upper()}"

        items = cosmos_db.query_items(query, params, partition_key=user_id)
        if items is None:
            return jsonify([]), 200

        priority_map = {
            90: 'Very High',
            70: 'High',
            50: 'Medium',
            30: 'Low',
            10: 'Very Low'
        }
        
        response_items = []
        for item in items:
            camel_item = to_camel_case(item)
            camel_item['displayPriority'] = priority_map.get(item['priority'], 'Medium')
            camel_item['status'] = STATUS_MAP.get(item['status'], item['status'])
            response_items.append(camel_item)
            
        return jsonify(response_items), 200
        
    except Exception as e:
        return jsonify({'error': str(e)}), 400

@app.route('/api/batch-update', methods=['PATCH'])
def batch_update():
    try:
        data = to_snake_case(request.json)
        if not data.get('updates'):
            return jsonify({'error': 'No updates provided'}), 400

        if len(data['updates']) > 100:
            return jsonify({'error': 'Maximum batch size is 100 items'}), 400

        # Reverse status mapping for storage
        REVERSE_STATUS_MAP = {
            'Not Started': 'not_started',
            'Working On It': 'working_on_it',
            'Complete': 'complete'
        }

        priority_map = {
            'Very High': 90,
            'High': 70,
            'Medium': 50,
            'Low': 30,
            'Very Low': 10
        }
        
        current_time = datetime.now(timezone.utc).replace(microsecond=0).isoformat()

        for update in data['updates']:
            try:
                item_id = update.get('id')
                if not item_id:
                    continue

                # Convert status from display format to storage format
                if 'status' in update:
                    display_status = update['status']
                    storage_status = REVERSE_STATUS_MAP.get(display_status)
                    if not storage_status:
                        return jsonify({
                            'error': f'Invalid status value "{display_status}" for item {item_id}. Must be one of: {", ".join(REVERSE_STATUS_MAP.keys())}'
                        }), 400
                    update['status'] = storage_status

                # Handle priority
                if 'priority' in update:
                    display_priority = update['priority']
                    if display_priority not in priority_map:
                        return jsonify({
                            'error': f'Invalid priority value for item {item_id}. Must be one of: {", ".join(priority_map.keys())}'
                        }), 400
                    update['priority'] = priority_map[display_priority]

                # Always update updated_at
                update['updated_at'] = current_time

                # --------------------------
                # RECURRING TASK LOGIC HERE
                # --------------------------
                # 1. Retrieve existing item from DB to check is_recurring, frequency, etc.
                existing_item = cosmos_db.get_item_by_id(item_id)
                if not existing_item:
                    return jsonify({'error': f'Item {item_id} not found'}), 404

                # 2. If the new status is 'complete' and it's a recurring task, override accordingly
                if update.get('status', '').lower() == 'complete' and existing_item.get('is_recurring') is True:
                    try:
                        # Create a copy of the existing item to modify
                        updated_item = existing_item.copy()
                        
                        # (A) Initialize completion_history if it doesn't exist
                        if 'completion_history' not in updated_item:
                            updated_item['completion_history'] = []
                        
                        # Add the new completion
                        updated_item['completion_history'].append({
                            'completed_at': current_time
                        })
                        
                        # (B) Force status back to 'not_started'
                        updated_item['status'] = 'not_started'
                        
                        # (C) Compute new due_date (only if frequency_in_days is valid)
                        freq = updated_item.get('frequency_in_days') or 0
                        if freq > 0:
                            new_due = datetime.now(timezone.utc) + timedelta(days=freq)
                            updated_item['due_date'] = new_due.replace(microsecond=0).isoformat()
                        
                        # Update the updated_at timestamp
                        updated_item['updated_at'] = current_time
                        
                        # Now perform the actual update in Cosmos with the complete item
                        result = cosmos_db.upsert_item(updated_item)
                        if not result:
                            raise ValueError(f'Failed to update recurring item {item_id}')
                            
                        continue  # Skip the normal update path since we've handled it specially
                    except Exception as e:
                        return jsonify({'error': f'Error updating recurring item {item_id}: {str(e)}'}), 400

                # Now perform the actual update in Cosmos
                result = cosmos_db.update_item(item_id, update)
                if not result:
                    return jsonify({'error': f'Failed to update item {item_id}'}), 400

            except Exception as e:
                return jsonify({'error': f'Error processing item {item_id}: {str(e)}'}), 400

        return jsonify({'message': 'Items updated successfully'}), 200
    except Exception as e:
        return jsonify({'error': f'Error in batch update: {str(e)}'}), 400

@app.route('/api/items/<item_id>', methods=['DELETE'])
def delete_item(item_id: str):
    try:
        user_id = 'test-user'
        success = cosmos_db.delete_item(item_id, user_id)
        if success:
            return jsonify({'message': 'Item deleted successfully'}), 200
        else:
            return jsonify({'error': 'Failed to delete item'}), 404
    except Exception as e:
        return jsonify({'error': str(e)}), 400

if __name__ == '__main__':
    app.run(debug=True, port=5000)

--------------------------------------------------------------------------------
<File: cosmos_db.py>
# File: backend/cosmos_db.py

import os
from typing import List, Dict, Any, Optional
from dotenv import load_dotenv
from azure.cosmos import CosmosClient, exceptions, PartitionKey
from azure.cosmos.container import ContainerProxy
from azure.cosmos.database import DatabaseProxy
from azure.identity import DefaultAzureCredential
from datetime import datetime, timezone, timedelta

class CosmosDBManager:
    def __init__(self, cosmos_host=None, cosmos_database_id=None, cosmos_container_id=None):
        self._load_env_variables(cosmos_host, cosmos_database_id, cosmos_container_id)
        self.client = self._get_cosmos_client()
        self.database: Optional[DatabaseProxy] = None
        self.container: Optional[ContainerProxy] = None
        self._initialize_database_and_container()

    def _load_env_variables(self, cosmos_host=None, cosmos_database_id=None, cosmos_container_id=None):
        load_dotenv()
        self.cosmos_host = cosmos_host or os.environ.get("COSMOS_HOST")
        self.cosmos_database_id = cosmos_database_id or os.environ.get("COSMOS_DATABASE_ID")
        self.cosmos_container_id = cosmos_container_id or os.environ.get("COSMOS_CONTAINER_ID")
        self.tenant_id = os.environ.get("TENANT_ID", '16b3c013-d300-468d-ac64-7eda0820b6d3')

        if not all([self.cosmos_host, self.cosmos_database_id, self.cosmos_container_id]):
            raise ValueError("Cosmos DB configuration is incomplete")

    def _get_cosmos_client(self) -> CosmosClient:
        print("Initializing Cosmos DB client")
        print("Using DefaultAzureCredential for Cosmos DB authentication")
        credential = DefaultAzureCredential(
            interactive_browser_tenant_id=self.tenant_id,
            visual_studio_code_tenant_id=self.tenant_id,
            workload_identity_tenant_id=self.tenant_id,
            shared_cache_tenant_id=self.tenant_id
        )
        return CosmosClient(self.cosmos_host, credential=credential)

    def _initialize_database_and_container(self) -> None:
        try:
            self.database = self._create_or_get_database()
            self.container = self._create_or_get_container()
        except exceptions.CosmosHttpResponseError as e:
            print(f'An error occurred: {e.message}')
            raise

    def _create_or_get_database(self) -> DatabaseProxy:
        try:
            database = self.client.create_database(id=self.cosmos_database_id)
            print(f'Database with id \'{self.cosmos_database_id}\' created')
        except exceptions.CosmosResourceExistsError:
            database = self.client.get_database_client(self.cosmos_database_id)
            print(f'Database with id \'{self.cosmos_database_id}\' was found')
        return database

    def _create_or_get_container(self) -> ContainerProxy:
        try:
            container = self.database.create_container(
                id=self.cosmos_container_id, 
                partition_key=PartitionKey(path='/user_id')
            )
            print(f'Container with id \'{self.cosmos_container_id}\' created')
        except exceptions.CosmosResourceExistsError:
            container = self.database.get_container_client(self.cosmos_container_id)
            print(f'Container with id \'{self.cosmos_container_id}\' was found')
        return container

    def create_item(self, item: Dict[str, Any]) -> Dict[str, Any]:
        try:
            created_item = self.container.create_item(body=item)
            print(f"Item created with id: {created_item['id']}")
            return created_item
        except exceptions.CosmosResourceExistsError:
            print(f"Item with id {item['id']} already exists. Use update_item or upsert_item to modify.")
            return None
        except exceptions.CosmosHttpResponseError as e:
            print(f"An error occurred during creation: {e.message}")
            return None

    def update_item(self, item_id: str, updates: Dict[str, Any]) -> Dict[str, Any]:
        try:
            # First, get the existing item
            existing_item = self.get_item_by_id(item_id)
            if not existing_item:
                raise ValueError(f"Item with id {item_id} not found")
            
            # Update the existing item with new values
            existing_item.update(updates)
            
            # Ensure we have the partition key (user_id)
            if 'user_id' not in existing_item:
                raise ValueError("user_id (partition key) is required for update operation")
            
            updated_item = self.container.replace_item(
                item=item_id,
                body=existing_item,
                partition_key=existing_item['user_id']
            )
            print(f"Item updated with id: {updated_item['id']}")
            return updated_item
            
        except exceptions.CosmosHttpResponseError as e:
            print(f"An error occurred during update: {e.message}")
            raise  # Re-raise the exception to propagate it
        except Exception as e:
            print(f"An error occurred during update: {str(e)}")
            raise  # Re-raise the exception to propagate it

    def upsert_item(self, item: Dict[str, Any]) -> Dict[str, Any]:
        try:
            if 'user_id' not in item:
                raise ValueError("user_id (partition key) is required for upsert operation")
                
            upserted_item = self.container.upsert_item(
                body=item,
                partition_key=item['user_id']
            )
            print(f"Item upserted with id: {upserted_item['id']}")
            return upserted_item
        except exceptions.CosmosHttpResponseError as e:
            print(f"An error occurred during upsert: {e.message}")
            raise  # Re-raise the exception to propagate it

    def query_items(self, query: str, parameters: Optional[List[Dict[str, Any]]] = None, partition_key: Optional[str] = None) -> List[Dict[str, Any]]:
        try:
            items = list(self.container.query_items(
                query=query,
                parameters=parameters,
                partition_key=partition_key,
                enable_cross_partition_query=(partition_key is None)
            ))
            print(f"Query returned {len(items)} items")
            return items
        except exceptions.CosmosHttpResponseError as e:
            print(f"An error occurred during query: {e.message}")
            return []

    def delete_item(self, item_id: str, partition_key: str) -> bool:
        try:
            self.container.delete_item(item=item_id, partition_key=partition_key)
            print(f"Item deleted with id: {item_id}")
            return True
        except exceptions.CosmosResourceNotFoundError:
            print(f"Item with id {item_id} not found. Unable to delete.")
            return False
        except exceptions.CosmosHttpResponseError as e:
            print(f"An error occurred during deletion: {e.message}")
            return False

    def get_items_by_user_id(self, user_id: str) -> List[Dict[str, Any]]:
        query = "SELECT * FROM c WHERE c.user_id = @user_id"
        parameters = [{"name": "@user_id", "value": user_id}]
        return self.query_items(query, parameters, partition_key=user_id)

    def bulk_update(self, updates: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        try:
            item_ids = [update['id'] for update in updates]
            query = "SELECT * FROM c WHERE c.id IN (@ids)"
            params = [{"name": "@ids", "value": item_ids}]
            items = list(self.container.query_items(
                query=query,
                parameters=params,
                enable_cross_partition_query=True
            ))

            if not items:
                return []

            items_dict = {item['id']: item for item in items}
            operations = []
            updated_items = []
            
            for update in updates:
                item_id = update.pop('id')
                if item_id not in items_dict:
                    continue
                item = items_dict[item_id].copy()
                item.update(update)
                operations.append(('upsert', item))
                updated_items.append(item)
                
            if operations:
                self.container.execute_multi(operations)
                
            return updated_items
            
        except exceptions.CosmosHttpResponseError as e:
            print(f"An error occurred during bulk update: {e.message}")
            return []

    # --------------------------
    # NEW HELPER METHOD:
    # --------------------------
    def get_item_by_id(self, item_id: str) -> Optional[Dict[str, Any]]:
        """
        Retrieve a single item by its ID, using cross-partition query.
        Returns None if not found.
        """
        query = "SELECT * FROM c WHERE c.id = @id"
        params = [{"name": "@id", "value": item_id}]
        items = list(self.container.query_items(
            query=query,
            parameters=params,
            enable_cross_partition_query=True
        ))
        if items:
            return items[0]
        return None

--------------------------------------------------------------------------------
<File: app/globals.css>
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Color System */
:root {
  /* Brand Colors */
  --cyan: #00FFFF;
  --blue: #00AEFF;
  --mint: #00DE94;
  --green: #00FF52;

  /* Status Colors */
  --status-working: #F5B800;
  --status-not-started: #808080;
  --status-complete: #00DE94;

  /* Priority Colors */
  --priority-high: #E84B3C;
  --priority-medium: #F5B800;
  --priority-low: #00DE94;

  /* Neutral Colors */
  --white: #ffffff;
  --background: #ffffff;
  --text-primary: #1a1a1a;
  --text-secondary: #666666;
  --text-tertiary: #999999;
}

/* Weekly Plan Page */
.content-grid {
  @apply grid md:grid-cols-3 gap-6;
}

@layer base {
  body {
    @apply bg-white relative min-h-screen;
  }

  /* Remove background texture */
  body::before {
    display: none;
  }

  body::after {
    display: none;
  }

  /* Modern Typography */
  h1, h2, h3, h4, h5, h6 {
    @apply text-[#1a1a1a] font-medium tracking-tight;
  }
}

@keyframes slideIn {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes checkmark {
  0% {
    transform: scale(0) rotate(45deg);
    opacity: 0;
  }
  35% {
    transform: scale(0) rotate(45deg);
    opacity: 0;
  }
  70% {
    transform: scale(1.2) rotate(45deg);
    opacity: 1;
  }
  100% {
    transform: scale(1) rotate(45deg);
    opacity: 1;
  }
}

@keyframes complete {
  0% {
    transform: translateX(0);
    opacity: 1;
  }
  30% {
    transform: translateX(5px);
    opacity: 1;
  }
  100% {
    transform: translateX(30px);
    opacity: 0;
  }
}

@layer utilities {
  .animate-check {
    animation: checkmark 0.4s cubic-bezier(0.65, 0, 0.45, 1) forwards;
  }

  .animate-complete {
    animation: complete 0.8s ease-out forwards;
  }
}

@layer components {
  /* Layout Components */
  .page-container {
    @apply max-w-7xl mx-auto p-6 space-y-6 relative;
  }

  /* Header Elements */
  .page-title {
    @apply text-3xl font-bold text-[#1a1a1a]
           tracking-tight;
  }

  .page-header-button {
    @apply bg-gray-100 hover:bg-gray-200
           text-gray-700 font-medium
           px-4 py-2 rounded-lg
           transition-all duration-300
           border-0
           flex items-center justify-center;
  }

  .page-header-button[size="icon"] {
    @apply p-2 w-10 h-10
           flex items-center justify-center;
  }

  .filter-icon {
    @apply h-5 w-5 text-gray-700
           flex-shrink-0;
  }

  /* Grid System */
  .grid-container {
    @apply w-full bg-white rounded-lg border border-gray-200 overflow-hidden;
  }

  .grid-header {
    @apply grid grid-cols-7 gap-4
           px-4 py-3 bg-gray-50 border-b border-gray-200;
  }

  .grid-header-cell {
    @apply text-sm font-medium text-gray-600;
  }

  .grid-header-cell.center {
    @apply text-center;
  }

  .grid-body {
    @apply divide-y divide-gray-100;
  }

  .grid-row {
    @apply grid grid-cols-7 gap-4
           px-4 py-3 hover:bg-gray-50 transition-colors
           items-center;
  }

  .grid-cell {
    @apply text-sm text-gray-700;
  }

  .grid-cell.center {
    @apply flex justify-center;
  }

  /* Item Title */
  .item-title {
    @apply text-blue-600 hover:text-blue-700 cursor-pointer;
  }

  /* Save Button */
  .save-button {
    @apply bg-gray-100 hover:bg-gray-200
           text-gray-700 font-medium
           px-4 py-2 rounded-lg
           transition-all duration-300
           disabled:opacity-50 disabled:cursor-not-allowed
           flex items-center gap-2;
  }

  .save-button.modified {
    @apply bg-green-500 hover:bg-green-600;
  }

  /* Editable Fields */
  .editable-cell {
    position: relative;
  }

  .editable-cell:hover .edit-icon {
    opacity: 1;
  }

  .editable-content {
    @apply w-full px-2 py-1 rounded
           hover:bg-gray-100 transition-colors
           cursor-pointer;
  }

  .editable-content:focus {
    @apply outline-none ring-2 ring-blue-500 bg-white;
  }

  .edit-icon {
    position: absolute;
    right: 0.5rem;
    top: 50%;
    transform: translateY(-50%);
    opacity: 0;
    width: 1rem;
    height: 1rem;
    color: #9ca3af;
    transition: opacity 0.2s;
  }

  /* Status Badges */
  .status-badge {
    @apply px-4 py-1 rounded-full text-sm font-medium 
           inline-flex items-center justify-center gap-2
           transition-opacity
           w-full whitespace-nowrap;
  }

  .status-badge.working {
    @apply bg-[#F5B800] text-white;
  }

  .status-badge.complete {
    @apply bg-[#00DE94] text-white;
  }

  .status-badge.not-started {
    @apply bg-gray-400 text-white;
  }

  /* Priority Badges */
  .priority-badge {
    @apply px-4 py-1 rounded-full text-sm font-medium
           inline-flex items-center justify-center gap-2
           transition-opacity
           w-full whitespace-nowrap;
  }

  .priority-badge.very-high {
    @apply bg-[#E84B3C] text-white;
  }

  .priority-badge.high {
    @apply bg-[#F5B800] text-white;
  }

  .priority-badge.medium {
    @apply bg-[#808080] text-white;
  }

  .priority-badge.low {
    @apply bg-[#00DE94] text-white;
  }

  .priority-badge.very-low {
    @apply bg-[#B0B0B0] text-white;
  }

  /* Time Estimate */
  .time-estimate {
    @apply text-sm text-gray-600 font-medium;
  }

  /* Filter Panel */
  .filter-panel {
    @apply bg-white
           border border-gray-100
           rounded-xl p-6 
           animate-[slideIn_0.2s_ease-out_forwards]
           shadow-lg;
  }

  /* Select Overrides */
  .select-trigger-no-border {
    @apply border-0 shadow-none focus:ring-0;
  }

  .select-trigger-no-border svg {
    @apply text-gray-700 opacity-80;
  }

  .select-content-rounded {
    @apply rounded-lg overflow-hidden border border-gray-200 bg-white;
  }

  .select-item-hover {
    @apply hover:bg-gray-50/50 cursor-pointer px-3 py-1.5;
  }

  /* Status Select */
  .status-select-trigger {
    @apply min-w-[135px];
  }
}

--------------------------------------------------------------------------------
<File: app/home/page.tsx>
"use client";


// This would normally come from an API
const mockTasks = [
  {
    id: '1',
    title: 'Complete Project Report',
    description: 'Write and submit the quarterly project report',
    priority: 'high',
    status: 'in_progress',
    category: 'Work',
    dueDate: '2024-01-05',
    isRecurring: false,
  },
  {
    id: '2',
    title: 'Morning Exercise',
    description: '30 minutes of cardio',
    priority: 'medium',
    status: 'pending',
    category: 'Health',
    isRecurring: true,
    streak: 5,
  },
];

export default function Home() {
  return (
    <div className="page-container">
      <div className="page-header">
        <h2>Welcome to Life Manager</h2>
      </div>
      <p className="subtitle">Your personal productivity dashboard</p>
      <div className="content-grid md:grid-cols-2 lg:grid-cols-3">
        {/* Dashboard content will go here */}
      </div>
    </div>
  );
}

--------------------------------------------------------------------------------
<File: app/layout.tsx>
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";
import { Sidebar } from "./sidebar/sidebar";
import { AppProvider } from "@/contexts/app-context";

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "Life Manager",
  description: "Manage your life efficiently",
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body className={inter.className}>
        <AppProvider>
          <div className="flex h-screen">
            <Sidebar />
            <main className="flex-1 overflow-auto p-4">
              {children}
            </main>
          </div>
        </AppProvider>
      </body>
    </html>
  );
}

--------------------------------------------------------------------------------
<File: app/master-list/page.tsx>
'use client';

import { useState, useRef, useEffect } from 'react';
import { Button } from "@/components/ui/button";
import { AddItemDialog } from "@/components/items/add-item-dialog";
import { ItemFilters, FilterOptions } from "@/components/items/item-filters";
import { 
    Select,
    SelectContent,
    SelectItem,
    SelectTrigger,
    SelectValue,
} from "@/components/ui/select";
import { cn } from "@/lib/utils";
import { 
    SlidersHorizontal, 
    Calendar,
    Save,
    Pencil,
    CheckCircle2,
    AlertCircle,
    CircleDot,
    Trash2
} from "lucide-react";
import { useApp } from '@/contexts/app-context';
import { TaskItem } from '@/types/items';

interface EditableFieldProps {
    value: string;
    onChange: (value: string) => void;
    type?: 'text' | 'date';
    className?: string;
}

function EditableField({ value, onChange, type = 'text', className }: EditableFieldProps) {
    const [isEditing, setIsEditing] = useState(false);
    const [editValue, setEditValue] = useState(value);
    const inputRef = useRef<HTMLInputElement>(null);

    useEffect(() => {
        setEditValue(value);
    }, [value]);

    useEffect(() => {
        if (isEditing && inputRef.current) {
            inputRef.current.focus();
        }
    }, [isEditing]);

    const handleChange = (newValue: string) => {
        setEditValue(newValue);
        onChange(newValue);
        setIsEditing(false);
    };

    const handleKeyDown = (e: React.KeyboardEvent) => {
        if (e.key === 'Enter') {
            handleChange(editValue);
        } else if (e.key === 'Escape') {
            setIsEditing(false);
            setEditValue(value);
        }
    };

    if (isEditing) {
        return (
            <input
                ref={inputRef}
                type={type}
                className="w-full px-2 py-1 text-sm rounded border border-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500"
                value={editValue}
                onChange={(e) => setEditValue(e.target.value)}
                onBlur={() => handleChange(editValue)}
                onKeyDown={handleKeyDown}
            />
        );
    }

    return (
        <div 
            className="editable-cell"
            onClick={() => setIsEditing(true)}
        >
            <div className={cn("editable-content", className)}>
                {value}
            </div>
            <Pencil className="edit-icon" />
        </div>
    );
}

const getStatusBadgeClass = (status: string) => {
    switch (status) {
        case 'Working On It':
            return 'bg-yellow-100 text-yellow-800 border-yellow-300';
        case 'Complete':
            return 'bg-green-100 text-green-800 border-green-300';
        case 'Not Started':
            return 'bg-gray-100 text-gray-800 border-gray-300';
        default:
            return 'bg-gray-100 text-gray-800 border-gray-300';
    }
};

const getPriorityBadgeClass = (priority: string) => {
    switch (priority) {
        case 'Very High':
            return 'bg-red-100 text-red-800 border-red-300';
        case 'High':
            return 'bg-orange-100 text-orange-800 border-orange-300';
        case 'Medium':
            return 'bg-yellow-100 text-yellow-800 border-yellow-300';
        case 'Low':
            return 'bg-green-200 text-green-800 border-green-300';
        default: // Very Low
            return 'bg-green-100 text-green-800 border-green-300';
    }
};

// Priority mapping for backend communication
const PRIORITY_MAP = {
    'Very High': 90,
    'High': 70,
    'Medium': 50,
    'Low': 30,
    'Very Low': 10
} as const;

function StatusSelect({ value, onChange }: { value: string, onChange: (value: string) => void }) {
    return (
        <Select 
            value={value} 
            onValueChange={onChange}
        >
            <SelectTrigger className={cn(
                "select-trigger-no-border rounded-full px-3 py-1 text-sm border status-select-trigger",
                getStatusBadgeClass(value)
            )}>
                <SelectValue>{value}</SelectValue>
            </SelectTrigger>
            <SelectContent className="select-content-rounded">
                <SelectItem value="Not Started" className="select-item-hover">Not Started</SelectItem>
                <SelectItem value="Working On It" className="select-item-hover">Working On It</SelectItem>
                <SelectItem value="Complete" className="select-item-hover">Complete</SelectItem>
            </SelectContent>
        </Select>
    );
}

function PrioritySelect({ value, displayValue, onChange }: { value: number, displayValue: string, onChange: (value: string) => void }) {
    return (
        <Select 
            value={displayValue} 
            onValueChange={onChange}
        >
            <SelectTrigger className={cn(
                "select-trigger-no-border rounded-full px-3 py-1 text-sm border",
                getPriorityBadgeClass(displayValue)
            )}>
                <SelectValue>{displayValue}</SelectValue>
            </SelectTrigger>
            <SelectContent className="select-content-rounded">
                <SelectItem value="Very High" className="select-item-hover">Very High</SelectItem>
                <SelectItem value="High" className="select-item-hover">High</SelectItem>
                <SelectItem value="Medium" className="select-item-hover">Medium</SelectItem>
                <SelectItem value="Low" className="select-item-hover">Low</SelectItem>
                <SelectItem value="Very Low" className="select-item-hover">Very Low</SelectItem>
            </SelectContent>
        </Select>
    );
}

export default function MasterList() {
    const { items, loading, error, updateItem, refreshItems } = useApp();
    const [open, setOpen] = useState(false);
    const [showFilters, setShowFilters] = useState(false);
    const [pendingChanges, setPendingChanges] = useState<Record<string, Partial<TaskItem>>>({});
    const [filters, setFilters] = useState<FilterOptions>({
        statuses: ['Not Started', 'Working On It'],
        sortBy: 'priority',
        sortDirection: 'asc',
        type: undefined
    });

    // Filter items based on current filters
    const filteredItems = items.filter(item => {
        if (filters.type && filters.type !== 'all' && item.type !== filters.type) {
            return false;
        }
        if (!filters.statuses.includes(item.status)) {
            return false;
        }
        return true;
    }).sort((a, b) => {
        const direction = filters.sortDirection === 'asc' ? 1 : -1;
        switch (filters.sortBy) {
            case 'priority':
                return (a.priority - b.priority) * direction;
            case 'dueDate':
                if (!a.dueDate) return 1;
                if (!b.dueDate) return -1;
                return (new Date(a.dueDate).getTime() - new Date(b.dueDate).getTime()) * direction;
            case 'createdAt':
                return (new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime()) * direction;
            default:
                return 0;
        }
    });

    const handleUpdateField = (id: string, field: string, value: any) => {
        setPendingChanges(prev => {
            const changes = { ...prev };
            if (field === 'priority') {
                // When updating priority, store both the display value and numeric value
                changes[id] = {
                    ...changes[id],
                    priority: PRIORITY_MAP[value as keyof typeof PRIORITY_MAP],
                    displayPriority: value
                };
            } else {
                changes[id] = {
                    ...changes[id],
                    [field]: value
                };
            }
            return changes;
        });
    };

    const handleSaveChanges = async () => {
        try {
            // Update each item with pending changes
            await Promise.all(
                Object.entries(pendingChanges).map(([id, changes]) =>
                    updateItem({ id, ...changes } as TaskItem)
                )
            );
            
            // Clear pending changes after successful update
            setPendingChanges({});
        } catch (error) {
            console.error('Error updating items:', error);
        }
    };

    const formatDate = (dateString?: string) => {
        if (!dateString) return 'N/A';
        return new Date(dateString).toLocaleDateString('en-US', { 
            year: 'numeric',
            month: 'numeric',
            day: 'numeric'
        });
    };

    const hasPendingChanges = Object.keys(pendingChanges).length > 0;

    const handleDeleteItem = async (id: string) => {
        if (!confirm('Are you sure you want to delete this item?')) {
            return;
        }

        try {
            const response = await fetch(`http://localhost:5000/api/items/${id}`, {
                method: 'DELETE',
            });

            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error || 'Failed to delete item');
            }

            // Refresh items after deletion
            await refreshItems();
        } catch (error) {
            console.error('Error deleting item:', error);
            alert(error instanceof Error ? error.message : 'Failed to delete item');
        }
    };

    return (
        <div className="page-container">
            <div className="flex items-center justify-between mb-8">
                <h1 className="page-title">Master List</h1>
                <div className="flex items-center gap-2">
                    <Button
                        className="page-header-button"
                        size="icon"
                        onClick={() => setShowFilters(!showFilters)}
                    >
                        <SlidersHorizontal className="filter-icon" />
                    </Button>
                    <Button
                        className="save-button"
                        onClick={handleSaveChanges}
                        disabled={!hasPendingChanges}
                    >
                        <Save className="h-4 w-4" />
                        Save Changes
                    </Button>
                    <Button 
                        onClick={() => setOpen(true)}
                        className="page-header-button"
                    >
                        Add Item
                    </Button>
                </div>
            </div>

            {showFilters && (
                <div className="mb-6">
                    <ItemFilters 
                        filters={filters}
                        onFiltersChange={setFilters}
                    />
                </div>
            )}

            <AddItemDialog 
                open={open} 
                onOpenChange={setOpen}
                onItemAdded={refreshItems}
            />

            {loading ? (
                <div className="flex items-center justify-center h-32">
                    <div className="text-muted-foreground">Loading...</div>
                </div>
            ) : error ? (
                <div className="text-center py-8 text-red-500">
                    {error}
                </div>
            ) : (
                <div className="grid-container">
                    <div className="grid-header">
                        <div className="grid-header-cell">Item</div>
                        <div className="grid-header-cell">Notes</div>
                        <div className="grid-header-cell">Status</div>
                        <div className="grid-header-cell">Due Date</div>
                        <div className="grid-header-cell">Created On</div>
                        <div className="grid-header-cell">Priority</div>
                        <div className="grid-header-cell"></div>
                    </div>
                    <div className="grid-body">
                        {filteredItems.map((item) => {
                            const itemChanges = pendingChanges[item.id] || {};
                            const displayItem = { ...item, ...itemChanges };

                            return (
                                <div key={item.id} className="grid-row">
                                    <div className="grid-cell">
                                        <EditableField
                                            value={displayItem.title}
                                            onChange={(value) => handleUpdateField(item.id, 'title', value)}
                                            className="item-title text-black font-medium"
                                        />
                                    </div>
                                    <div className="grid-cell">
                                        <EditableField
                                            value={displayItem.notes || ''}
                                            onChange={(value) => handleUpdateField(item.id, 'notes', value)}
                                            className="text-gray-600 text-sm"
                                        />
                                    </div>
                                    <div className="grid-cell">
                                        <StatusSelect
                                            value={displayItem.status}
                                            onChange={(value) => handleUpdateField(item.id, 'status', value)}
                                        />
                                    </div>
                                    <div className="grid-cell">
                                        <EditableField
                                            value={displayItem.dueDate || ''}
                                            onChange={(value) => handleUpdateField(item.id, 'dueDate', value)}
                                            type="date"
                                        />
                                    </div>
                                    <div className="grid-cell">
                                        {formatDate(displayItem.createdAt)}
                                    </div>
                                    <div className="grid-cell">
                                        <PrioritySelect
                                            value={displayItem.priority}
                                            displayValue={displayItem.displayPriority}
                                            onChange={(value) => handleUpdateField(item.id, 'priority', value)}
                                        />
                                    </div>
                                    <div className="grid-cell flex justify-center">
                                        <button
                                            onClick={() => handleDeleteItem(item.id)}
                                            className="p-1 hover:bg-gray-100 rounded-full transition-colors"
                                            title="Delete item"
                                        >
                                            <Trash2 className="h-4 w-4 text-gray-500 hover:text-red-500" />
                                        </button>
                                    </div>
                                </div>
                            );
                        })}
                    </div>
                </div>
            )}
        </div>
    );
} 
--------------------------------------------------------------------------------
<File: app/page.tsx>
import { redirect } from 'next/navigation';

export default async function RootPage() {
  redirect('/home');
  // Need to return something even though redirect will be called
  return null;
} 
--------------------------------------------------------------------------------
<File: app/sidebar/sidebar.tsx>
"use client";

import Link from "next/link";
import { usePathname } from "next/navigation";
import { Home, Calendar, List } from "lucide-react";
import { cn } from "@/lib/utils";

const routes = [
  {
    label: "Home",
    icon: Home,
    href: "/home",
    className: "sidebar-icon home"
  },
  {
    label: "Weekly Plan",
    icon: Calendar,
    href: "/weekly-plan",
    className: "sidebar-icon weekly"
  },
  {
    label: "Master List",
    icon: List,
    href: "/master-list",
    className: "sidebar-icon master"
  },
];

export function Sidebar() {
  const pathname = usePathname();

  return (
    <div className="sidebar flex h-full flex-col overflow-y-auto">
      <div className="flex flex-col gap-4 p-6">
        <Link href="/home" className="flex items-center gap-2">
          <h1 className="text-2xl font-semibold">
            Life Manager
          </h1>
        </Link>
        <div className="flex flex-col gap-1">
          {routes.map((route) => (
            <Link
              key={route.href}
              href={route.href}
              className={cn(
                "flex items-center gap-2 rounded-lg px-3 py-2 text-sm font-medium transition-colors",
                pathname === route.href 
                  ? "bg-[#00AEFF]/10 text-[--text-primary]" 
                  : "text-[--text-secondary] hover:text-[--text-primary] hover:bg-[#00AEFF]/5"
              )}
            >
              <route.icon className={route.className} />
              {route.label}
            </Link>
          ))}
        </div>
      </div>
    </div>
  );
} 
--------------------------------------------------------------------------------
<File: app/weekly-plan/page.tsx>
'use client';

import { useState } from 'react';
import { format, startOfWeek, addDays, addWeeks, subWeeks, endOfWeek } from 'date-fns';
import { TaskList } from '@/components/weekly-plan/task-list';
import { CalendarDay } from '@/components/weekly-plan/calendar-day';
import { TaskItem } from '@/types/items';
import { Button } from '@/components/ui/button';
import { useApp } from '@/contexts/app-context';

export default function WeeklyPlanPage() {
  const { items, loading, error, updateItem } = useApp();
  const [selectedDate, setSelectedDate] = useState(new Date());
  const [weeklyTasks, setWeeklyTasks] = useState<{ [key: string]: TaskItem[] }>({});

  // Get unscheduled tasks (Not Started or Working On It)
  const unscheduledTasks = items
    .filter((item): item is TaskItem => 
      item.type === 'task' && 
      (item.status === 'Not Started' || item.status === 'Working On It')
    );

  // Get the start and end of the week
  const weekStart = startOfWeek(selectedDate);
  const weekEnd = endOfWeek(selectedDate);

  // Generate array of dates for the week
  const weekDates = Array.from({ length: 7 }, (_, i) => addDays(weekStart, i));

  const handlePreviousWeek = () => {
    setSelectedDate(subWeeks(selectedDate, 1));
  };

  const handleNextWeek = () => {
    setSelectedDate(addWeeks(selectedDate, 1));
  };

  const handleTaskDrop = (date: Date, task: TaskItem, sourceDate?: string) => {
    const targetDateKey = format(date, 'yyyy-MM-dd');

    // If dropping in the same day, do nothing
    if (sourceDate && sourceDate === targetDateKey) {
      return;
    }

    // Remove task from source (either task list or another day)
    if (sourceDate) {
      // Moving from one day to another
      setWeeklyTasks(prev => {
        const newTasks = { ...prev };
        newTasks[sourceDate] = prev[sourceDate]?.filter(t => t.id !== task.id) || [];
        newTasks[targetDateKey] = [...(prev[targetDateKey] || []), task];
        return newTasks;
      });
    } else {
      // Moving from task list to calendar
      setWeeklyTasks(prev => ({
        ...prev,
        [targetDateKey]: [...(prev[targetDateKey] || []), task],
      }));
    }
  };

  const handleTaskUnschedule = (task: TaskItem, sourceDate: string) => {
    // Remove from calendar
    setWeeklyTasks(prev => ({
      ...prev,
      [sourceDate]: prev[sourceDate]?.filter(t => t.id !== task.id) || [],
    }));
  };

  const handleTaskComplete = async (task: TaskItem, dateKey: string) => {
    try {
      // Update UI immediately after animation completes
      setTimeout(() => {
        setWeeklyTasks(prev => ({
          ...prev,
          [dateKey]: prev[dateKey]?.filter(t => t.id !== task.id) || [],
        }));
      }, 800); // Match the animation duration

      // Update backend and global state
      await updateItem({
        ...task,
        status: 'Complete'
      });
    } catch (error) {
      console.error('Error completing task:', error);
      // Could add error handling/rollback here if needed
    }
  };

  // Format the date range for the header
  const dateRangeText = `${format(weekStart, 'LLL d')} - ${format(weekEnd, 'LLL d, yyyy')}`;

  return (
    <div className="flex h-[calc(100vh-2rem)] overflow-hidden">
      {/* Task List Section - Fixed width, full height */}
      <div className="w-[280px] border-r border-gray-200 bg-white overflow-y-auto">
        <div className="p-4">
          <h2 className="text-lg font-semibold mb-4">Tasks</h2>
          <TaskList 
            tasks={unscheduledTasks}
            loading={loading}
            error={error}
            onTaskReturn={handleTaskUnschedule}
          />
        </div>
      </div>

      {/* Calendar Section - Flexible width, full height */}
      <div className="flex-1 overflow-hidden flex flex-col">
        {/* Header */}
        <div className="flex justify-between items-center p-6 border-b border-gray-200">
          <h1 className="text-2xl font-semibold flex items-baseline">
            Weekly Plan
            <span className="text-base text-gray-500 ml-2 font-normal">
              {dateRangeText}
            </span>
          </h1>
          <div className="flex gap-4">
            <Button onClick={handlePreviousWeek} variant="outline" size="sm">
              Previous Week
            </Button>
            <Button onClick={handleNextWeek} variant="outline" size="sm">
              Next Week
            </Button>
          </div>
        </div>

        {/* Calendar Grid */}
        <div className="flex-1 overflow-y-auto">
          <div className="grid-container h-full">
            {/* Calendar Header */}
            <div className="grid grid-cols-7 border-b border-gray-200">
              {weekDates.map((date) => (
                <div
                  key={date.toISOString()}
                  className="p-4 text-center border-r last:border-r-0"
                >
                  <div className="font-medium text-gray-900">{format(date, 'EEE')}</div>
                  <div className="text-sm text-gray-500">{format(date, 'd')}</div>
                </div>
              ))}
            </div>

            {/* Calendar Body */}
            <div className="grid grid-cols-7 h-[calc(100%-57px)]">
              {weekDates.map((date) => {
                const dateKey = format(date, 'yyyy-MM-dd');
                return (
                  <div
                    key={date.toISOString()}
                    className="border-r last:border-r-0 h-full"
                  >
                    <CalendarDay
                      date={date}
                      tasks={weeklyTasks[dateKey] || []}
                      onDrop={(task, sourceDate) => handleTaskDrop(date, task, sourceDate)}
                      onTaskUnschedule={(task) => handleTaskUnschedule(task, dateKey)}
                      onTaskComplete={(task) => handleTaskComplete(task, dateKey)}
                    />
                  </div>
                );
              })}
            </div>
          </div>
        </div>
      </div>
    </div>
  );
} 
--------------------------------------------------------------------------------
<File: components/items/add-item-dialog.tsx>
'use client';

import { useState } from 'react';
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Dialog, DialogContent, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { useApp } from '@/contexts/app-context';
import { TaskItem, GoalItem, Priority, Status, ItemType } from '@/types/items';

interface AddItemDialogProps {
    open: boolean;
    onOpenChange: (open: boolean) => void;
    onItemAdded?: () => void;
}

const PRIORITY_MAP: Record<Priority, number> = {
    'Very High': 90,
    'High': 70,
    'Medium': 50,
    'Low': 30,
    'Very Low': 10
};

type BaseFormData = {
    userId: string;
    title: string;
    type: ItemType;
    status: Status;
    priority: number;
    displayPriority: Priority;
    notes: string;
    categoryId: string;
    subcategoryId: string;
    completionHistory: Array<{ completedAt: string, nextDueDate: string }>;
};

type TaskFormData = BaseFormData & {
    type: 'task';
    dueDate: string;
    isRecurring: boolean;
    frequencyInDays: number;
    goalIds: string[];
};

type GoalFormData = BaseFormData & {
    type: 'goal';
    targetDate: string;
    taskIds: string[];
};

type FormData = TaskFormData | GoalFormData;

const DEFAULT_FORM_DATA: TaskFormData = {
    userId: 'test-user', // This should come from authentication
    title: '',
    type: 'task',
    status: 'Not Started',
    priority: PRIORITY_MAP['Medium'],
    displayPriority: 'Medium',
    notes: '',
    dueDate: '',
    isRecurring: false,
    frequencyInDays: 0,
    categoryId: '',
    subcategoryId: '',
    goalIds: [],
    completionHistory: []
};

export function AddItemDialog({ open, onOpenChange, onItemAdded }: AddItemDialogProps) {
    const { createItem } = useApp();
    const [formData, setFormData] = useState<FormData>(DEFAULT_FORM_DATA);

    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();

        try {
            await createItem(formData);

            // Close dialog and reset form
            onOpenChange(false);
            setFormData(DEFAULT_FORM_DATA);
            onItemAdded?.();
        } catch (error) {
            console.error('Error creating item:', error);
            alert(error instanceof Error ? error.message : 'Failed to create item');
        }
    };

    const handleInputChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement>) => {
        const { name, value, type } = e.target;
        setFormData(prev => {
            if (name === 'priority') {
                return {
                    ...prev,
                    priority: PRIORITY_MAP[value as Priority],
                    displayPriority: value as Priority
                };
            }
            if (name === 'type') {
                const newType = value as ItemType;
                if (newType === 'task') {
                    return {
                        ...DEFAULT_FORM_DATA,
                        title: prev.title,
                        notes: prev.notes,
                        priority: prev.priority,
                        displayPriority: prev.displayPriority
                    };
                } else {
                    return {
                        ...prev,
                        type: 'goal',
                        targetDate: '',
                        taskIds: []
                    } as GoalFormData;
                }
            }
            if (name === 'status') {
                return {
                    ...prev,
                    status: value as Status
                };
            }
            return {
                ...prev,
                [name]: type === 'number' ? Number(value) : value
            };
        });
    };

    return (
        <Dialog open={open} onOpenChange={onOpenChange}>
            <DialogContent className="bg-white">
                <DialogHeader>
                    <DialogTitle>Add New Item</DialogTitle>
                </DialogHeader>
                <form onSubmit={handleSubmit} className="space-y-4">
                    <div>
                        <label className="block text-sm font-medium mb-1">Title</label>
                        <Input
                            name="title"
                            value={formData.title}
                            onChange={handleInputChange}
                            required
                        />
                    </div>
                    <div>
                        <label className="block text-sm font-medium mb-1">Type</label>
                        <select
                            name="type"
                            value={formData.type}
                            onChange={handleInputChange}
                            className="flex h-9 w-full rounded-md border border-input bg-white px-3 py-1 text-sm shadow-sm focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring cursor-pointer"
                        >
                            <option value="task">Task</option>
                            <option value="goal">Goal</option>
                        </select>
                    </div>
                    <div>
                        <label className="block text-sm font-medium mb-1">Priority</label>
                        <select
                            name="priority"
                            value={formData.displayPriority}
                            onChange={handleInputChange}
                            className="flex h-9 w-full rounded-md border border-input bg-white px-3 py-1 text-sm shadow-sm focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring cursor-pointer"
                        >
                            <option value="Very High">Very High</option>
                            <option value="High">High</option>
                            <option value="Medium">Medium</option>
                            <option value="Low">Low</option>
                            <option value="Very Low">Very Low</option>
                        </select>
                    </div>
                    <div>
                        <label className="block text-sm font-medium mb-1">Notes</label>
                        <Input
                            name="notes"
                            value={formData.notes}
                            onChange={handleInputChange}
                        />
                    </div>
                    {formData.type === 'task' && (
                        <>
                            <div>
                                <label className="block text-sm font-medium mb-1">Due Date</label>
                                <Input
                                    type="date"
                                    name="dueDate"
                                    value={formData.dueDate}
                                    onChange={handleInputChange}
                                />
                            </div>
                            <div className="flex items-center gap-2">
                                <input
                                    type="checkbox"
                                    name="isRecurring"
                                    checked={formData.isRecurring}
                                    onChange={(e) => setFormData(prev => ({
                                        ...prev,
                                        isRecurring: e.target.checked
                                    } as TaskFormData))}
                                />
                                <label className="text-sm font-medium">Recurring Task</label>
                            </div>
                            {formData.isRecurring && (
                                <div>
                                    <label className="block text-sm font-medium mb-1">Frequency (days)</label>
                                    <Input
                                        type="number"
                                        name="frequencyInDays"
                                        value={formData.frequencyInDays}
                                        onChange={handleInputChange}
                                        min="1"
                                    />
                                </div>
                            )}
                        </>
                    )}
                    {formData.type === 'goal' && (
                        <div>
                            <label className="block text-sm font-medium mb-1">Target Date</label>
                            <Input
                                type="date"
                                name="targetDate"
                                value={formData.targetDate}
                                onChange={handleInputChange}
                            />
                        </div>
                    )}
                    <Button 
                        type="submit" 
                        className="w-full bg-blue-600 hover:bg-blue-700 text-white font-medium py-2 px-4 rounded-lg transition-colors"
                    >
                        Create Item
                    </Button>
                </form>
            </DialogContent>
        </Dialog>
    );
} 
--------------------------------------------------------------------------------
<File: components/items/item-filters.tsx>
import {
    Select,
    SelectContent,
    SelectItem,
    SelectTrigger,
    SelectValue,
} from "@/components/ui/select";
import { Label } from "@/components/ui/label";
import { Checkbox } from "@/components/ui/checkbox";

export interface FilterOptions {
    statuses: ('Not Started' | 'Working On It' | 'Complete')[];
    sortBy: 'priority' | 'dueDate' | 'createdAt';
    sortDirection: 'asc' | 'desc';
    type?: 'all' | 'task' | 'goal';
}

interface ItemFiltersProps {
    filters: FilterOptions;
    onFiltersChange: (filters: FilterOptions) => void;
}

export function ItemFilters({ filters, onFiltersChange }: ItemFiltersProps) {
    const toggleStatus = (status: FilterOptions['statuses'][0]) => {
        const newStatuses = filters.statuses.includes(status)
            ? filters.statuses.filter(s => s !== status)
            : [...filters.statuses, status];
        onFiltersChange({ ...filters, statuses: newStatuses });
    };

    return (
        <div className="filter-panel">
            <div className="grid grid-cols-1 md:grid-cols-4 gap-8">
                <div className="space-y-4">
                    <Label className="text-sm font-semibold text-gray-700">Status</Label>
                    <div className="space-y-4 pt-1">
                        <div className="flex items-center space-x-3">
                            <Checkbox 
                                id="not_started"
                                checked={filters.statuses.includes('Not Started')}
                                onCheckedChange={() => toggleStatus('Not Started')}
                                className="border-gray-200 data-[state=checked]:bg-blue-500 data-[state=checked]:text-white"
                            />
                            <label 
                                htmlFor="not_started"
                                className="text-sm font-medium text-gray-700"
                            >
                                Not Started
                            </label>
                        </div>
                        <div className="flex items-center space-x-3">
                            <Checkbox 
                                id="working_on_it"
                                checked={filters.statuses.includes('Working On It')}
                                onCheckedChange={() => toggleStatus('Working On It')}
                                className="border-gray-200 data-[state=checked]:bg-blue-500 data-[state=checked]:text-white"
                            />
                            <label 
                                htmlFor="working_on_it"
                                className="text-sm font-medium text-gray-700"
                            >
                                Working On It
                            </label>
                        </div>
                        <div className="flex items-center space-x-3">
                            <Checkbox 
                                id="complete"
                                checked={filters.statuses.includes('Complete')}
                                onCheckedChange={() => toggleStatus('Complete')}
                                className="border-gray-200 data-[state=checked]:bg-blue-500 data-[state=checked]:text-white"
                            />
                            <label 
                                htmlFor="complete"
                                className="text-sm font-medium text-gray-700"
                            >
                                Complete
                            </label>
                        </div>
                    </div>
                </div>

                <div className="space-y-4">
                    <Label className="text-sm font-semibold text-gray-700">Sort By</Label>
                    <Select
                        value={filters.sortBy}
                        onValueChange={(value: FilterOptions['sortBy']) =>
                            onFiltersChange({ ...filters, sortBy: value })
                        }
                    >
                        <SelectTrigger className="bg-white border-gray-200 text-gray-700 hover:bg-gray-50">
                            <SelectValue placeholder="Sort by..." />
                        </SelectTrigger>
                        <SelectContent className="bg-white border-gray-200">
                            <SelectItem value="priority" className="text-gray-700 hover:bg-gray-50">Priority</SelectItem>
                            <SelectItem value="dueDate" className="text-gray-700 hover:bg-gray-50">Due Date</SelectItem>
                            <SelectItem value="createdAt" className="text-gray-700 hover:bg-gray-50">Created Date</SelectItem>
                        </SelectContent>
                    </Select>
                </div>

                <div className="space-y-4">
                    <Label className="text-sm font-semibold text-gray-700">Sort Direction</Label>
                    <Select
                        value={filters.sortDirection}
                        onValueChange={(value: FilterOptions['sortDirection']) =>
                            onFiltersChange({ ...filters, sortDirection: value })
                        }
                    >
                        <SelectTrigger className="bg-white border-gray-200 text-gray-700 hover:bg-gray-50">
                            <SelectValue placeholder="Sort direction..." />
                        </SelectTrigger>
                        <SelectContent className="bg-white border-gray-200">
                            <SelectItem value="asc" className="text-gray-700 hover:bg-gray-50">Ascending</SelectItem>
                            <SelectItem value="desc" className="text-gray-700 hover:bg-gray-50">Descending</SelectItem>
                        </SelectContent>
                    </Select>
                </div>

                <div className="space-y-4">
                    <Label className="text-sm font-semibold text-gray-700">Type</Label>
                    <Select
                        value={filters.type || 'all'}
                        onValueChange={(value: NonNullable<FilterOptions['type']>) =>
                            onFiltersChange({ ...filters, type: value === 'all' ? undefined : value })
                        }
                    >
                        <SelectTrigger className="bg-white border-gray-200 text-gray-700 hover:bg-gray-50">
                            <SelectValue placeholder="Select type..." />
                        </SelectTrigger>
                        <SelectContent className="bg-white border-gray-200">
                            <SelectItem value="all" className="text-gray-700 hover:bg-gray-50">All Types</SelectItem>
                            <SelectItem value="task" className="text-gray-700 hover:bg-gray-50">Tasks</SelectItem>
                            <SelectItem value="goal" className="text-gray-700 hover:bg-gray-50">Goals</SelectItem>
                        </SelectContent>
                    </Select>
                </div>
            </div>
        </div>
    );
} 
--------------------------------------------------------------------------------
<File: components/ui/badge.tsx>
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center rounded-md border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground shadow hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground shadow hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  )
}

export { Badge, badgeVariants }

--------------------------------------------------------------------------------
<File: components/ui/button.tsx>
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
        outline:
          "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants } 
--------------------------------------------------------------------------------
<File: components/ui/card.tsx>
import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-lg border border-border/40 shadow-sm hover:shadow-md transition-all duration-200",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h3
    ref={ref}
    className={cn("text-lg font-semibold leading-none tracking-tight text-card-foreground", className)}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }

--------------------------------------------------------------------------------
<File: components/ui/checkbox.tsx>
"use client"

import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { Check } from "lucide-react"

import { cn } from "@/lib/utils"

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary shadow focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn("flex items-center justify-center text-current")}
    >
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
))
Checkbox.displayName = CheckboxPrimitive.Root.displayName

export { Checkbox }

--------------------------------------------------------------------------------
<File: components/ui/dialog.tsx>
import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { cn } from "@/lib/utils"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogTrigger,
  DialogClose,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
} 
--------------------------------------------------------------------------------
<File: components/ui/input.tsx>
import * as React from "react"
import { cn } from "@/lib/utils"

export interface InputProps
  extends React.InputHTMLAttributes<HTMLInputElement> {}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-9 w-full rounded-md border border-input bg-background px-3 py-1 text-sm shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input } 
--------------------------------------------------------------------------------
<File: components/ui/label.tsx>
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }

--------------------------------------------------------------------------------
<File: components/ui/select.tsx>
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"

import { cn } from "@/lib/utils"

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-9 w-full items-center justify-between whitespace-nowrap rounded-md border border-input bg-transparent px-3 py-2 text-sm shadow-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-1 focus:ring-ring disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("px-2 py-1.5 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-2 pr-8 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute right-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>
    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}

--------------------------------------------------------------------------------
<File: components/ui/switch.tsx>
"use client"

import * as React from "react"
import * as SwitchPrimitives from "@radix-ui/react-switch"

import { cn } from "@/lib/utils"

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-5 w-9 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-4 w-4 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-4 data-[state=unchecked]:translate-x-0"
      )}
    />
  </SwitchPrimitives.Root>
))
Switch.displayName = SwitchPrimitives.Root.displayName

export { Switch }

--------------------------------------------------------------------------------
<File: components/weekly-plan/calendar-day.tsx>
'use client';

import { useState } from 'react';
import { TaskItem } from '@/types/items';
import { format } from 'date-fns';
import { X, Check } from 'lucide-react';
import { cn } from '@/lib/utils';

interface CalendarDayProps {
  date: Date;
  tasks: TaskItem[];
  onDrop: (task: TaskItem, sourceDate?: string) => void;
  onTaskUnschedule: (task: TaskItem) => void;
  onTaskComplete?: (task: TaskItem) => void;
}

export function CalendarDay({ 
  date, 
  tasks, 
  onDrop, 
  onTaskUnschedule,
  onTaskComplete 
}: CalendarDayProps) {
  const [isDragOver, setIsDragOver] = useState(false);
  const [completingTasks, setCompletingTasks] = useState<Set<string>>(new Set());
  const dateKey = format(date, 'yyyy-MM-dd');

  const handleDragOver = (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragOver(true);
  };

  const handleDragLeave = () => {
    setIsDragOver(false);
  };

  const handleDrop = (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragOver(false);
    
    try {
      const taskData = e.dataTransfer.getData('text/plain');
      const task = JSON.parse(taskData) as TaskItem;
      const sourceDate = e.dataTransfer.getData('source-date');
      onDrop(task, sourceDate || undefined);
    } catch (error) {
      console.error('Error handling drop:', error);
    }
  };

  const handleTaskComplete = (task: TaskItem) => {
    if (!onTaskComplete || completingTasks.has(task.id)) return;
    
    // Add task to completing set
    setCompletingTasks(prev => new Set(prev).add(task.id));

    // Wait for animation to complete before calling parent handler
    setTimeout(() => {
      onTaskComplete(task);
    }, 800);
  };

  return (
    <div
      onDragOver={handleDragOver}
      onDragLeave={handleDragLeave}
      onDrop={handleDrop}
      className={`h-full p-2 space-y-2 transition-colors ${
        isDragOver ? 'bg-blue-50' : ''
      }`}
    >
      {tasks.length === 0 && (
        <div className="h-full flex items-start justify-center pt-8 text-gray-400 text-sm">
          Drop tasks here
        </div>
      )}
      {tasks.map((task) => (
        <div
          key={task.id}
          draggable
          onDragStart={(e) => {
            e.dataTransfer.setData('text/plain', JSON.stringify(task));
            e.dataTransfer.setData('source-date', dateKey);
          }}
          className={cn(
            "group p-2 bg-white rounded-lg border border-gray-200 shadow-sm hover:shadow-md transition-all relative cursor-move hover:border-gray-300",
            completingTasks.has(task.id) && "animate-complete"
          )}
        >
          <div className="absolute left-2 top-1/2 -translate-y-1/2">
            <button
              onClick={() => handleTaskComplete(task)}
              className={cn(
                "w-5 h-5 rounded border-2 border-gray-300 hover:border-green-500 transition-colors flex items-center justify-center",
                completingTasks.has(task.id) && "bg-green-500 border-green-500"
              )}
            >
              {completingTasks.has(task.id) && (
                <Check className="h-3 w-3 text-white animate-check" />
              )}
            </button>
          </div>
          <button
            onClick={() => onTaskUnschedule(task)}
            className="absolute top-1 right-1 p-1 rounded-full opacity-0 group-hover:opacity-100 hover:bg-gray-100 transition-opacity"
            title="Remove from calendar"
          >
            <X className="h-3 w-3 text-gray-500" />
          </button>
          <div className="pl-7 pr-6">
            <h4 className={cn(
              "text-sm font-medium text-gray-900",
              completingTasks.has(task.id) && "line-through text-gray-500"
            )}>
              {task.title}
            </h4>
            <div className="mt-1 flex items-center gap-2">
              <span className={`priority-badge ${task.displayPriority.toLowerCase().replace(' ', '-')}`}>
                {task.displayPriority}
              </span>
            </div>
          </div>
        </div>
      ))}
    </div>
  );
} 
--------------------------------------------------------------------------------
<File: components/weekly-plan/task-list.tsx>
'use client';

import { useState } from 'react';
import { TaskItem } from '@/types/items';

interface TaskListProps {
  tasks: TaskItem[];
  loading: boolean;
  error: string | null;
  onTaskReturn?: (task: TaskItem, sourceDate: string) => void;
}

export function TaskList({ tasks, loading, error, onTaskReturn }: TaskListProps) {
  const [isDragOver, setIsDragOver] = useState(false);

  const handleDragOver = (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragOver(true);
  };

  const handleDragLeave = () => {
    setIsDragOver(false);
  };

  const handleDrop = (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragOver(false);

    try {
      const taskData = e.dataTransfer.getData('text/plain');
      const sourceDate = e.dataTransfer.getData('source-date');
      if (sourceDate && onTaskReturn) {
        const task = JSON.parse(taskData) as TaskItem;
        onTaskReturn(task, sourceDate);
      }
    } catch (error) {
      console.error('Error handling drop:', error);
    }
  };

  if (loading) {
    return (
      <div className="flex items-center justify-center h-40">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-gray-900"></div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="text-center py-8 text-red-500">
        {error}
      </div>
    );
  }

  return (
    <div 
      onDragOver={handleDragOver}
      onDragLeave={handleDragLeave}
      onDrop={handleDrop}
      className={`space-y-2 min-h-[200px] transition-colors rounded-lg ${
        isDragOver ? 'bg-blue-50' : ''
      }`}
    >
      {tasks.map((task) => (
        <div
          key={task.id}
          draggable
          onDragStart={(e) => {
            e.dataTransfer.setData('text/plain', JSON.stringify(task));
          }}
          className="p-3 bg-white rounded-lg border border-gray-200 cursor-move hover:border-gray-300 transition-colors"
        >
          <h3 className="font-medium text-sm">{task.title}</h3>
          <div className="mt-1 flex items-center gap-2">
            <span className={`priority-badge ${task.displayPriority.toLowerCase().replace(' ', '-')}`}>
              {task.displayPriority}
            </span>
            <span className={`status-badge ${task.status.toLowerCase().replace(' ', '-')}`}>
              {task.status}
            </span>
          </div>
        </div>
      ))}
      {tasks.length === 0 && (
        <div className="text-center py-8 text-gray-500">
          {isDragOver ? 'Drop to unschedule task' : 'No tasks available'}
        </div>
      )}
    </div>
  );
} 
--------------------------------------------------------------------------------
<File: contexts/app-context.tsx>
'use client';

import { createContext, useContext, useEffect, useState } from 'react';
import { TaskItem, GoalItem } from '@/types/items';

type Item = TaskItem | GoalItem;

interface AppContextType {
  items: Item[];
  loading: boolean;
  error: string | null;
  refreshItems: () => Promise<void>;
  updateItem: (updatedItem: Item) => Promise<void>;
  createItem: (newItem: Omit<Item, 'id' | 'createdAt' | 'updatedAt'>) => Promise<void>;
}

const AppContext = createContext<AppContextType | undefined>(undefined);

export function AppProvider({ children }: { children: React.ReactNode }) {
  const [items, setItems] = useState<Item[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchItems = async () => {
    try {
      setError(null);
      setLoading(true);
      const response = await fetch('http://localhost:5000/api/get-master-list');
      if (!response.ok) {
        throw new Error('Failed to fetch items');
      }
      const data = await response.json();
      setItems(data);
    } catch (error) {
      setError(error instanceof Error ? error.message : 'Failed to fetch items');
    } finally {
      setLoading(false);
    }
  };

  // Initial fetch on mount
  useEffect(() => {
    fetchItems();
  }, []);

  const refreshItems = async () => {
    await fetchItems();
  };

  const updateItem = async (updatedItem: Item) => {
    try {
      const response = await fetch('http://localhost:5000/api/batch-update', {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          updates: [updatedItem],
        }),
      });

      if (!response.ok) {
        throw new Error('Failed to update item');
      }

      // Update local state
      setItems(prevItems =>
        prevItems.map(item =>
          item.id === updatedItem.id ? updatedItem : item
        )
      );
    } catch (error) {
      setError(error instanceof Error ? error.message : 'Failed to update item');
      throw error;
    }
  };

  const createItem = async (newItem: Omit<Item, 'id' | 'createdAt' | 'updatedAt'>) => {
    try {
      const response = await fetch('http://localhost:5000/api/items', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(newItem),
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || 'Failed to create item');
      }

      // Refresh items to get the new item
      await refreshItems();
    } catch (error) {
      setError(error instanceof Error ? error.message : 'Failed to create item');
      throw error;
    }
  };

  return (
    <AppContext.Provider
      value={{
        items,
        loading,
        error,
        refreshItems,
        updateItem,
        createItem,
      }}
    >
      {children}
    </AppContext.Provider>
  );
}

export function useApp() {
  const context = useContext(AppContext);
  if (context === undefined) {
    throw new Error('useApp must be used within an AppProvider');
  }
  return context;
} 
--------------------------------------------------------------------------------
<File: lib/utils.ts>
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

--------------------------------------------------------------------------------
<File: types/items.ts>
export type Status = 'Not Started' | 'Working On It' | 'Complete';
export type Priority = 'Very High' | 'High' | 'Medium' | 'Low' | 'Very Low';
export type ItemType = 'task' | 'goal';

interface CompletionHistoryEntry {
  completedAt: string;
  nextDueDate: string;
}

export interface BaseItem {
  id: string;
  userId: string;
  type: ItemType;
  title: string;
  status: Status;
  priority: number;
  displayPriority: Priority;
  notes?: string;
  dueDate?: string;
  createdAt: string;
  updatedAt: string;
  categoryId?: string;
  subcategoryId?: string;
  isRecurring?: boolean;
  frequencyInDays?: number;
  completionHistory?: CompletionHistoryEntry[];
}

export interface TaskItem extends BaseItem {
  type: 'task';
  goalIds?: string[];
}

export interface GoalItem extends BaseItem {
  type: 'goal';
  targetDate?: string;
  taskIds?: string[];
} 
--------------------------------------------------------------------------------

<end codebase> 

